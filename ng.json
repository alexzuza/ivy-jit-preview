{
  "/node_modules/@angular/common/index.d.ts": "export * from './public_api';\r\n",
  "/node_modules/@angular/common/public_api.d.ts": "export * from './src/common';\r\n",
  "/node_modules/@angular/common/src/common.d.ts": "export { CommonModule } from './common.module';\r\nexport { NgForOf, NgIf } from './directives/index';\r\n",
  "/node_modules/@angular/common/src/common.module.d.ts": "export declare class CommonModule {\r\n}\r\n",
  "/node_modules/@angular/common/src/directives/index.d.ts": "import { NgForOf } from './ng_for_of';\r\nimport { NgIf } from './ng_if';\r\nexport { NgForOf, NgIf };\r\nexport declare const COMMON_DIRECTIVES: (typeof NgForOf | typeof NgIf)[];\r\n",
  "/node_modules/@angular/common/src/directives/ng_for_of.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { DoCheck, IterableDiffers, NgIterable, TemplateRef, TrackByFunction, ViewContainerRef } from '@angular/core';\r\nexport declare class NgForOfContext<T> {\r\n    $implicit: T;\r\n    ngForOf: NgIterable<T>;\r\n    index: number;\r\n    count: number;\r\n    constructor($implicit: T, ngForOf: NgIterable<T>, index: number, count: number);\r\n    readonly first: boolean;\r\n    readonly last: boolean;\r\n    readonly even: boolean;\r\n    readonly odd: boolean;\r\n}\r\n/**\r\n * The `NgForOf` directive instantiates a template once per item from an iterable. The context\r\n * for each instantiated template inherits from the outer context with the given loop variable\r\n * set to the current item from the iterable.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Local Variables\r\n *\r\n * `NgForOf` provides several exported values that can be aliased to local variables:\r\n *\r\n * - `$implicit: T`: The value of the individual items in the iterable (`ngForOf`).\r\n * - `ngForOf: NgIterable<T>`: The value of the iterable expression. Useful when the expression is\r\n * more complex then a property access, for example when using the async pipe (`userStreams |\r\n * async`).\r\n * - `index: number`: The index of the current item in the iterable.\r\n * - `first: boolean`: True when the item is the first item in the iterable.\r\n * - `last: boolean`: True when the item is the last item in the iterable.\r\n * - `even: boolean`: True when the item has an even index in the iterable.\r\n * - `odd: boolean`: True when the item has an odd index in the iterable.\r\n *\r\n * ```\r\n * <li *ngFor=\"let user of userObservable | async as users; index as i; first as isFirst\">\r\n *    {{i}}/{{users.length}}. {{user}} <span *ngIf=\"isFirst\">default</span>\r\n * </li>\r\n * ```\r\n *\r\n * ### Change Propagation\r\n *\r\n * When the contents of the iterator changes, `NgForOf` makes the corresponding changes to the DOM:\r\n *\r\n * * When an item is added, a new instance of the template is added to the DOM.\r\n * * When an item is removed, its template instance is removed from the DOM.\r\n * * When items are reordered, their respective templates are reordered in the DOM.\r\n * * Otherwise, the DOM element for that item will remain the same.\r\n *\r\n * Angular uses object identity to track insertions and deletions within the iterator and reproduce\r\n * those changes in the DOM. This has important implications for animations and any stateful\r\n * controls (such as `<input>` elements which accept user input) that are present. Inserted rows can\r\n * be animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state\r\n * such as user input.\r\n *\r\n * It is possible for the identities of elements in the iterator to change while the data does not.\r\n * This can happen, for example, if the iterator produced from an RPC to the server, and that\r\n * RPC is re-run. Even if the data hasn't changed, the second response will produce objects with\r\n * different identities, and Angular will tear down the entire DOM and rebuild it (as if all old\r\n * elements were deleted and all new elements inserted). This is an expensive operation and should\r\n * be avoided if possible.\r\n *\r\n * To customize the default tracking algorithm, `NgForOf` supports `trackBy` option.\r\n * `trackBy` takes a function which has two arguments: `index` and `item`.\r\n * If `trackBy` is given, Angular tracks changes by the return value of the function.\r\n *\r\n * ### Syntax\r\n *\r\n * - `<li *ngFor=\"let item of items; index as i; trackBy: trackByFn\">...</li>`\r\n *\r\n * With `<ng-template>` element:\r\n *\r\n * ```\r\n * <ng-template ngFor let-item [ngForOf]=\"items\" let-i=\"index\" [ngForTrackBy]=\"trackByFn\">\r\n *   <li>...</li>\r\n * </ng-template>\r\n * ```\r\n *\r\n * ### Example\r\n *\r\n * See a [live demo](http://plnkr.co/edit/KVuXxDp0qinGDyo307QW?p=preview) for a more detailed\r\n * example.\r\n *\r\n *\r\n */\r\nexport declare class NgForOf<T> implements DoCheck {\r\n    private _viewContainer;\r\n    private _template;\r\n    private _differs;\r\n    ngForOf: NgIterable<T>;\r\n    ngForTrackBy: TrackByFunction<T>;\r\n    private _ngForOf;\r\n    private _ngForOfDirty;\r\n    private _differ;\r\n    private _trackByFn;\r\n    constructor(_viewContainer: ViewContainerRef, _template: TemplateRef<NgForOfContext<T>>, _differs: IterableDiffers);\r\n    ngForTemplate: TemplateRef<NgForOfContext<T>>;\r\n    ngDoCheck(): void;\r\n    private _applyChanges;\r\n    private _perViewChange;\r\n}\r\nexport declare function getTypeNameForDebugging(type: any): string;\r\n",
  "/node_modules/@angular/common/src/directives/ng_if.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { TemplateRef, ViewContainerRef } from '@angular/core';\r\n/**\r\n * Conditionally includes a template based on the value of an `expression`.\r\n *\r\n * `ngIf` evaluates the `expression` and then renders the `then` or `else` template in its place\r\n * when expression is truthy or falsy respectively. Typically the:\r\n *  - `then` template is the inline template of `ngIf` unless bound to a different value.\r\n *  - `else` template is blank unless it is bound.\r\n *\r\n * ## Most common usage\r\n *\r\n * The most common usage of the `ngIf` directive is to conditionally show the inline template as\r\n * seen in this example:\r\n * {@example common/ngIf/ts/module.ts region='NgIfSimple'}\r\n *\r\n * ## Showing an alternative template using `else`\r\n *\r\n * If it is necessary to display a template when the `expression` is falsy use the `else` template\r\n * binding as shown. Note that the `else` binding points to a `<ng-template>` labeled `#elseBlock`.\r\n * The template can be defined anywhere in the component view but is typically placed right after\r\n * `ngIf` for readability.\r\n *\r\n * {@example common/ngIf/ts/module.ts region='NgIfElse'}\r\n *\r\n * ## Using non-inlined `then` template\r\n *\r\n * Usually the `then` template is the inlined template of the `ngIf`, but it can be changed using\r\n * a binding (just like `else`). Because `then` and `else` are bindings, the template references can\r\n * change at runtime as shown in this example.\r\n *\r\n * {@example common/ngIf/ts/module.ts region='NgIfThenElse'}\r\n *\r\n * ## Storing conditional result in a variable\r\n *\r\n * A common pattern is that we need to show a set of properties from the same object. If the\r\n * object is undefined, then we have to use the safe-traversal-operator `?.` to guard against\r\n * dereferencing a `null` value. This is especially the case when waiting on async data such as\r\n * when using the `async` pipe as shown in following example:\r\n *\r\n * ```\r\n * Hello {{ (userStream|async)?.last }}, {{ (userStream|async)?.first }}!\r\n * ```\r\n *\r\n * There are several inefficiencies in the above example:\r\n *  - We create multiple subscriptions on `userStream`. One for each `async` pipe, or two in the\r\n *    example above.\r\n *  - We cannot display an alternative screen while waiting for the data to arrive asynchronously.\r\n *  - We have to use the safe-traversal-operator `?.` to access properties, which is cumbersome.\r\n *  - We have to place the `async` pipe in parenthesis.\r\n *\r\n * A better way to do this is to use `ngIf` and store the result of the condition in a local\r\n * variable as shown in the the example below:\r\n *\r\n * {@example common/ngIf/ts/module.ts region='NgIfAs'}\r\n *\r\n * Notice that:\r\n *  - We use only one `async` pipe and hence only one subscription gets created.\r\n *  - `ngIf` stores the result of the `userStream|async` in the local variable `user`.\r\n *  - The local `user` can then be bound repeatedly in a more efficient way.\r\n *  - No need to use the safe-traversal-operator `?.` to access properties as `ngIf` will only\r\n *    display the data if `userStream` returns a value.\r\n *  - We can display an alternative template while waiting for the data.\r\n *\r\n * ### Syntax\r\n *\r\n * Simple form:\r\n * - `<div *ngIf=\"condition\">...</div>`\r\n * - `<ng-template [ngIf]=\"condition\"><div>...</div></ng-template>`\r\n *\r\n * Form with an else block:\r\n * ```\r\n * <div *ngIf=\"condition; else elseBlock\">...</div>\r\n * <ng-template #elseBlock>...</ng-template>\r\n * ```\r\n *\r\n * Form with a `then` and `else` block:\r\n * ```\r\n * <div *ngIf=\"condition; then thenBlock else elseBlock\"></div>\r\n * <ng-template #thenBlock>...</ng-template>\r\n * <ng-template #elseBlock>...</ng-template>\r\n * ```\r\n *\r\n * Form with storing the value locally:\r\n * ```\r\n * <div *ngIf=\"condition as value; else elseBlock\">{{value}}</div>\r\n * <ng-template #elseBlock>...</ng-template>\r\n * ```\r\n *\r\n *\r\n */\r\nexport declare class NgIf {\r\n    private _viewContainer;\r\n    private _context;\r\n    private _thenTemplateRef;\r\n    private _elseTemplateRef;\r\n    private _thenViewRef;\r\n    private _elseViewRef;\r\n    constructor(_viewContainer: ViewContainerRef, templateRef: TemplateRef<NgIfContext>);\r\n    ngIf: any;\r\n    ngIfThen: TemplateRef<NgIfContext> | null;\r\n    ngIfElse: TemplateRef<NgIfContext> | null;\r\n    private _updateView;\r\n    /** @internal */\r\n    static ngIfUseIfTypeGuard: void;\r\n}\r\nexport declare class NgIfContext {\r\n    $implicit: any;\r\n    ngIf: any;\r\n}\r\n",
  "/node_modules/@angular/compiler/compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport * from './public_api';\r\n",
  "/node_modules/@angular/compiler/index.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport * from './compiler';\r\n",
  "/node_modules/@angular/compiler/public_api.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @module\r\n * @description\r\n * Entry point for all public APIs of this package.\r\n */\r\nexport * from './src/compiler';\r\n",
  "/node_modules/@angular/compiler/src/aot/compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileInjectableMetadata, CompileNgModuleMetadata, CompileShallowModuleMetadata } from '../compile_metadata';\r\nimport { CompilerConfig } from '../config';\r\nimport { MessageBundle } from '../i18n/message_bundle';\r\nimport { InjectableCompiler } from '../injectable_compiler';\r\nimport { CompileMetadataResolver } from '../metadata_resolver';\r\nimport { NgModuleCompiler } from '../ng_module_compiler';\r\nimport { OutputEmitter } from '../output/abstract_emitter';\r\nimport { StyleCompiler } from '../style_compiler';\r\nimport { SummaryResolver } from '../summary_resolver';\r\nimport { TemplateParser } from '../template_parser/template_parser';\r\nimport { TypeCheckCompiler } from '../view_compiler/type_check_compiler';\r\nimport { ViewCompiler } from '../view_compiler/view_compiler';\r\nimport { AotCompilerHost } from './compiler_host';\r\nimport { AotCompilerOptions } from './compiler_options';\r\nimport { GeneratedFile } from './generated_file';\r\nimport { LazyRoute } from './lazy_routes';\r\nimport { PartialModule } from './partial_module';\r\nimport { StaticReflector } from './static_reflector';\r\nimport { StaticSymbol } from './static_symbol';\r\nimport { StaticSymbolResolver } from './static_symbol_resolver';\r\nexport declare class AotCompiler {\r\n    private _config;\r\n    private _options;\r\n    private _host;\r\n    readonly reflector: StaticReflector;\r\n    private _metadataResolver;\r\n    private _templateParser;\r\n    private _styleCompiler;\r\n    private _viewCompiler;\r\n    private _typeCheckCompiler;\r\n    private _ngModuleCompiler;\r\n    private _injectableCompiler;\r\n    private _outputEmitter;\r\n    private _summaryResolver;\r\n    private _symbolResolver;\r\n    private _templateAstCache;\r\n    private _analyzedFiles;\r\n    private _analyzedFilesForInjectables;\r\n    constructor(_config: CompilerConfig, _options: AotCompilerOptions, _host: AotCompilerHost, reflector: StaticReflector, _metadataResolver: CompileMetadataResolver, _templateParser: TemplateParser, _styleCompiler: StyleCompiler, _viewCompiler: ViewCompiler, _typeCheckCompiler: TypeCheckCompiler, _ngModuleCompiler: NgModuleCompiler, _injectableCompiler: InjectableCompiler, _outputEmitter: OutputEmitter, _summaryResolver: SummaryResolver<StaticSymbol>, _symbolResolver: StaticSymbolResolver);\r\n    clearCache(): void;\r\n    analyzeModulesSync(rootFiles: string[]): NgAnalyzedModules;\r\n    analyzeModulesAsync(rootFiles: string[]): Promise<NgAnalyzedModules>;\r\n    private _analyzeFile;\r\n    private _analyzeFileForInjectables;\r\n    findGeneratedFileNames(fileName: string): string[];\r\n    emitBasicStub(genFileName: string, originalFileName?: string): GeneratedFile;\r\n    emitTypeCheckStub(genFileName: string, originalFileName: string): GeneratedFile | null;\r\n    loadFilesAsync(fileNames: string[], tsFiles: string[]): Promise<{\r\n        analyzedModules: NgAnalyzedModules;\r\n        analyzedInjectables: NgAnalyzedFileWithInjectables[];\r\n    }>;\r\n    loadFilesSync(fileNames: string[], tsFiles: string[]): {\r\n        analyzedModules: NgAnalyzedModules;\r\n        analyzedInjectables: NgAnalyzedFileWithInjectables[];\r\n    };\r\n    private _createNgFactoryStub;\r\n    private _externalIdentifierReferences;\r\n    private _createTypeCheckBlock;\r\n    emitMessageBundle(analyzeResult: NgAnalyzedModules, locale: string | null): MessageBundle;\r\n    emitAllPartialModules({ ngModuleByPipeOrDirective, files }: NgAnalyzedModules, r3Files: NgAnalyzedFileWithInjectables[]): PartialModule[];\r\n    private _compileShallowModules;\r\n    private _compilePartialModule;\r\n    emitAllPartialModules2(files: NgAnalyzedFileWithInjectables[]): PartialModule[];\r\n    private _emitPartialModule2;\r\n    emitAllImpls(analyzeResult: NgAnalyzedModules): GeneratedFile[];\r\n    private _compileImplFile;\r\n    private _createSummary;\r\n    private _compileModule;\r\n    private _compileComponentFactory;\r\n    private _compileComponent;\r\n    private _parseTemplate;\r\n    private _createOutputContext;\r\n    private _fileNameToModuleName;\r\n    private _codegenStyles;\r\n    private _codegenSourceModule;\r\n    listLazyRoutes(entryRoute?: string, analyzedModules?: NgAnalyzedModules): LazyRoute[];\r\n}\r\nexport interface NgAnalyzedModules {\r\n    ngModules: CompileNgModuleMetadata[];\r\n    ngModuleByPipeOrDirective: Map<StaticSymbol, CompileNgModuleMetadata>;\r\n    files: NgAnalyzedFile[];\r\n    symbolsMissingModule?: StaticSymbol[];\r\n}\r\nexport interface NgAnalyzedFileWithInjectables {\r\n    fileName: string;\r\n    injectables: CompileInjectableMetadata[];\r\n    shallowModules: CompileShallowModuleMetadata[];\r\n}\r\nexport interface NgAnalyzedFile {\r\n    fileName: string;\r\n    directives: StaticSymbol[];\r\n    pipes: StaticSymbol[];\r\n    ngModules: CompileNgModuleMetadata[];\r\n    injectables: CompileInjectableMetadata[];\r\n    exportsNonSourceFiles: boolean;\r\n}\r\nexport interface NgAnalyzeModulesHost {\r\n    isSourceFile(filePath: string): boolean;\r\n}\r\nexport declare function analyzeNgModules(fileNames: string[], host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver, metadataResolver: CompileMetadataResolver): NgAnalyzedModules;\r\nexport declare function analyzeAndValidateNgModules(fileNames: string[], host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver, metadataResolver: CompileMetadataResolver): NgAnalyzedModules;\r\nexport declare function analyzeFile(host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver, metadataResolver: CompileMetadataResolver, fileName: string): NgAnalyzedFile;\r\nexport declare function analyzeFileForInjectables(host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver, metadataResolver: CompileMetadataResolver, fileName: string): NgAnalyzedFileWithInjectables;\r\nexport declare function mergeAnalyzedFiles(analyzedFiles: NgAnalyzedFile[]): NgAnalyzedModules;\r\n",
  "/node_modules/@angular/compiler/src/aot/compiler_factory.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { UrlResolver } from '../url_resolver';\r\nimport { AotCompiler } from './compiler';\r\nimport { AotCompilerHost } from './compiler_host';\r\nimport { AotCompilerOptions } from './compiler_options';\r\nimport { StaticReflector } from './static_reflector';\r\nexport declare function createAotUrlResolver(host: {\r\n    resourceNameToFileName(resourceName: string, containingFileName: string): string | null;\r\n}): UrlResolver;\r\n/**\r\n * Creates a new AotCompiler based on options and a host.\r\n */\r\nexport declare function createAotCompiler(compilerHost: AotCompilerHost, options: AotCompilerOptions, errorCollector?: (error: any, type?: any) => void): {\r\n    compiler: AotCompiler;\r\n    reflector: StaticReflector;\r\n};\r\n",
  "/node_modules/@angular/compiler/src/aot/compiler_host.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { StaticSymbolResolverHost } from './static_symbol_resolver';\r\nimport { AotSummaryResolverHost } from './summary_resolver';\r\n/**\r\n * The host of the AotCompiler disconnects the implementation from TypeScript / other language\r\n * services and from underlying file systems.\r\n */\r\nexport interface AotCompilerHost extends StaticSymbolResolverHost, AotSummaryResolverHost {\r\n    /**\r\n     * Converts a file path to a module name that can be used as an `import.\r\n     * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.\r\n     *\r\n     * See ImportResolver.\r\n     */\r\n    fileNameToModuleName(importedFilePath: string, containingFilePath: string): string;\r\n    /**\r\n     * Converts a path that refers to a resource into an absolute filePath\r\n     * that can be later on used for loading the resource via `loadResource.\r\n     */\r\n    resourceNameToFileName(resourceName: string, containingFileName: string): string | null;\r\n    /**\r\n     * Loads a resource (e.g. html / css)\r\n     */\r\n    loadResource(path: string): Promise<string> | string;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/aot/compiler_options.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { MissingTranslationStrategy } from '../core';\r\nexport interface AotCompilerOptions {\r\n    locale?: string;\r\n    i18nFormat?: string;\r\n    translations?: string;\r\n    missingTranslation?: MissingTranslationStrategy;\r\n    enableSummariesForJit?: boolean;\r\n    preserveWhitespaces?: boolean;\r\n    fullTemplateTypeCheck?: boolean;\r\n    allowEmptyCodegenFiles?: boolean;\r\n    strictInjectionParameters?: boolean;\r\n    enableIvy?: boolean | 'ngtsc' | 'tsc';\r\n}\r\n",
  "/node_modules/@angular/compiler/src/aot/formatted_error.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport interface Position {\r\n    fileName: string;\r\n    line: number;\r\n    column: number;\r\n}\r\nexport interface FormattedMessageChain {\r\n    message: string;\r\n    position?: Position;\r\n    next?: FormattedMessageChain;\r\n}\r\nexport declare type FormattedError = Error & {\r\n    chain: FormattedMessageChain;\r\n    position?: Position;\r\n};\r\nexport declare function formattedError(chain: FormattedMessageChain): FormattedError;\r\nexport declare function isFormattedError(error: Error): error is FormattedError;\r\n",
  "/node_modules/@angular/compiler/src/aot/generated_file.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Statement } from '../output/output_ast';\r\nexport declare class GeneratedFile {\r\n    srcFileUrl: string;\r\n    genFileUrl: string;\r\n    source: string | null;\r\n    stmts: Statement[] | null;\r\n    constructor(srcFileUrl: string, genFileUrl: string, sourceOrStmts: string | Statement[]);\r\n    isEquivalent(other: GeneratedFile): boolean;\r\n}\r\nexport declare function toTypeScript(file: GeneratedFile, preamble?: string): string;\r\n",
  "/node_modules/@angular/compiler/src/aot/lazy_routes.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileNgModuleMetadata } from '../compile_metadata';\r\nimport { StaticReflector } from './static_reflector';\r\nimport { StaticSymbol } from './static_symbol';\r\nexport interface LazyRoute {\r\n    module: StaticSymbol;\r\n    route: string;\r\n    referencedModule: StaticSymbol;\r\n}\r\nexport declare function listLazyRoutes(moduleMeta: CompileNgModuleMetadata, reflector: StaticReflector): LazyRoute[];\r\nexport declare function parseLazyRoute(route: string, reflector: StaticReflector, module?: StaticSymbol): LazyRoute;\r\n",
  "/node_modules/@angular/compiler/src/aot/partial_module.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as o from '../output/output_ast';\r\nexport interface PartialModule {\r\n    fileName: string;\r\n    statements: o.Statement[];\r\n}\r\n",
  "/node_modules/@angular/compiler/src/aot/static_reflector.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileReflector } from '../compile_reflector';\r\nimport * as o from '../output/output_ast';\r\nimport { SummaryResolver } from '../summary_resolver';\r\nimport { StaticSymbol } from './static_symbol';\r\nimport { StaticSymbolResolver } from './static_symbol_resolver';\r\n/**\r\n * A static reflector implements enough of the Reflector API that is necessary to compile\r\n * templates statically.\r\n */\r\nexport declare class StaticReflector implements CompileReflector {\r\n    private summaryResolver;\r\n    private symbolResolver;\r\n    private errorRecorder?;\r\n    private annotationCache;\r\n    private shallowAnnotationCache;\r\n    private propertyCache;\r\n    private parameterCache;\r\n    private methodCache;\r\n    private staticCache;\r\n    private conversionMap;\r\n    private resolvedExternalReferences;\r\n    private injectionToken;\r\n    private opaqueToken;\r\n    ROUTES: StaticSymbol;\r\n    private ANALYZE_FOR_ENTRY_COMPONENTS;\r\n    private annotationForParentClassWithSummaryKind;\r\n    constructor(summaryResolver: SummaryResolver<StaticSymbol>, symbolResolver: StaticSymbolResolver, knownMetadataClasses?: {\r\n        name: string;\r\n        filePath: string;\r\n        ctor: any;\r\n    }[], knownMetadataFunctions?: {\r\n        name: string;\r\n        filePath: string;\r\n        fn: any;\r\n    }[], errorRecorder?: (error: any, fileName?: string) => void);\r\n    componentModuleUrl(typeOrFunc: StaticSymbol): string;\r\n    resolveExternalReference(ref: o.ExternalReference, containingFile?: string): StaticSymbol;\r\n    findDeclaration(moduleUrl: string, name: string, containingFile?: string): StaticSymbol;\r\n    tryFindDeclaration(moduleUrl: string, name: string, containingFile?: string): StaticSymbol;\r\n    findSymbolDeclaration(symbol: StaticSymbol): StaticSymbol;\r\n    tryAnnotations(type: StaticSymbol): any[];\r\n    annotations(type: StaticSymbol): any[];\r\n    shallowAnnotations(type: StaticSymbol): any[];\r\n    private _annotations;\r\n    propMetadata(type: StaticSymbol): {\r\n        [key: string]: any[];\r\n    };\r\n    parameters(type: StaticSymbol): any[];\r\n    private _methodNames;\r\n    private _staticMembers;\r\n    private findParentType;\r\n    hasLifecycleHook(type: any, lcProperty: string): boolean;\r\n    guards(type: any): {\r\n        [key: string]: StaticSymbol;\r\n    };\r\n    private _registerDecoratorOrConstructor;\r\n    private _registerFunction;\r\n    private initializeConversionMap;\r\n    /**\r\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\r\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\r\n     *\r\n     * @param declarationFile the absolute path of the file where the symbol is declared\r\n     * @param name the name of the type.\r\n     */\r\n    getStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol;\r\n    /**\r\n     * Simplify but discard any errors\r\n     */\r\n    private trySimplify;\r\n    /** @internal */\r\n    simplify(context: StaticSymbol, value: any, lazy?: boolean): any;\r\n    private getTypeMetadata;\r\n    private reportError;\r\n    private error;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/aot/static_symbol.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A token representing the a reference to a static type.\r\n *\r\n * This token is unique for a filePath and name and can be used as a hash table key.\r\n */\r\nexport declare class StaticSymbol {\r\n    filePath: string;\r\n    name: string;\r\n    members: string[];\r\n    constructor(filePath: string, name: string, members: string[]);\r\n    assertNoMembers(): void;\r\n}\r\n/**\r\n * A cache of static symbol used by the StaticReflector to return the same symbol for the\r\n * same symbol values.\r\n */\r\nexport declare class StaticSymbolCache {\r\n    private cache;\r\n    get(declarationFile: string, name: string, members?: string[]): StaticSymbol;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/aot/static_symbol_resolver.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { SummaryResolver } from '../summary_resolver';\r\nimport { StaticSymbol, StaticSymbolCache } from './static_symbol';\r\nexport declare class ResolvedStaticSymbol {\r\n    symbol: StaticSymbol;\r\n    metadata: any;\r\n    constructor(symbol: StaticSymbol, metadata: any);\r\n}\r\n/**\r\n * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other\r\n * language\r\n * services and from underlying file systems.\r\n */\r\nexport interface StaticSymbolResolverHost {\r\n    /**\r\n     * Return a ModuleMetadata for the given module.\r\n     * Angular CLI will produce this metadata for a module whenever a .d.ts files is\r\n     * produced and the module has exported variables or classes with decorators. Module metadata can\r\n     * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.\r\n     *\r\n     * @param modulePath is a string identifier for a module as an absolute path.\r\n     * @returns the metadata for the given module.\r\n     */\r\n    getMetadataFor(modulePath: string): {\r\n        [key: string]: any;\r\n    }[] | undefined;\r\n    /**\r\n     * Converts a module name that is used in an `import` to a file path.\r\n     * I.e.\r\n     * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\r\n     */\r\n    moduleNameToFileName(moduleName: string, containingFile?: string): string | null;\r\n    /**\r\n     * Get a file suitable for display to the user that should be relative to the project directory\r\n     * or the current directory.\r\n     */\r\n    getOutputName(filePath: string): string;\r\n}\r\n/**\r\n * This class is responsible for loading metadata per symbol,\r\n * and normalizing references between symbols.\r\n *\r\n * Internally, it only uses symbols without members,\r\n * and deduces the values for symbols with members based\r\n * on these symbols.\r\n */\r\nexport declare class StaticSymbolResolver {\r\n    private host;\r\n    private staticSymbolCache;\r\n    private summaryResolver;\r\n    private errorRecorder?;\r\n    private metadataCache;\r\n    private resolvedSymbols;\r\n    private resolvedFilePaths;\r\n    private importAs;\r\n    private symbolResourcePaths;\r\n    private symbolFromFile;\r\n    private knownFileNameToModuleNames;\r\n    constructor(host: StaticSymbolResolverHost, staticSymbolCache: StaticSymbolCache, summaryResolver: SummaryResolver<StaticSymbol>, errorRecorder?: (error: any, fileName?: string) => void);\r\n    resolveSymbol(staticSymbol: StaticSymbol): ResolvedStaticSymbol;\r\n    /**\r\n     * getImportAs produces a symbol that can be used to import the given symbol.\r\n     * The import might be different than the symbol if the symbol is exported from\r\n     * a library with a summary; in which case we want to import the symbol from the\r\n     * ngfactory re-export instead of directly to avoid introducing a direct dependency\r\n     * on an otherwise indirect dependency.\r\n     *\r\n     * @param staticSymbol the symbol for which to generate a import symbol\r\n     */\r\n    getImportAs(staticSymbol: StaticSymbol, useSummaries?: boolean): StaticSymbol | null;\r\n    /**\r\n     * getResourcePath produces the path to the original location of the symbol and should\r\n     * be used to determine the relative location of resource references recorded in\r\n     * symbol metadata.\r\n     */\r\n    getResourcePath(staticSymbol: StaticSymbol): string;\r\n    /**\r\n     * getTypeArity returns the number of generic type parameters the given symbol\r\n     * has. If the symbol is not a type the result is null.\r\n     */\r\n    getTypeArity(staticSymbol: StaticSymbol): number | null;\r\n    getKnownModuleName(filePath: string): string | null;\r\n    recordImportAs(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol): void;\r\n    recordModuleNameForFileName(fileName: string, moduleName: string): void;\r\n    /**\r\n     * Invalidate all information derived from the given file.\r\n     *\r\n     * @param fileName the file to invalidate\r\n     */\r\n    invalidateFile(fileName: string): void;\r\n    /** @internal */\r\n    ignoreErrorsFor<T>(cb: () => T): T;\r\n    private _resolveSymbolMembers;\r\n    private _resolveSymbolFromSummary;\r\n    /**\r\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\r\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\r\n     *\r\n     * @param declarationFile the absolute path of the file where the symbol is declared\r\n     * @param name the name of the type.\r\n     * @param members a symbol for a static member of the named type\r\n     */\r\n    getStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol;\r\n    /**\r\n     * hasDecorators checks a file's metadata for the presence of decorators without evaluating the\r\n     * metadata.\r\n     *\r\n     * @param filePath the absolute path to examine for decorators.\r\n     * @returns true if any class in the file has a decorator.\r\n     */\r\n    hasDecorators(filePath: string): boolean;\r\n    getSymbolsOf(filePath: string): StaticSymbol[];\r\n    private _createSymbolsOf;\r\n    private createResolvedSymbol;\r\n    private createExport;\r\n    private reportError;\r\n    /**\r\n     * @param module an absolute path to a module file.\r\n     */\r\n    private getModuleMetadata;\r\n    getSymbolByModule(module: string, symbolName: string, containingFile?: string): StaticSymbol;\r\n    private resolveModule;\r\n}\r\nexport declare function unescapeIdentifier(identifier: string): string;\r\nexport declare function unwrapResolvedMetadata(metadata: any): any;\r\n",
  "/node_modules/@angular/compiler/src/aot/summary_resolver.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Summary, SummaryResolver } from '../summary_resolver';\r\nimport { StaticSymbol, StaticSymbolCache } from './static_symbol';\r\nexport interface AotSummaryResolverHost {\r\n    /**\r\n     * Loads an NgModule/Directive/Pipe summary file\r\n     */\r\n    loadSummary(filePath: string): string | null;\r\n    /**\r\n     * Returns whether a file is a source file or not.\r\n     */\r\n    isSourceFile(sourceFilePath: string): boolean;\r\n    /**\r\n     * Converts a file name into a representation that should be stored in a summary file.\r\n     * This has to include changing the suffix as well.\r\n     * E.g.\r\n     * `some_file.ts` -> `some_file.d.ts`\r\n     *\r\n     * @param referringSrcFileName the soure file that refers to fileName\r\n     */\r\n    toSummaryFileName(fileName: string, referringSrcFileName: string): string;\r\n    /**\r\n     * Converts a fileName that was processed by `toSummaryFileName` back into a real fileName\r\n     * given the fileName of the library that is referrig to it.\r\n     */\r\n    fromSummaryFileName(fileName: string, referringLibFileName: string): string;\r\n}\r\nexport declare class AotSummaryResolver implements SummaryResolver<StaticSymbol> {\r\n    private host;\r\n    private staticSymbolCache;\r\n    private summaryCache;\r\n    private loadedFilePaths;\r\n    private importAs;\r\n    private knownFileNameToModuleNames;\r\n    constructor(host: AotSummaryResolverHost, staticSymbolCache: StaticSymbolCache);\r\n    isLibraryFile(filePath: string): boolean;\r\n    toSummaryFileName(filePath: string, referringSrcFileName: string): string;\r\n    fromSummaryFileName(fileName: string, referringLibFileName: string): string;\r\n    resolveSummary(staticSymbol: StaticSymbol): Summary<StaticSymbol> | null;\r\n    getSymbolsOf(filePath: string): StaticSymbol[] | null;\r\n    getImportAs(staticSymbol: StaticSymbol): StaticSymbol;\r\n    /**\r\n     * Converts a file path to a module name that can be used as an `import`.\r\n     */\r\n    getKnownModuleName(importedFilePath: string): string | null;\r\n    addSummary(summary: Summary<StaticSymbol>): void;\r\n    private _loadSummaryFile;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/aot/summary_serializer.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileDirectiveMetadata, CompileNgModuleMetadata, CompilePipeMetadata, CompileTypeMetadata, CompileTypeSummary } from '../compile_metadata';\r\nimport { Summary, SummaryResolver } from '../summary_resolver';\r\nimport { OutputContext } from '../util';\r\nimport { StaticSymbol, StaticSymbolCache } from './static_symbol';\r\nimport { ResolvedStaticSymbol, StaticSymbolResolver } from './static_symbol_resolver';\r\nexport declare function serializeSummaries(srcFileName: string, forJitCtx: OutputContext | null, summaryResolver: SummaryResolver<StaticSymbol>, symbolResolver: StaticSymbolResolver, symbols: ResolvedStaticSymbol[], types: {\r\n    summary: CompileTypeSummary;\r\n    metadata: CompileNgModuleMetadata | CompileDirectiveMetadata | CompilePipeMetadata | CompileTypeMetadata;\r\n}[]): {\r\n    json: string;\r\n    exportAs: {\r\n        symbol: StaticSymbol;\r\n        exportAs: string;\r\n    }[];\r\n};\r\nexport declare function deserializeSummaries(symbolCache: StaticSymbolCache, summaryResolver: SummaryResolver<StaticSymbol>, libraryFileName: string, json: string): {\r\n    moduleName: string | null;\r\n    summaries: Summary<StaticSymbol>[];\r\n    importAs: {\r\n        symbol: StaticSymbol;\r\n        importAs: StaticSymbol;\r\n    }[];\r\n};\r\nexport declare function createForJitStub(outputCtx: OutputContext, reference: StaticSymbol): void;\r\n",
  "/node_modules/@angular/compiler/src/aot/util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare function ngfactoryFilePath(filePath: string, forceSourceFile?: boolean): string;\r\nexport declare function stripGeneratedFileSuffix(filePath: string): string;\r\nexport declare function isGeneratedFile(filePath: string): boolean;\r\nexport declare function splitTypescriptSuffix(path: string, forceSourceFile?: boolean): string[];\r\nexport declare function normalizeGenFileSuffix(srcFileSuffix: string): string;\r\nexport declare function summaryFileName(fileName: string): string;\r\nexport declare function summaryForJitFileName(fileName: string, forceSourceFile?: boolean): string;\r\nexport declare function stripSummaryForJitFileSuffix(filePath: string): string;\r\nexport declare function summaryForJitName(symbolName: string): string;\r\nexport declare function stripSummaryForJitNameSuffix(symbolName: string): string;\r\nexport declare function isLoweredSymbol(name: string): boolean;\r\nexport declare function createLoweredSymbol(id: number): string;\r\n",
  "/node_modules/@angular/compiler/src/assertions.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare function assertArrayOfStrings(identifier: string, value: any): void;\r\nexport declare function assertInterpolationSymbols(identifier: string, value: any): void;\r\n",
  "/node_modules/@angular/compiler/src/ast_path.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A path is an ordered set of elements. Typically a path is to  a\r\n * particular offset in a source file. The head of the list is the top\r\n * most node. The tail is the node that contains the offset directly.\r\n *\r\n * For example, the expression `a + b + c` might have an ast that looks\r\n * like:\r\n *     +\r\n *    / \\\r\n *   a   +\r\n *      / \\\r\n *     b   c\r\n *\r\n * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,\r\n * 'c' at 9-10]` and the path the node at offset 1 would be\r\n * `['+' at 1-10, 'a' at 1-2]`.\r\n */\r\nexport declare class AstPath<T> {\r\n    private path;\r\n    position: number;\r\n    constructor(path: T[], position?: number);\r\n    readonly empty: boolean;\r\n    readonly head: T | undefined;\r\n    readonly tail: T | undefined;\r\n    parentOf(node: T | undefined): T | undefined;\r\n    childOf(node: T): T | undefined;\r\n    first<N extends T>(ctor: {\r\n        new (...args: any[]): N;\r\n    }): N | undefined;\r\n    push(node: T): void;\r\n    pop(): T;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/chars.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare const $EOF = 0;\r\nexport declare const $TAB = 9;\r\nexport declare const $LF = 10;\r\nexport declare const $VTAB = 11;\r\nexport declare const $FF = 12;\r\nexport declare const $CR = 13;\r\nexport declare const $SPACE = 32;\r\nexport declare const $BANG = 33;\r\nexport declare const $DQ = 34;\r\nexport declare const $HASH = 35;\r\nexport declare const $$ = 36;\r\nexport declare const $PERCENT = 37;\r\nexport declare const $AMPERSAND = 38;\r\nexport declare const $SQ = 39;\r\nexport declare const $LPAREN = 40;\r\nexport declare const $RPAREN = 41;\r\nexport declare const $STAR = 42;\r\nexport declare const $PLUS = 43;\r\nexport declare const $COMMA = 44;\r\nexport declare const $MINUS = 45;\r\nexport declare const $PERIOD = 46;\r\nexport declare const $SLASH = 47;\r\nexport declare const $COLON = 58;\r\nexport declare const $SEMICOLON = 59;\r\nexport declare const $LT = 60;\r\nexport declare const $EQ = 61;\r\nexport declare const $GT = 62;\r\nexport declare const $QUESTION = 63;\r\nexport declare const $0 = 48;\r\nexport declare const $9 = 57;\r\nexport declare const $A = 65;\r\nexport declare const $E = 69;\r\nexport declare const $F = 70;\r\nexport declare const $X = 88;\r\nexport declare const $Z = 90;\r\nexport declare const $LBRACKET = 91;\r\nexport declare const $BACKSLASH = 92;\r\nexport declare const $RBRACKET = 93;\r\nexport declare const $CARET = 94;\r\nexport declare const $_ = 95;\r\nexport declare const $a = 97;\r\nexport declare const $e = 101;\r\nexport declare const $f = 102;\r\nexport declare const $n = 110;\r\nexport declare const $r = 114;\r\nexport declare const $t = 116;\r\nexport declare const $u = 117;\r\nexport declare const $v = 118;\r\nexport declare const $x = 120;\r\nexport declare const $z = 122;\r\nexport declare const $LBRACE = 123;\r\nexport declare const $BAR = 124;\r\nexport declare const $RBRACE = 125;\r\nexport declare const $NBSP = 160;\r\nexport declare const $PIPE = 124;\r\nexport declare const $TILDA = 126;\r\nexport declare const $AT = 64;\r\nexport declare const $BT = 96;\r\nexport declare function isWhitespace(code: number): boolean;\r\nexport declare function isDigit(code: number): boolean;\r\nexport declare function isAsciiLetter(code: number): boolean;\r\nexport declare function isAsciiHexDigit(code: number): boolean;\r\n",
  "/node_modules/@angular/compiler/src/compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @module\r\n * @description\r\n * Entry point for all APIs of the compiler package.\r\n *\r\n * <div class=\"callout is-critical\">\r\n *   <header>Unstable APIs</header>\r\n *   <p>\r\n *     All compiler apis are currently considered experimental and private!\r\n *   </p>\r\n *   <p>\r\n *     We expect the APIs in this package to keep on changing. Do not rely on them.\r\n *   </p>\r\n * </div>\r\n */\r\nimport * as core from './core';\r\nexport { core };\r\nexport * from './version';\r\nexport * from './template_parser/template_ast';\r\nexport { CompilerConfig, preserveWhitespacesDefault } from './config';\r\nexport * from './compile_metadata';\r\nexport * from './aot/compiler_factory';\r\nexport * from './aot/compiler';\r\nexport * from './aot/generated_file';\r\nexport * from './aot/compiler_options';\r\nexport * from './aot/compiler_host';\r\nexport * from './aot/formatted_error';\r\nexport * from './aot/partial_module';\r\nexport * from './aot/static_reflector';\r\nexport * from './aot/static_symbol';\r\nexport * from './aot/static_symbol_resolver';\r\nexport * from './aot/summary_resolver';\r\nexport { isLoweredSymbol, createLoweredSymbol } from './aot/util';\r\nexport { LazyRoute } from './aot/lazy_routes';\r\nexport * from './ast_path';\r\nexport * from './summary_resolver';\r\nexport { Identifiers } from './identifiers';\r\nexport { JitCompiler } from './jit/compiler';\r\nexport * from './compile_reflector';\r\nexport * from './url_resolver';\r\nexport * from './resource_loader';\r\nexport { ConstantPool } from './constant_pool';\r\nexport { DirectiveResolver } from './directive_resolver';\r\nexport { PipeResolver } from './pipe_resolver';\r\nexport { NgModuleResolver } from './ng_module_resolver';\r\nexport { DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig } from './ml_parser/interpolation_config';\r\nexport * from './schema/element_schema_registry';\r\nexport * from './i18n/index';\r\nexport * from './directive_normalizer';\r\nexport * from './expression_parser/ast';\r\nexport * from './expression_parser/lexer';\r\nexport * from './expression_parser/parser';\r\nexport * from './metadata_resolver';\r\nexport * from './ml_parser/ast';\r\nexport * from './ml_parser/html_parser';\r\nexport * from './ml_parser/html_tags';\r\nexport * from './ml_parser/interpolation_config';\r\nexport * from './ml_parser/tags';\r\nexport { NgModuleCompiler } from './ng_module_compiler';\r\nexport { ArrayType, AssertNotNull, BinaryOperator, BinaryOperatorExpr, BuiltinMethod, BuiltinType, BuiltinTypeName, BuiltinVar, CastExpr, ClassField, ClassMethod, ClassStmt, CommaExpr, CommentStmt, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, ExternalReference, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, JSDocCommentStmt, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, StatementVisitor, ThrowStmt, TryCatchStmt, Type, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, StmtModifier, Statement, TypeofExpr, collectExternalReferences } from './output/output_ast';\r\nexport { EmitterVisitorContext } from './output/abstract_emitter';\r\nexport * from './output/ts_emitter';\r\nexport * from './parse_util';\r\nexport * from './schema/dom_element_schema_registry';\r\nexport * from './selector';\r\nexport * from './style_compiler';\r\nexport * from './template_parser/template_parser';\r\nexport { ViewCompiler } from './view_compiler/view_compiler';\r\nexport { getParseErrors, isSyntaxError, syntaxError, Version } from './util';\r\nexport { SourceMap } from './output/source_map';\r\nexport * from './injectable_compiler_2';\r\nexport * from './render3/view/api';\r\nexport { jitExpression } from './render3/r3_jit';\r\nexport { R3DependencyMetadata, R3FactoryMetadata, R3ResolvedDependencyType } from './render3/r3_factory';\r\nexport { compileInjector, compileNgModule, R3InjectorMetadata, R3NgModuleMetadata } from './render3/r3_module_compiler';\r\nexport { compilePipeFromMetadata, R3PipeMetadata } from './render3/r3_pipe_compiler';\r\nexport { makeBindingParser, parseTemplate } from './render3/view/template';\r\nexport { R3Reference } from './render3/util';\r\nexport { compileBaseDefFromMetadata, R3BaseRefMetaData, compileComponentFromMetadata, compileDirectiveFromMetadata, parseHostBindings } from './render3/view/compiler';\r\n",
  "/node_modules/@angular/compiler/src/compiler_util/expression_converter.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as cdAst from '../expression_parser/ast';\r\nimport * as o from '../output/output_ast';\r\nexport declare class EventHandlerVars {\r\n    static event: o.ReadVarExpr;\r\n}\r\nexport interface LocalResolver {\r\n    getLocal(name: string): o.Expression | null;\r\n}\r\nexport declare class ConvertActionBindingResult {\r\n    /**\r\n     * Render2 compatible statements,\r\n     */\r\n    stmts: o.Statement[];\r\n    /**\r\n     * Variable name used with render2 compatible statements.\r\n     */\r\n    allowDefault: o.ReadVarExpr;\r\n    /**\r\n     * Store statements which are render3 compatible.\r\n     */\r\n    render3Stmts: o.Statement[];\r\n    constructor(\r\n    /**\r\n     * Render2 compatible statements,\r\n     */\r\n    stmts: o.Statement[], \r\n    /**\r\n     * Variable name used with render2 compatible statements.\r\n     */\r\n    allowDefault: o.ReadVarExpr);\r\n}\r\nexport declare type InterpolationFunction = (args: o.Expression[]) => o.Expression;\r\n/**\r\n * Converts the given expression AST into an executable output AST, assuming the expression is\r\n * used in an action binding (e.g. an event handler).\r\n */\r\nexport declare function convertActionBinding(localResolver: LocalResolver | null, implicitReceiver: o.Expression, action: cdAst.AST, bindingId: string, interpolationFunction?: InterpolationFunction): ConvertActionBindingResult;\r\nexport interface BuiltinConverter {\r\n    (args: o.Expression[]): o.Expression;\r\n}\r\nexport interface BuiltinConverterFactory {\r\n    createLiteralArrayConverter(argCount: number): BuiltinConverter;\r\n    createLiteralMapConverter(keys: {\r\n        key: string;\r\n        quoted: boolean;\r\n    }[]): BuiltinConverter;\r\n    createPipeConverter(name: string, argCount: number): BuiltinConverter;\r\n}\r\nexport declare function convertPropertyBindingBuiltins(converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST;\r\nexport declare class ConvertPropertyBindingResult {\r\n    stmts: o.Statement[];\r\n    currValExpr: o.Expression;\r\n    constructor(stmts: o.Statement[], currValExpr: o.Expression);\r\n}\r\nexport declare enum BindingForm {\r\n    General = 0,\r\n    TrySimple = 1\r\n}\r\n/**\r\n * Converts the given expression AST into an executable output AST, assuming the expression\r\n * is used in property binding. The expression has to be preprocessed via\r\n * `convertPropertyBindingBuiltins`.\r\n */\r\nexport declare function convertPropertyBinding(localResolver: LocalResolver | null, implicitReceiver: o.Expression, expressionWithoutBuiltins: cdAst.AST, bindingId: string, form: BindingForm, interpolationFunction?: InterpolationFunction): ConvertPropertyBindingResult;\r\nexport declare function temporaryDeclaration(bindingId: string, temporaryNumber: number): o.Statement;\r\nexport declare class BuiltinFunctionCall extends cdAst.FunctionCall {\r\n    args: cdAst.AST[];\r\n    converter: BuiltinConverter;\r\n    constructor(span: cdAst.ParseSpan, args: cdAst.AST[], converter: BuiltinConverter);\r\n}\r\n",
  "/node_modules/@angular/compiler/src/compile_metadata.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { StaticSymbol } from './aot/static_symbol';\r\nimport { ChangeDetectionStrategy, SchemaMetadata, Type, ViewEncapsulation } from './core';\r\nimport { LifecycleHooks } from './lifecycle_reflector';\r\nimport { ParseTreeResult as HtmlParseTreeResult } from './ml_parser/parser';\r\nexport declare function sanitizeIdentifier(name: string): string;\r\nexport declare function identifierName(compileIdentifier: CompileIdentifierMetadata | null | undefined): string | null;\r\nexport declare function identifierModuleUrl(compileIdentifier: CompileIdentifierMetadata): string;\r\nexport declare function viewClassName(compType: any, embeddedTemplateIndex: number): string;\r\nexport declare function rendererTypeName(compType: any): string;\r\nexport declare function hostViewClassName(compType: any): string;\r\nexport declare function componentFactoryName(compType: any): string;\r\nexport interface ProxyClass {\r\n    setDelegate(delegate: any): void;\r\n}\r\nexport interface CompileIdentifierMetadata {\r\n    reference: any;\r\n}\r\nexport declare enum CompileSummaryKind {\r\n    Pipe = 0,\r\n    Directive = 1,\r\n    NgModule = 2,\r\n    Injectable = 3\r\n}\r\n/**\r\n * A CompileSummary is the data needed to use a directive / pipe / module\r\n * in other modules / components. However, this data is not enough to compile\r\n * the directive / module itself.\r\n */\r\nexport interface CompileTypeSummary {\r\n    summaryKind: CompileSummaryKind | null;\r\n    type: CompileTypeMetadata;\r\n}\r\nexport interface CompileDiDependencyMetadata {\r\n    isAttribute?: boolean;\r\n    isSelf?: boolean;\r\n    isHost?: boolean;\r\n    isSkipSelf?: boolean;\r\n    isOptional?: boolean;\r\n    isValue?: boolean;\r\n    token?: CompileTokenMetadata;\r\n    value?: any;\r\n}\r\nexport interface CompileProviderMetadata {\r\n    token: CompileTokenMetadata;\r\n    useClass?: CompileTypeMetadata;\r\n    useValue?: any;\r\n    useExisting?: CompileTokenMetadata;\r\n    useFactory?: CompileFactoryMetadata;\r\n    deps?: CompileDiDependencyMetadata[];\r\n    multi?: boolean;\r\n}\r\nexport interface CompileFactoryMetadata extends CompileIdentifierMetadata {\r\n    diDeps: CompileDiDependencyMetadata[];\r\n    reference: any;\r\n}\r\nexport declare function tokenName(token: CompileTokenMetadata): string;\r\nexport declare function tokenReference(token: CompileTokenMetadata): any;\r\nexport interface CompileTokenMetadata {\r\n    value?: any;\r\n    identifier?: CompileIdentifierMetadata | CompileTypeMetadata;\r\n}\r\nexport interface CompileInjectableMetadata {\r\n    symbol: StaticSymbol;\r\n    type: CompileTypeMetadata;\r\n    providedIn?: StaticSymbol;\r\n    useValue?: any;\r\n    useClass?: StaticSymbol;\r\n    useExisting?: StaticSymbol;\r\n    useFactory?: StaticSymbol;\r\n    deps?: any[];\r\n}\r\n/**\r\n * Metadata regarding compilation of a type.\r\n */\r\nexport interface CompileTypeMetadata extends CompileIdentifierMetadata {\r\n    diDeps: CompileDiDependencyMetadata[];\r\n    lifecycleHooks: LifecycleHooks[];\r\n    reference: any;\r\n}\r\nexport interface CompileQueryMetadata {\r\n    selectors: Array<CompileTokenMetadata>;\r\n    descendants: boolean;\r\n    first: boolean;\r\n    propertyName: string;\r\n    read: CompileTokenMetadata;\r\n}\r\n/**\r\n * Metadata about a stylesheet\r\n */\r\nexport declare class CompileStylesheetMetadata {\r\n    moduleUrl: string | null;\r\n    styles: string[];\r\n    styleUrls: string[];\r\n    constructor({ moduleUrl, styles, styleUrls }?: {\r\n        moduleUrl?: string;\r\n        styles?: string[];\r\n        styleUrls?: string[];\r\n    });\r\n}\r\n/**\r\n * Summary Metadata regarding compilation of a template.\r\n */\r\nexport interface CompileTemplateSummary {\r\n    ngContentSelectors: string[];\r\n    encapsulation: ViewEncapsulation | null;\r\n    styles: string[];\r\n    animations: any[] | null;\r\n}\r\n/**\r\n * Metadata regarding compilation of a template.\r\n */\r\nexport declare class CompileTemplateMetadata {\r\n    encapsulation: ViewEncapsulation | null;\r\n    template: string | null;\r\n    templateUrl: string | null;\r\n    htmlAst: HtmlParseTreeResult | null;\r\n    isInline: boolean;\r\n    styles: string[];\r\n    styleUrls: string[];\r\n    externalStylesheets: CompileStylesheetMetadata[];\r\n    animations: any[];\r\n    ngContentSelectors: string[];\r\n    interpolation: [string, string] | null;\r\n    preserveWhitespaces: boolean;\r\n    constructor({ encapsulation, template, templateUrl, htmlAst, styles, styleUrls, externalStylesheets, animations, ngContentSelectors, interpolation, isInline, preserveWhitespaces }: {\r\n        encapsulation: ViewEncapsulation | null;\r\n        template: string | null;\r\n        templateUrl: string | null;\r\n        htmlAst: HtmlParseTreeResult | null;\r\n        styles: string[];\r\n        styleUrls: string[];\r\n        externalStylesheets: CompileStylesheetMetadata[];\r\n        ngContentSelectors: string[];\r\n        animations: any[];\r\n        interpolation: [string, string] | null;\r\n        isInline: boolean;\r\n        preserveWhitespaces: boolean;\r\n    });\r\n    toSummary(): CompileTemplateSummary;\r\n}\r\nexport interface CompileEntryComponentMetadata {\r\n    componentType: any;\r\n    componentFactory: StaticSymbol | object;\r\n}\r\nexport interface CompileDirectiveSummary extends CompileTypeSummary {\r\n    type: CompileTypeMetadata;\r\n    isComponent: boolean;\r\n    selector: string | null;\r\n    exportAs: string | null;\r\n    inputs: {\r\n        [key: string]: string;\r\n    };\r\n    outputs: {\r\n        [key: string]: string;\r\n    };\r\n    hostListeners: {\r\n        [key: string]: string;\r\n    };\r\n    hostProperties: {\r\n        [key: string]: string;\r\n    };\r\n    hostAttributes: {\r\n        [key: string]: string;\r\n    };\r\n    providers: CompileProviderMetadata[];\r\n    viewProviders: CompileProviderMetadata[];\r\n    queries: CompileQueryMetadata[];\r\n    guards: {\r\n        [key: string]: any;\r\n    };\r\n    viewQueries: CompileQueryMetadata[];\r\n    entryComponents: CompileEntryComponentMetadata[];\r\n    changeDetection: ChangeDetectionStrategy | null;\r\n    template: CompileTemplateSummary | null;\r\n    componentViewType: StaticSymbol | ProxyClass | null;\r\n    rendererType: StaticSymbol | object | null;\r\n    componentFactory: StaticSymbol | object | null;\r\n}\r\n/**\r\n * Metadata regarding compilation of a directive.\r\n */\r\nexport declare class CompileDirectiveMetadata {\r\n    static create({ isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, host, providers, viewProviders, queries, guards, viewQueries, entryComponents, template, componentViewType, rendererType, componentFactory }: {\r\n        isHost: boolean;\r\n        type: CompileTypeMetadata;\r\n        isComponent: boolean;\r\n        selector: string | null;\r\n        exportAs: string | null;\r\n        changeDetection: ChangeDetectionStrategy | null;\r\n        inputs: string[];\r\n        outputs: string[];\r\n        host: {\r\n            [key: string]: string;\r\n        };\r\n        providers: CompileProviderMetadata[];\r\n        viewProviders: CompileProviderMetadata[];\r\n        queries: CompileQueryMetadata[];\r\n        guards: {\r\n            [key: string]: any;\r\n        };\r\n        viewQueries: CompileQueryMetadata[];\r\n        entryComponents: CompileEntryComponentMetadata[];\r\n        template: CompileTemplateMetadata;\r\n        componentViewType: StaticSymbol | ProxyClass | null;\r\n        rendererType: StaticSymbol | object | null;\r\n        componentFactory: StaticSymbol | object | null;\r\n    }): CompileDirectiveMetadata;\r\n    isHost: boolean;\r\n    type: CompileTypeMetadata;\r\n    isComponent: boolean;\r\n    selector: string | null;\r\n    exportAs: string | null;\r\n    changeDetection: ChangeDetectionStrategy | null;\r\n    inputs: {\r\n        [key: string]: string;\r\n    };\r\n    outputs: {\r\n        [key: string]: string;\r\n    };\r\n    hostListeners: {\r\n        [key: string]: string;\r\n    };\r\n    hostProperties: {\r\n        [key: string]: string;\r\n    };\r\n    hostAttributes: {\r\n        [key: string]: string;\r\n    };\r\n    providers: CompileProviderMetadata[];\r\n    viewProviders: CompileProviderMetadata[];\r\n    queries: CompileQueryMetadata[];\r\n    guards: {\r\n        [key: string]: any;\r\n    };\r\n    viewQueries: CompileQueryMetadata[];\r\n    entryComponents: CompileEntryComponentMetadata[];\r\n    template: CompileTemplateMetadata | null;\r\n    componentViewType: StaticSymbol | ProxyClass | null;\r\n    rendererType: StaticSymbol | object | null;\r\n    componentFactory: StaticSymbol | object | null;\r\n    constructor({ isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, hostListeners, hostProperties, hostAttributes, providers, viewProviders, queries, guards, viewQueries, entryComponents, template, componentViewType, rendererType, componentFactory }: {\r\n        isHost: boolean;\r\n        type: CompileTypeMetadata;\r\n        isComponent: boolean;\r\n        selector: string | null;\r\n        exportAs: string | null;\r\n        changeDetection: ChangeDetectionStrategy | null;\r\n        inputs: {\r\n            [key: string]: string;\r\n        };\r\n        outputs: {\r\n            [key: string]: string;\r\n        };\r\n        hostListeners: {\r\n            [key: string]: string;\r\n        };\r\n        hostProperties: {\r\n            [key: string]: string;\r\n        };\r\n        hostAttributes: {\r\n            [key: string]: string;\r\n        };\r\n        providers: CompileProviderMetadata[];\r\n        viewProviders: CompileProviderMetadata[];\r\n        queries: CompileQueryMetadata[];\r\n        guards: {\r\n            [key: string]: any;\r\n        };\r\n        viewQueries: CompileQueryMetadata[];\r\n        entryComponents: CompileEntryComponentMetadata[];\r\n        template: CompileTemplateMetadata | null;\r\n        componentViewType: StaticSymbol | ProxyClass | null;\r\n        rendererType: StaticSymbol | object | null;\r\n        componentFactory: StaticSymbol | object | null;\r\n    });\r\n    toSummary(): CompileDirectiveSummary;\r\n}\r\nexport interface CompilePipeSummary extends CompileTypeSummary {\r\n    type: CompileTypeMetadata;\r\n    name: string;\r\n    pure: boolean;\r\n}\r\nexport declare class CompilePipeMetadata {\r\n    type: CompileTypeMetadata;\r\n    name: string;\r\n    pure: boolean;\r\n    constructor({ type, name, pure }: {\r\n        type: CompileTypeMetadata;\r\n        name: string;\r\n        pure: boolean;\r\n    });\r\n    toSummary(): CompilePipeSummary;\r\n}\r\nexport interface CompileNgModuleSummary extends CompileTypeSummary {\r\n    type: CompileTypeMetadata;\r\n    exportedDirectives: CompileIdentifierMetadata[];\r\n    exportedPipes: CompileIdentifierMetadata[];\r\n    entryComponents: CompileEntryComponentMetadata[];\r\n    providers: {\r\n        provider: CompileProviderMetadata;\r\n        module: CompileIdentifierMetadata;\r\n    }[];\r\n    modules: CompileTypeMetadata[];\r\n}\r\nexport declare class CompileShallowModuleMetadata {\r\n    type: CompileTypeMetadata;\r\n    rawExports: any;\r\n    rawImports: any;\r\n    rawProviders: any;\r\n}\r\n/**\r\n * Metadata regarding compilation of a module.\r\n */\r\nexport declare class CompileNgModuleMetadata {\r\n    type: CompileTypeMetadata;\r\n    declaredDirectives: CompileIdentifierMetadata[];\r\n    exportedDirectives: CompileIdentifierMetadata[];\r\n    declaredPipes: CompileIdentifierMetadata[];\r\n    exportedPipes: CompileIdentifierMetadata[];\r\n    entryComponents: CompileEntryComponentMetadata[];\r\n    bootstrapComponents: CompileIdentifierMetadata[];\r\n    providers: CompileProviderMetadata[];\r\n    importedModules: CompileNgModuleSummary[];\r\n    exportedModules: CompileNgModuleSummary[];\r\n    schemas: SchemaMetadata[];\r\n    id: string | null;\r\n    transitiveModule: TransitiveCompileNgModuleMetadata;\r\n    constructor({ type, providers, declaredDirectives, exportedDirectives, declaredPipes, exportedPipes, entryComponents, bootstrapComponents, importedModules, exportedModules, schemas, transitiveModule, id }: {\r\n        type: CompileTypeMetadata;\r\n        providers: CompileProviderMetadata[];\r\n        declaredDirectives: CompileIdentifierMetadata[];\r\n        exportedDirectives: CompileIdentifierMetadata[];\r\n        declaredPipes: CompileIdentifierMetadata[];\r\n        exportedPipes: CompileIdentifierMetadata[];\r\n        entryComponents: CompileEntryComponentMetadata[];\r\n        bootstrapComponents: CompileIdentifierMetadata[];\r\n        importedModules: CompileNgModuleSummary[];\r\n        exportedModules: CompileNgModuleSummary[];\r\n        transitiveModule: TransitiveCompileNgModuleMetadata;\r\n        schemas: SchemaMetadata[];\r\n        id: string | null;\r\n    });\r\n    toSummary(): CompileNgModuleSummary;\r\n}\r\nexport declare class TransitiveCompileNgModuleMetadata {\r\n    directivesSet: Set<any>;\r\n    directives: CompileIdentifierMetadata[];\r\n    exportedDirectivesSet: Set<any>;\r\n    exportedDirectives: CompileIdentifierMetadata[];\r\n    pipesSet: Set<any>;\r\n    pipes: CompileIdentifierMetadata[];\r\n    exportedPipesSet: Set<any>;\r\n    exportedPipes: CompileIdentifierMetadata[];\r\n    modulesSet: Set<any>;\r\n    modules: CompileTypeMetadata[];\r\n    entryComponentsSet: Set<any>;\r\n    entryComponents: CompileEntryComponentMetadata[];\r\n    providers: {\r\n        provider: CompileProviderMetadata;\r\n        module: CompileIdentifierMetadata;\r\n    }[];\r\n    addProvider(provider: CompileProviderMetadata, module: CompileIdentifierMetadata): void;\r\n    addDirective(id: CompileIdentifierMetadata): void;\r\n    addExportedDirective(id: CompileIdentifierMetadata): void;\r\n    addPipe(id: CompileIdentifierMetadata): void;\r\n    addExportedPipe(id: CompileIdentifierMetadata): void;\r\n    addModule(id: CompileTypeMetadata): void;\r\n    addEntryComponent(ec: CompileEntryComponentMetadata): void;\r\n}\r\nexport declare class ProviderMeta {\r\n    token: any;\r\n    useClass: Type | null;\r\n    useValue: any;\r\n    useExisting: any;\r\n    useFactory: Function | null;\r\n    dependencies: Object[] | null;\r\n    multi: boolean;\r\n    constructor(token: any, { useClass, useValue, useExisting, useFactory, deps, multi }: {\r\n        useClass?: Type;\r\n        useValue?: any;\r\n        useExisting?: any;\r\n        useFactory?: Function | null;\r\n        deps?: Object[] | null;\r\n        multi?: boolean;\r\n    });\r\n}\r\nexport declare function flatten<T>(list: Array<T | T[]>): T[];\r\nexport declare function templateSourceUrl(ngModuleType: CompileIdentifierMetadata, compMeta: {\r\n    type: CompileIdentifierMetadata;\r\n}, templateMeta: {\r\n    isInline: boolean;\r\n    templateUrl: string | null;\r\n}): string;\r\nexport declare function sharedStylesheetJitUrl(meta: CompileStylesheetMetadata, id: number): string;\r\nexport declare function ngModuleJitUrl(moduleMeta: CompileNgModuleMetadata): string;\r\nexport declare function templateJitUrl(ngModuleType: CompileIdentifierMetadata, compMeta: CompileDirectiveMetadata): string;\r\n",
  "/node_modules/@angular/compiler/src/compile_reflector.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Component } from './core';\r\nimport * as o from './output/output_ast';\r\n/**\r\n * Provides access to reflection data about symbols that the compiler needs.\r\n */\r\nexport declare abstract class CompileReflector {\r\n    abstract parameters(typeOrFunc: any): any[][];\r\n    abstract annotations(typeOrFunc: any): any[];\r\n    abstract shallowAnnotations(typeOrFunc: any): any[];\r\n    abstract tryAnnotations(typeOrFunc: any): any[];\r\n    abstract propMetadata(typeOrFunc: any): {\r\n        [key: string]: any[];\r\n    };\r\n    abstract hasLifecycleHook(type: any, lcProperty: string): boolean;\r\n    abstract guards(typeOrFunc: any): {\r\n        [key: string]: any;\r\n    };\r\n    abstract componentModuleUrl(type: any, cmpMetadata: Component): string;\r\n    abstract resolveExternalReference(ref: o.ExternalReference): any;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/config.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { MissingTranslationStrategy, ViewEncapsulation } from './core';\r\nexport declare class CompilerConfig {\r\n    defaultEncapsulation: ViewEncapsulation | null;\r\n    useJit: boolean;\r\n    jitDevMode: boolean;\r\n    missingTranslation: MissingTranslationStrategy | null;\r\n    preserveWhitespaces: boolean;\r\n    strictInjectionParameters: boolean;\r\n    constructor({ defaultEncapsulation, useJit, jitDevMode, missingTranslation, preserveWhitespaces, strictInjectionParameters }?: {\r\n        defaultEncapsulation?: ViewEncapsulation;\r\n        useJit?: boolean;\r\n        jitDevMode?: boolean;\r\n        missingTranslation?: MissingTranslationStrategy | null;\r\n        preserveWhitespaces?: boolean;\r\n        strictInjectionParameters?: boolean;\r\n    });\r\n}\r\nexport declare function preserveWhitespacesDefault(preserveWhitespacesOption: boolean | null, defaultSetting?: boolean): boolean;\r\n",
  "/node_modules/@angular/compiler/src/constant_pool.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as o from './output/output_ast';\r\nimport { OutputContext } from './util';\r\nexport declare const enum DefinitionKind {\r\n    Injector = 0,\r\n    Directive = 1,\r\n    Component = 2,\r\n    Pipe = 3\r\n}\r\n/**\r\n * A constant pool allows a code emitter to share constant in an output context.\r\n *\r\n * The constant pool also supports sharing access to ivy definitions references.\r\n */\r\nexport declare class ConstantPool {\r\n    statements: o.Statement[];\r\n    private translations;\r\n    private literals;\r\n    private literalFactories;\r\n    private injectorDefinitions;\r\n    private directiveDefinitions;\r\n    private componentDefinitions;\r\n    private pipeDefinitions;\r\n    private nextNameIndex;\r\n    getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression;\r\n    getTranslation(message: string, meta: {\r\n        description?: string;\r\n        meaning?: string;\r\n    }, suffix: string): o.Expression;\r\n    getDefinition(type: any, kind: DefinitionKind, ctx: OutputContext, forceShared?: boolean): o.Expression;\r\n    getLiteralFactory(literal: o.LiteralArrayExpr | o.LiteralMapExpr): {\r\n        literalFactory: o.Expression;\r\n        literalFactoryArguments: o.Expression[];\r\n    };\r\n    private _getLiteralFactory;\r\n    /**\r\n     * Produce a unique name.\r\n     *\r\n     * The name might be unique among different prefixes if any of the prefixes end in\r\n     * a digit so the prefix should be a constant string (not based on user input) and\r\n     * must not end in a digit.\r\n     */\r\n    uniqueName(prefix: string): string;\r\n    private definitionsOf;\r\n    propertyNameOf(kind: DefinitionKind): string;\r\n    private freshName;\r\n    private freshTranslationName;\r\n    private keyOf;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/core.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport interface Inject {\r\n    token: any;\r\n}\r\nexport declare const createInject: MetadataFactory<Inject>;\r\nexport declare const createInjectionToken: MetadataFactory<object>;\r\nexport interface Attribute {\r\n    attributeName?: string;\r\n}\r\nexport declare const createAttribute: MetadataFactory<Attribute>;\r\nexport interface Query {\r\n    descendants: boolean;\r\n    first: boolean;\r\n    read: any;\r\n    isViewQuery: boolean;\r\n    selector: any;\r\n}\r\nexport declare const createContentChildren: MetadataFactory<Query>;\r\nexport declare const createContentChild: MetadataFactory<Query>;\r\nexport declare const createViewChildren: MetadataFactory<Query>;\r\nexport declare const createViewChild: MetadataFactory<Query>;\r\nexport interface Directive {\r\n    selector?: string;\r\n    inputs?: string[];\r\n    outputs?: string[];\r\n    host?: {\r\n        [key: string]: string;\r\n    };\r\n    providers?: Provider[];\r\n    exportAs?: string;\r\n    queries?: {\r\n        [key: string]: any;\r\n    };\r\n    guards?: {\r\n        [key: string]: any;\r\n    };\r\n}\r\nexport declare const createDirective: MetadataFactory<Directive>;\r\nexport interface Component extends Directive {\r\n    changeDetection?: ChangeDetectionStrategy;\r\n    viewProviders?: Provider[];\r\n    moduleId?: string;\r\n    templateUrl?: string;\r\n    template?: string;\r\n    styleUrls?: string[];\r\n    styles?: string[];\r\n    animations?: any[];\r\n    encapsulation?: ViewEncapsulation;\r\n    interpolation?: [string, string];\r\n    entryComponents?: Array<Type | any[]>;\r\n    preserveWhitespaces?: boolean;\r\n}\r\nexport declare enum ViewEncapsulation {\r\n    Emulated = 0,\r\n    Native = 1,\r\n    None = 2,\r\n    ShadowDom = 3\r\n}\r\nexport declare enum ChangeDetectionStrategy {\r\n    OnPush = 0,\r\n    Default = 1\r\n}\r\nexport declare const createComponent: MetadataFactory<Component>;\r\nexport interface Pipe {\r\n    name: string;\r\n    pure?: boolean;\r\n}\r\nexport declare const createPipe: MetadataFactory<Pipe>;\r\nexport interface Input {\r\n    bindingPropertyName?: string;\r\n}\r\nexport declare const createInput: MetadataFactory<Input>;\r\nexport interface Output {\r\n    bindingPropertyName?: string;\r\n}\r\nexport declare const createOutput: MetadataFactory<Output>;\r\nexport interface HostBinding {\r\n    hostPropertyName?: string;\r\n}\r\nexport declare const createHostBinding: MetadataFactory<HostBinding>;\r\nexport interface HostListener {\r\n    eventName?: string;\r\n    args?: string[];\r\n}\r\nexport declare const createHostListener: MetadataFactory<HostListener>;\r\nexport interface NgModule {\r\n    providers?: Provider[];\r\n    declarations?: Array<Type | any[]>;\r\n    imports?: Array<Type | ModuleWithProviders | any[]>;\r\n    exports?: Array<Type | any[]>;\r\n    entryComponents?: Array<Type | any[]>;\r\n    bootstrap?: Array<Type | any[]>;\r\n    schemas?: Array<SchemaMetadata | any[]>;\r\n    id?: string;\r\n}\r\nexport declare const createNgModule: MetadataFactory<NgModule>;\r\nexport interface ModuleWithProviders {\r\n    ngModule: Type;\r\n    providers?: Provider[];\r\n}\r\nexport interface Injectable {\r\n    providedIn?: Type | 'root' | any;\r\n    useClass?: Type | any;\r\n    useExisting?: Type | any;\r\n    useValue?: any;\r\n    useFactory?: Type | any;\r\n    deps?: Array<Type | any[]>;\r\n}\r\nexport declare const createInjectable: MetadataFactory<Injectable>;\r\nexport interface SchemaMetadata {\r\n    name: string;\r\n}\r\nexport declare const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata;\r\nexport declare const NO_ERRORS_SCHEMA: SchemaMetadata;\r\nexport declare const createOptional: MetadataFactory<{}>;\r\nexport declare const createSelf: MetadataFactory<{}>;\r\nexport declare const createSkipSelf: MetadataFactory<{}>;\r\nexport declare const createHost: MetadataFactory<{}>;\r\nexport interface Type extends Function {\r\n    new (...args: any[]): any;\r\n}\r\nexport declare const Type: FunctionConstructor;\r\nexport declare enum SecurityContext {\r\n    NONE = 0,\r\n    HTML = 1,\r\n    STYLE = 2,\r\n    SCRIPT = 3,\r\n    URL = 4,\r\n    RESOURCE_URL = 5\r\n}\r\nexport declare type Provider = any;\r\nexport declare const enum NodeFlags {\r\n    None = 0,\r\n    TypeElement = 1,\r\n    TypeText = 2,\r\n    ProjectedTemplate = 4,\r\n    CatRenderNode = 3,\r\n    TypeNgContent = 8,\r\n    TypePipe = 16,\r\n    TypePureArray = 32,\r\n    TypePureObject = 64,\r\n    TypePurePipe = 128,\r\n    CatPureExpression = 224,\r\n    TypeValueProvider = 256,\r\n    TypeClassProvider = 512,\r\n    TypeFactoryProvider = 1024,\r\n    TypeUseExistingProvider = 2048,\r\n    LazyProvider = 4096,\r\n    PrivateProvider = 8192,\r\n    TypeDirective = 16384,\r\n    Component = 32768,\r\n    CatProviderNoDirective = 3840,\r\n    CatProvider = 20224,\r\n    OnInit = 65536,\r\n    OnDestroy = 131072,\r\n    DoCheck = 262144,\r\n    OnChanges = 524288,\r\n    AfterContentInit = 1048576,\r\n    AfterContentChecked = 2097152,\r\n    AfterViewInit = 4194304,\r\n    AfterViewChecked = 8388608,\r\n    EmbeddedViews = 16777216,\r\n    ComponentView = 33554432,\r\n    TypeContentQuery = 67108864,\r\n    TypeViewQuery = 134217728,\r\n    StaticQuery = 268435456,\r\n    DynamicQuery = 536870912,\r\n    TypeModuleProvider = 1073741824,\r\n    CatQuery = 201326592,\r\n    Types = 201347067\r\n}\r\nexport declare const enum DepFlags {\r\n    None = 0,\r\n    SkipSelf = 1,\r\n    Optional = 2,\r\n    Self = 4,\r\n    Value = 8\r\n}\r\n/**\r\n * Injection flags for DI.\r\n */\r\nexport declare const enum InjectFlags {\r\n    Default = 0,\r\n    /**\r\n     * Specifies that an injector should retrieve a dependency from any injector until reaching the\r\n     * host element of the current component. (Only used with Element Injector)\r\n     */\r\n    Host = 1,\r\n    /** Don't descend into ancestors of the node requesting injection. */\r\n    Self = 2,\r\n    /** Skip the node that is requesting injection. */\r\n    SkipSelf = 4,\r\n    /** Inject `defaultValue` instead if token not found. */\r\n    Optional = 8\r\n}\r\nexport declare const enum ArgumentType {\r\n    Inline = 0,\r\n    Dynamic = 1\r\n}\r\nexport declare const enum BindingFlags {\r\n    TypeElementAttribute = 1,\r\n    TypeElementClass = 2,\r\n    TypeElementStyle = 4,\r\n    TypeProperty = 8,\r\n    SyntheticProperty = 16,\r\n    SyntheticHostProperty = 32,\r\n    CatSyntheticProperty = 48,\r\n    Types = 15\r\n}\r\nexport declare const enum QueryBindingType {\r\n    First = 0,\r\n    All = 1\r\n}\r\nexport declare const enum QueryValueType {\r\n    ElementRef = 0,\r\n    RenderElement = 1,\r\n    TemplateRef = 2,\r\n    ViewContainerRef = 3,\r\n    Provider = 4\r\n}\r\nexport declare const enum ViewFlags {\r\n    None = 0,\r\n    OnPush = 2\r\n}\r\nexport declare enum MissingTranslationStrategy {\r\n    Error = 0,\r\n    Warning = 1,\r\n    Ignore = 2\r\n}\r\nexport interface MetadataFactory<T> {\r\n    (...args: any[]): T;\r\n    isTypeOf(obj: any): obj is T;\r\n    ngMetadataName: string;\r\n}\r\nexport interface Route {\r\n    children?: Route[];\r\n    loadChildren?: string | Type | any;\r\n}\r\n/**\r\n * Flags used to generate R3-style CSS Selectors. They are pasted from\r\n * core/src/render3/projection.ts because they cannot be referenced directly.\r\n */\r\nexport declare const enum SelectorFlags {\r\n    /** Indicates this is the beginning of a new negative selector */\r\n    NOT = 1,\r\n    /** Mode for matching attributes */\r\n    ATTRIBUTE = 2,\r\n    /** Mode for matching tag names */\r\n    ELEMENT = 4,\r\n    /** Mode for matching class names */\r\n    CLASS = 8\r\n}\r\nexport declare type R3CssSelector = (string | SelectorFlags)[];\r\nexport declare type R3CssSelectorList = R3CssSelector[];\r\nexport declare function parseSelectorToR3Selector(selector: string): R3CssSelectorList;\r\n/**\r\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\r\n * should be executed.\r\n *\r\n * Typically, a template runs both the creation block and the update block on initialization and\r\n * subsequent runs only execute the update block. However, dynamically created views require that\r\n * the creation block be executed separately from the update block (for backwards compat).\r\n */\r\nexport declare const enum RenderFlags {\r\n    Create = 1,\r\n    Update = 2\r\n}\r\nexport declare const enum InitialStylingFlags {\r\n    VALUES_MODE = 1\r\n}\r\n/**\r\n * A set of marker values to be used in the attributes arrays. Those markers indicate that some\r\n * items are not regular attributes and the processing should be adapted accordingly.\r\n */\r\nexport declare const enum AttributeMarker {\r\n    /**\r\n     * Marker indicates that the following 3 values in the attributes array are:\r\n     * namespaceUri, attributeName, attributeValue\r\n     * in that order.\r\n     */\r\n    NamespaceURI = 0,\r\n    /**\r\n     * This marker indicates that the following attribute names were extracted from bindings (ex.:\r\n     * [foo]=\"exp\") and / or event handlers (ex. (bar)=\"doSth()\").\r\n     * Taking the above bindings and outputs as an example an attributes array could look as follows:\r\n     * ['class', 'fade in', AttributeMarker.SelectOnly, 'foo', 'bar']\r\n     */\r\n    SelectOnly = 1\r\n}\r\n",
  "/node_modules/@angular/compiler/src/css_parser/css_ast.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ParseLocation, ParseSourceSpan } from '../parse_util';\r\nimport { CssToken } from './css_lexer';\r\nexport declare enum BlockType {\r\n    Import = 0,\r\n    Charset = 1,\r\n    Namespace = 2,\r\n    Supports = 3,\r\n    Keyframes = 4,\r\n    MediaQuery = 5,\r\n    Selector = 6,\r\n    FontFace = 7,\r\n    Page = 8,\r\n    Document = 9,\r\n    Viewport = 10,\r\n    Unsupported = 11\r\n}\r\nexport interface CssAstVisitor {\r\n    visitCssValue(ast: CssStyleValueAst, context?: any): any;\r\n    visitCssInlineRule(ast: CssInlineRuleAst, context?: any): any;\r\n    visitCssAtRulePredicate(ast: CssAtRulePredicateAst, context?: any): any;\r\n    visitCssKeyframeRule(ast: CssKeyframeRuleAst, context?: any): any;\r\n    visitCssKeyframeDefinition(ast: CssKeyframeDefinitionAst, context?: any): any;\r\n    visitCssMediaQueryRule(ast: CssMediaQueryRuleAst, context?: any): any;\r\n    visitCssSelectorRule(ast: CssSelectorRuleAst, context?: any): any;\r\n    visitCssSelector(ast: CssSelectorAst, context?: any): any;\r\n    visitCssSimpleSelector(ast: CssSimpleSelectorAst, context?: any): any;\r\n    visitCssPseudoSelector(ast: CssPseudoSelectorAst, context?: any): any;\r\n    visitCssDefinition(ast: CssDefinitionAst, context?: any): any;\r\n    visitCssBlock(ast: CssBlockAst, context?: any): any;\r\n    visitCssStylesBlock(ast: CssStylesBlockAst, context?: any): any;\r\n    visitCssStyleSheet(ast: CssStyleSheetAst, context?: any): any;\r\n    visitCssUnknownRule(ast: CssUnknownRuleAst, context?: any): any;\r\n    visitCssUnknownTokenList(ast: CssUnknownTokenListAst, context?: any): any;\r\n}\r\nexport declare abstract class CssAst {\r\n    location: ParseSourceSpan;\r\n    constructor(location: ParseSourceSpan);\r\n    readonly start: ParseLocation;\r\n    readonly end: ParseLocation;\r\n    abstract visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssStyleValueAst extends CssAst {\r\n    tokens: CssToken[];\r\n    strValue: string;\r\n    constructor(location: ParseSourceSpan, tokens: CssToken[], strValue: string);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare abstract class CssRuleAst extends CssAst {\r\n    constructor(location: ParseSourceSpan);\r\n}\r\nexport declare class CssBlockRuleAst extends CssRuleAst {\r\n    location: ParseSourceSpan;\r\n    type: BlockType;\r\n    block: CssBlockAst;\r\n    name: CssToken | null;\r\n    constructor(location: ParseSourceSpan, type: BlockType, block: CssBlockAst, name?: CssToken | null);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssKeyframeRuleAst extends CssBlockRuleAst {\r\n    constructor(location: ParseSourceSpan, name: CssToken, block: CssBlockAst);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssKeyframeDefinitionAst extends CssBlockRuleAst {\r\n    steps: CssToken[];\r\n    constructor(location: ParseSourceSpan, steps: CssToken[], block: CssBlockAst);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssBlockDefinitionRuleAst extends CssBlockRuleAst {\r\n    strValue: string;\r\n    query: CssAtRulePredicateAst;\r\n    constructor(location: ParseSourceSpan, strValue: string, type: BlockType, query: CssAtRulePredicateAst, block: CssBlockAst);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssMediaQueryRuleAst extends CssBlockDefinitionRuleAst {\r\n    constructor(location: ParseSourceSpan, strValue: string, query: CssAtRulePredicateAst, block: CssBlockAst);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssAtRulePredicateAst extends CssAst {\r\n    strValue: string;\r\n    tokens: CssToken[];\r\n    constructor(location: ParseSourceSpan, strValue: string, tokens: CssToken[]);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssInlineRuleAst extends CssRuleAst {\r\n    type: BlockType;\r\n    value: CssStyleValueAst;\r\n    constructor(location: ParseSourceSpan, type: BlockType, value: CssStyleValueAst);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssSelectorRuleAst extends CssBlockRuleAst {\r\n    selectors: CssSelectorAst[];\r\n    strValue: string;\r\n    constructor(location: ParseSourceSpan, selectors: CssSelectorAst[], block: CssBlockAst);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssDefinitionAst extends CssAst {\r\n    property: CssToken;\r\n    value: CssStyleValueAst;\r\n    constructor(location: ParseSourceSpan, property: CssToken, value: CssStyleValueAst);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare abstract class CssSelectorPartAst extends CssAst {\r\n    constructor(location: ParseSourceSpan);\r\n}\r\nexport declare class CssSelectorAst extends CssSelectorPartAst {\r\n    selectorParts: CssSimpleSelectorAst[];\r\n    strValue: string;\r\n    constructor(location: ParseSourceSpan, selectorParts: CssSimpleSelectorAst[]);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssSimpleSelectorAst extends CssSelectorPartAst {\r\n    tokens: CssToken[];\r\n    strValue: string;\r\n    pseudoSelectors: CssPseudoSelectorAst[];\r\n    operator: CssToken;\r\n    constructor(location: ParseSourceSpan, tokens: CssToken[], strValue: string, pseudoSelectors: CssPseudoSelectorAst[], operator: CssToken);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssPseudoSelectorAst extends CssSelectorPartAst {\r\n    strValue: string;\r\n    name: string;\r\n    tokens: CssToken[];\r\n    innerSelectors: CssSelectorAst[];\r\n    constructor(location: ParseSourceSpan, strValue: string, name: string, tokens: CssToken[], innerSelectors: CssSelectorAst[]);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssBlockAst extends CssAst {\r\n    entries: CssAst[];\r\n    constructor(location: ParseSourceSpan, entries: CssAst[]);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssStylesBlockAst extends CssBlockAst {\r\n    definitions: CssDefinitionAst[];\r\n    constructor(location: ParseSourceSpan, definitions: CssDefinitionAst[]);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssStyleSheetAst extends CssAst {\r\n    rules: CssAst[];\r\n    constructor(location: ParseSourceSpan, rules: CssAst[]);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssUnknownRuleAst extends CssRuleAst {\r\n    ruleName: string;\r\n    tokens: CssToken[];\r\n    constructor(location: ParseSourceSpan, ruleName: string, tokens: CssToken[]);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare class CssUnknownTokenListAst extends CssRuleAst {\r\n    name: string;\r\n    tokens: CssToken[];\r\n    constructor(location: ParseSourceSpan, name: string, tokens: CssToken[]);\r\n    visit(visitor: CssAstVisitor, context?: any): any;\r\n}\r\nexport declare function mergeTokens(tokens: CssToken[], separator?: string): CssToken;\r\n",
  "/node_modules/@angular/compiler/src/css_parser/css_lexer.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare enum CssTokenType {\r\n    EOF = 0,\r\n    String = 1,\r\n    Comment = 2,\r\n    Identifier = 3,\r\n    Number = 4,\r\n    IdentifierOrNumber = 5,\r\n    AtKeyword = 6,\r\n    Character = 7,\r\n    Whitespace = 8,\r\n    Invalid = 9\r\n}\r\nexport declare enum CssLexerMode {\r\n    ALL = 0,\r\n    ALL_TRACK_WS = 1,\r\n    SELECTOR = 2,\r\n    PSEUDO_SELECTOR = 3,\r\n    PSEUDO_SELECTOR_WITH_ARGUMENTS = 4,\r\n    ATTRIBUTE_SELECTOR = 5,\r\n    AT_RULE_QUERY = 6,\r\n    MEDIA_QUERY = 7,\r\n    BLOCK = 8,\r\n    KEYFRAME_BLOCK = 9,\r\n    STYLE_BLOCK = 10,\r\n    STYLE_VALUE = 11,\r\n    STYLE_VALUE_FUNCTION = 12,\r\n    STYLE_CALC_FUNCTION = 13\r\n}\r\nexport declare class LexedCssResult {\r\n    error: Error | null;\r\n    token: CssToken;\r\n    constructor(error: Error | null, token: CssToken);\r\n}\r\nexport declare function generateErrorMessage(input: string, message: string, errorValue: string, index: number, row: number, column: number): string;\r\nexport declare function findProblemCode(input: string, errorValue: string, index: number, column: number): string;\r\nexport declare class CssToken {\r\n    index: number;\r\n    column: number;\r\n    line: number;\r\n    type: CssTokenType;\r\n    strValue: string;\r\n    numValue: number;\r\n    constructor(index: number, column: number, line: number, type: CssTokenType, strValue: string);\r\n}\r\nexport declare class CssLexer {\r\n    scan(text: string, trackComments?: boolean): CssScanner;\r\n}\r\nexport declare function cssScannerError(token: CssToken, message: string): Error;\r\nexport declare function getRawMessage(error: Error): string;\r\nexport declare function getToken(error: Error): CssToken;\r\nexport declare class CssScanner {\r\n    input: string;\r\n    private _trackComments;\r\n    peek: number;\r\n    peekPeek: number;\r\n    length: number;\r\n    index: number;\r\n    column: number;\r\n    line: number;\r\n    /** @internal */\r\n    _currentMode: CssLexerMode;\r\n    /** @internal */\r\n    _currentError: Error | null;\r\n    constructor(input: string, _trackComments?: boolean);\r\n    getMode(): CssLexerMode;\r\n    setMode(mode: CssLexerMode): void;\r\n    advance(): void;\r\n    peekAt(index: number): number;\r\n    consumeEmptyStatements(): void;\r\n    consumeWhitespace(): void;\r\n    consume(type: CssTokenType, value?: string | null): LexedCssResult;\r\n    scan(): LexedCssResult | null;\r\n    /** @internal */\r\n    _scan(): CssToken | null;\r\n    scanComment(): CssToken | null;\r\n    scanWhitespace(): CssToken;\r\n    scanString(): CssToken | null;\r\n    scanNumber(): CssToken;\r\n    scanIdentifier(): CssToken | null;\r\n    scanCssValueFunction(): CssToken;\r\n    scanCharacter(): CssToken | null;\r\n    scanAtExpression(): CssToken | null;\r\n    assertCondition(status: boolean, errorMessage: string): boolean;\r\n    error(message: string, errorTokenValue?: string | null, doNotAdvance?: boolean): CssToken;\r\n}\r\nexport declare function isNewline(code: number): boolean;\r\n",
  "/node_modules/@angular/compiler/src/css_parser/css_parser.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ParseError, ParseSourceFile, ParseSourceSpan } from '../parse_util';\r\nimport { BlockType, CssAst, CssBlockAst, CssDefinitionAst, CssKeyframeDefinitionAst, CssPseudoSelectorAst, CssRuleAst, CssSelectorAst, CssSimpleSelectorAst, CssStyleSheetAst, CssStyleValueAst, CssStylesBlockAst } from './css_ast';\r\nimport { CssToken, CssTokenType } from './css_lexer';\r\nexport { CssToken } from './css_lexer';\r\nexport { BlockType } from './css_ast';\r\nexport declare class ParsedCssResult {\r\n    errors: CssParseError[];\r\n    ast: CssStyleSheetAst;\r\n    constructor(errors: CssParseError[], ast: CssStyleSheetAst);\r\n}\r\nexport declare class CssParser {\r\n    private _errors;\r\n    private _file;\r\n    private _scanner;\r\n    private _lastToken;\r\n    /**\r\n     * @param css the CSS code that will be parsed\r\n     * @param url the name of the CSS file containing the CSS source code\r\n     */\r\n    parse(css: string, url: string): ParsedCssResult;\r\n    /** @internal */\r\n    _parseStyleSheet(delimiters: number): CssStyleSheetAst;\r\n    /** @internal */\r\n    _getSourceContent(): string;\r\n    /** @internal */\r\n    _extractSourceContent(start: number, end: number): string;\r\n    /** @internal */\r\n    _generateSourceSpan(start: CssToken | CssAst, end?: CssToken | CssAst | null): ParseSourceSpan;\r\n    /** @internal */\r\n    _resolveBlockType(token: CssToken): BlockType;\r\n    /** @internal */\r\n    _parseRule(delimiters: number): CssRuleAst;\r\n    /** @internal */\r\n    _parseAtRule(delimiters: number): CssRuleAst;\r\n    /** @internal */\r\n    _parseSelectorRule(delimiters: number): CssRuleAst;\r\n    /** @internal */\r\n    _parseSelectors(delimiters: number): CssSelectorAst[];\r\n    /** @internal */\r\n    _scan(): CssToken;\r\n    /** @internal */\r\n    _getScannerIndex(): number;\r\n    /** @internal */\r\n    _consume(type: CssTokenType, value?: string | null): CssToken;\r\n    /** @internal */\r\n    _parseKeyframeBlock(delimiters: number): CssBlockAst;\r\n    /** @internal */\r\n    _parseKeyframeDefinition(delimiters: number): CssKeyframeDefinitionAst;\r\n    /** @internal */\r\n    _parseKeyframeLabel(delimiters: number): CssToken;\r\n    /** @internal */\r\n    _parsePseudoSelector(delimiters: number): CssPseudoSelectorAst;\r\n    /** @internal */\r\n    _parseSimpleSelector(delimiters: number): CssSimpleSelectorAst;\r\n    /** @internal */\r\n    _parseSelector(delimiters: number): CssSelectorAst;\r\n    /** @internal */\r\n    _parseValue(delimiters: number): CssStyleValueAst;\r\n    /** @internal */\r\n    _collectUntilDelim(delimiters: number, assertType?: CssTokenType | null): CssToken[];\r\n    /** @internal */\r\n    _parseBlock(delimiters: number): CssBlockAst;\r\n    /** @internal */\r\n    _parseStyleBlock(delimiters: number): CssStylesBlockAst | null;\r\n    /** @internal */\r\n    _parseDefinition(delimiters: number): CssDefinitionAst;\r\n    /** @internal */\r\n    _assertCondition(status: boolean, errorMessage: string, problemToken: CssToken): boolean;\r\n    /** @internal */\r\n    _error(message: string, problemToken: CssToken): void;\r\n}\r\nexport declare class CssParseError extends ParseError {\r\n    static create(file: ParseSourceFile, offset: number, line: number, col: number, length: number, errMsg: string): CssParseError;\r\n    constructor(span: ParseSourceSpan, message: string);\r\n}\r\n",
  "/node_modules/@angular/compiler/src/directive_normalizer.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileDirectiveMetadata, CompileTemplateMetadata } from './compile_metadata';\r\nimport { CompilerConfig } from './config';\r\nimport { ViewEncapsulation } from './core';\r\nimport { HtmlParser } from './ml_parser/html_parser';\r\nimport { ResourceLoader } from './resource_loader';\r\nimport { UrlResolver } from './url_resolver';\r\nimport { SyncAsync } from './util';\r\nexport interface PrenormalizedTemplateMetadata {\r\n    ngModuleType: any;\r\n    componentType: any;\r\n    moduleUrl: string;\r\n    template: string | null;\r\n    templateUrl: string | null;\r\n    styles: string[];\r\n    styleUrls: string[];\r\n    interpolation: [string, string] | null;\r\n    encapsulation: ViewEncapsulation | null;\r\n    animations: any[];\r\n    preserveWhitespaces: boolean | null;\r\n}\r\nexport declare class DirectiveNormalizer {\r\n    private _resourceLoader;\r\n    private _urlResolver;\r\n    private _htmlParser;\r\n    private _config;\r\n    private _resourceLoaderCache;\r\n    constructor(_resourceLoader: ResourceLoader, _urlResolver: UrlResolver, _htmlParser: HtmlParser, _config: CompilerConfig);\r\n    clearCache(): void;\r\n    clearCacheFor(normalizedDirective: CompileDirectiveMetadata): void;\r\n    private _fetch;\r\n    normalizeTemplate(prenormData: PrenormalizedTemplateMetadata): SyncAsync<CompileTemplateMetadata>;\r\n    private _preParseTemplate;\r\n    private _preparseLoadedTemplate;\r\n    private _normalizeTemplateMetadata;\r\n    private _normalizeLoadedTemplateMetadata;\r\n    private _inlineStyles;\r\n    private _loadMissingExternalStylesheets;\r\n    private _normalizeStylesheet;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/directive_resolver.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileReflector } from './compile_reflector';\r\nimport { Directive, Type } from './core';\r\nexport declare class DirectiveResolver {\r\n    private _reflector;\r\n    constructor(_reflector: CompileReflector);\r\n    isDirective(type: Type): boolean;\r\n    /**\r\n     * Return {@link Directive} for a given `Type`.\r\n     */\r\n    resolve(type: Type): Directive;\r\n    resolve(type: Type, throwIfNotFound: true): Directive;\r\n    resolve(type: Type, throwIfNotFound: boolean): Directive | null;\r\n    private _mergeWithPropertyMetadata;\r\n    private _extractPublicName;\r\n    private _dedupeBindings;\r\n    private _merge;\r\n}\r\nexport declare function findLast<T>(arr: T[], condition: (value: T) => boolean): T | null;\r\n",
  "/node_modules/@angular/compiler/src/expression_parser/ast.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { SecurityContext } from '../core';\r\nimport { ParseSourceSpan } from '../parse_util';\r\nexport declare class ParserError {\r\n    input: string;\r\n    errLocation: string;\r\n    ctxLocation?: any;\r\n    message: string;\r\n    constructor(message: string, input: string, errLocation: string, ctxLocation?: any);\r\n}\r\nexport declare class ParseSpan {\r\n    start: number;\r\n    end: number;\r\n    constructor(start: number, end: number);\r\n}\r\nexport declare class AST {\r\n    span: ParseSpan;\r\n    constructor(span: ParseSpan);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n    toString(): string;\r\n}\r\n/**\r\n * Represents a quoted expression of the form:\r\n *\r\n * quote = prefix `:` uninterpretedExpression\r\n * prefix = identifier\r\n * uninterpretedExpression = arbitrary string\r\n *\r\n * A quoted expression is meant to be pre-processed by an AST transformer that\r\n * converts it into another AST that no longer contains quoted expressions.\r\n * It is meant to allow third-party developers to extend Angular template\r\n * expression language. The `uninterpretedExpression` part of the quote is\r\n * therefore not interpreted by the Angular's own expression parser.\r\n */\r\nexport declare class Quote extends AST {\r\n    prefix: string;\r\n    uninterpretedExpression: string;\r\n    location: any;\r\n    constructor(span: ParseSpan, prefix: string, uninterpretedExpression: string, location: any);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n    toString(): string;\r\n}\r\nexport declare class EmptyExpr extends AST {\r\n    visit(visitor: AstVisitor, context?: any): void;\r\n}\r\nexport declare class ImplicitReceiver extends AST {\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\n/**\r\n * Multiple expressions separated by a semicolon.\r\n */\r\nexport declare class Chain extends AST {\r\n    expressions: any[];\r\n    constructor(span: ParseSpan, expressions: any[]);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class Conditional extends AST {\r\n    condition: AST;\r\n    trueExp: AST;\r\n    falseExp: AST;\r\n    constructor(span: ParseSpan, condition: AST, trueExp: AST, falseExp: AST);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class PropertyRead extends AST {\r\n    receiver: AST;\r\n    name: string;\r\n    constructor(span: ParseSpan, receiver: AST, name: string);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class PropertyWrite extends AST {\r\n    receiver: AST;\r\n    name: string;\r\n    value: AST;\r\n    constructor(span: ParseSpan, receiver: AST, name: string, value: AST);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class SafePropertyRead extends AST {\r\n    receiver: AST;\r\n    name: string;\r\n    constructor(span: ParseSpan, receiver: AST, name: string);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class KeyedRead extends AST {\r\n    obj: AST;\r\n    key: AST;\r\n    constructor(span: ParseSpan, obj: AST, key: AST);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class KeyedWrite extends AST {\r\n    obj: AST;\r\n    key: AST;\r\n    value: AST;\r\n    constructor(span: ParseSpan, obj: AST, key: AST, value: AST);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class BindingPipe extends AST {\r\n    exp: AST;\r\n    name: string;\r\n    args: any[];\r\n    constructor(span: ParseSpan, exp: AST, name: string, args: any[]);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class LiteralPrimitive extends AST {\r\n    value: any;\r\n    constructor(span: ParseSpan, value: any);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class LiteralArray extends AST {\r\n    expressions: any[];\r\n    constructor(span: ParseSpan, expressions: any[]);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare type LiteralMapKey = {\r\n    key: string;\r\n    quoted: boolean;\r\n};\r\nexport declare class LiteralMap extends AST {\r\n    keys: LiteralMapKey[];\r\n    values: any[];\r\n    constructor(span: ParseSpan, keys: LiteralMapKey[], values: any[]);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class Interpolation extends AST {\r\n    strings: any[];\r\n    expressions: any[];\r\n    constructor(span: ParseSpan, strings: any[], expressions: any[]);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class Binary extends AST {\r\n    operation: string;\r\n    left: AST;\r\n    right: AST;\r\n    constructor(span: ParseSpan, operation: string, left: AST, right: AST);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class PrefixNot extends AST {\r\n    expression: AST;\r\n    constructor(span: ParseSpan, expression: AST);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class NonNullAssert extends AST {\r\n    expression: AST;\r\n    constructor(span: ParseSpan, expression: AST);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class MethodCall extends AST {\r\n    receiver: AST;\r\n    name: string;\r\n    args: any[];\r\n    constructor(span: ParseSpan, receiver: AST, name: string, args: any[]);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class SafeMethodCall extends AST {\r\n    receiver: AST;\r\n    name: string;\r\n    args: any[];\r\n    constructor(span: ParseSpan, receiver: AST, name: string, args: any[]);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class FunctionCall extends AST {\r\n    target: AST | null;\r\n    args: any[];\r\n    constructor(span: ParseSpan, target: AST | null, args: any[]);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n}\r\nexport declare class ASTWithSource extends AST {\r\n    ast: AST;\r\n    source: string | null;\r\n    location: string;\r\n    errors: ParserError[];\r\n    constructor(ast: AST, source: string | null, location: string, errors: ParserError[]);\r\n    visit(visitor: AstVisitor, context?: any): any;\r\n    toString(): string;\r\n}\r\nexport declare class TemplateBinding {\r\n    span: ParseSpan;\r\n    key: string;\r\n    keyIsVar: boolean;\r\n    name: string;\r\n    expression: ASTWithSource | null;\r\n    constructor(span: ParseSpan, key: string, keyIsVar: boolean, name: string, expression: ASTWithSource | null);\r\n}\r\nexport interface AstVisitor {\r\n    visitBinary(ast: Binary, context: any): any;\r\n    visitChain(ast: Chain, context: any): any;\r\n    visitConditional(ast: Conditional, context: any): any;\r\n    visitFunctionCall(ast: FunctionCall, context: any): any;\r\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\r\n    visitInterpolation(ast: Interpolation, context: any): any;\r\n    visitKeyedRead(ast: KeyedRead, context: any): any;\r\n    visitKeyedWrite(ast: KeyedWrite, context: any): any;\r\n    visitLiteralArray(ast: LiteralArray, context: any): any;\r\n    visitLiteralMap(ast: LiteralMap, context: any): any;\r\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\r\n    visitMethodCall(ast: MethodCall, context: any): any;\r\n    visitPipe(ast: BindingPipe, context: any): any;\r\n    visitPrefixNot(ast: PrefixNot, context: any): any;\r\n    visitNonNullAssert(ast: NonNullAssert, context: any): any;\r\n    visitPropertyRead(ast: PropertyRead, context: any): any;\r\n    visitPropertyWrite(ast: PropertyWrite, context: any): any;\r\n    visitQuote(ast: Quote, context: any): any;\r\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any;\r\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\r\n    visit?(ast: AST, context?: any): any;\r\n}\r\nexport declare class NullAstVisitor implements AstVisitor {\r\n    visitBinary(ast: Binary, context: any): any;\r\n    visitChain(ast: Chain, context: any): any;\r\n    visitConditional(ast: Conditional, context: any): any;\r\n    visitFunctionCall(ast: FunctionCall, context: any): any;\r\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\r\n    visitInterpolation(ast: Interpolation, context: any): any;\r\n    visitKeyedRead(ast: KeyedRead, context: any): any;\r\n    visitKeyedWrite(ast: KeyedWrite, context: any): any;\r\n    visitLiteralArray(ast: LiteralArray, context: any): any;\r\n    visitLiteralMap(ast: LiteralMap, context: any): any;\r\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\r\n    visitMethodCall(ast: MethodCall, context: any): any;\r\n    visitPipe(ast: BindingPipe, context: any): any;\r\n    visitPrefixNot(ast: PrefixNot, context: any): any;\r\n    visitNonNullAssert(ast: NonNullAssert, context: any): any;\r\n    visitPropertyRead(ast: PropertyRead, context: any): any;\r\n    visitPropertyWrite(ast: PropertyWrite, context: any): any;\r\n    visitQuote(ast: Quote, context: any): any;\r\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any;\r\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\r\n}\r\nexport declare class RecursiveAstVisitor implements AstVisitor {\r\n    visitBinary(ast: Binary, context: any): any;\r\n    visitChain(ast: Chain, context: any): any;\r\n    visitConditional(ast: Conditional, context: any): any;\r\n    visitPipe(ast: BindingPipe, context: any): any;\r\n    visitFunctionCall(ast: FunctionCall, context: any): any;\r\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\r\n    visitInterpolation(ast: Interpolation, context: any): any;\r\n    visitKeyedRead(ast: KeyedRead, context: any): any;\r\n    visitKeyedWrite(ast: KeyedWrite, context: any): any;\r\n    visitLiteralArray(ast: LiteralArray, context: any): any;\r\n    visitLiteralMap(ast: LiteralMap, context: any): any;\r\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\r\n    visitMethodCall(ast: MethodCall, context: any): any;\r\n    visitPrefixNot(ast: PrefixNot, context: any): any;\r\n    visitNonNullAssert(ast: NonNullAssert, context: any): any;\r\n    visitPropertyRead(ast: PropertyRead, context: any): any;\r\n    visitPropertyWrite(ast: PropertyWrite, context: any): any;\r\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\r\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any;\r\n    visitAll(asts: AST[], context: any): any;\r\n    visitQuote(ast: Quote, context: any): any;\r\n}\r\nexport declare class AstTransformer implements AstVisitor {\r\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST;\r\n    visitInterpolation(ast: Interpolation, context: any): AST;\r\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST;\r\n    visitPropertyRead(ast: PropertyRead, context: any): AST;\r\n    visitPropertyWrite(ast: PropertyWrite, context: any): AST;\r\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): AST;\r\n    visitMethodCall(ast: MethodCall, context: any): AST;\r\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): AST;\r\n    visitFunctionCall(ast: FunctionCall, context: any): AST;\r\n    visitLiteralArray(ast: LiteralArray, context: any): AST;\r\n    visitLiteralMap(ast: LiteralMap, context: any): AST;\r\n    visitBinary(ast: Binary, context: any): AST;\r\n    visitPrefixNot(ast: PrefixNot, context: any): AST;\r\n    visitNonNullAssert(ast: NonNullAssert, context: any): AST;\r\n    visitConditional(ast: Conditional, context: any): AST;\r\n    visitPipe(ast: BindingPipe, context: any): AST;\r\n    visitKeyedRead(ast: KeyedRead, context: any): AST;\r\n    visitKeyedWrite(ast: KeyedWrite, context: any): AST;\r\n    visitAll(asts: any[]): any[];\r\n    visitChain(ast: Chain, context: any): AST;\r\n    visitQuote(ast: Quote, context: any): AST;\r\n}\r\nexport declare class AstMemoryEfficientTransformer implements AstVisitor {\r\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST;\r\n    visitInterpolation(ast: Interpolation, context: any): Interpolation;\r\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST;\r\n    visitPropertyRead(ast: PropertyRead, context: any): AST;\r\n    visitPropertyWrite(ast: PropertyWrite, context: any): AST;\r\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): AST;\r\n    visitMethodCall(ast: MethodCall, context: any): AST;\r\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): AST;\r\n    visitFunctionCall(ast: FunctionCall, context: any): AST;\r\n    visitLiteralArray(ast: LiteralArray, context: any): AST;\r\n    visitLiteralMap(ast: LiteralMap, context: any): AST;\r\n    visitBinary(ast: Binary, context: any): AST;\r\n    visitPrefixNot(ast: PrefixNot, context: any): AST;\r\n    visitNonNullAssert(ast: NonNullAssert, context: any): AST;\r\n    visitConditional(ast: Conditional, context: any): AST;\r\n    visitPipe(ast: BindingPipe, context: any): AST;\r\n    visitKeyedRead(ast: KeyedRead, context: any): AST;\r\n    visitKeyedWrite(ast: KeyedWrite, context: any): AST;\r\n    visitAll(asts: any[]): any[];\r\n    visitChain(ast: Chain, context: any): AST;\r\n    visitQuote(ast: Quote, context: any): AST;\r\n}\r\nexport declare function visitAstChildren(ast: AST, visitor: AstVisitor, context?: any): void;\r\nexport declare class ParsedProperty {\r\n    name: string;\r\n    expression: ASTWithSource;\r\n    type: ParsedPropertyType;\r\n    sourceSpan: ParseSourceSpan;\r\n    readonly isLiteral: boolean;\r\n    readonly isAnimation: boolean;\r\n    constructor(name: string, expression: ASTWithSource, type: ParsedPropertyType, sourceSpan: ParseSourceSpan);\r\n}\r\nexport declare enum ParsedPropertyType {\r\n    DEFAULT = 0,\r\n    LITERAL_ATTR = 1,\r\n    ANIMATION = 2\r\n}\r\nexport declare const enum ParsedEventType {\r\n    Regular = 0,\r\n    Animation = 1\r\n}\r\nexport declare class ParsedEvent {\r\n    name: string;\r\n    targetOrPhase: string;\r\n    type: ParsedEventType;\r\n    handler: AST;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(name: string, targetOrPhase: string, type: ParsedEventType, handler: AST, sourceSpan: ParseSourceSpan);\r\n}\r\nexport declare class ParsedVariable {\r\n    name: string;\r\n    value: string;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(name: string, value: string, sourceSpan: ParseSourceSpan);\r\n}\r\nexport declare const enum BindingType {\r\n    Property = 0,\r\n    Attribute = 1,\r\n    Class = 2,\r\n    Style = 3,\r\n    Animation = 4\r\n}\r\nexport declare class BoundElementProperty {\r\n    name: string;\r\n    type: BindingType;\r\n    securityContext: SecurityContext;\r\n    value: AST;\r\n    unit: string | null;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(name: string, type: BindingType, securityContext: SecurityContext, value: AST, unit: string | null, sourceSpan: ParseSourceSpan);\r\n}\r\n",
  "/node_modules/@angular/compiler/src/expression_parser/lexer.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare enum TokenType {\r\n    Character = 0,\r\n    Identifier = 1,\r\n    Keyword = 2,\r\n    String = 3,\r\n    Operator = 4,\r\n    Number = 5,\r\n    Error = 6\r\n}\r\nexport declare class Lexer {\r\n    tokenize(text: string): Token[];\r\n}\r\nexport declare class Token {\r\n    index: number;\r\n    type: TokenType;\r\n    numValue: number;\r\n    strValue: string;\r\n    constructor(index: number, type: TokenType, numValue: number, strValue: string);\r\n    isCharacter(code: number): boolean;\r\n    isNumber(): boolean;\r\n    isString(): boolean;\r\n    isOperator(operater: string): boolean;\r\n    isIdentifier(): boolean;\r\n    isKeyword(): boolean;\r\n    isKeywordLet(): boolean;\r\n    isKeywordAs(): boolean;\r\n    isKeywordNull(): boolean;\r\n    isKeywordUndefined(): boolean;\r\n    isKeywordTrue(): boolean;\r\n    isKeywordFalse(): boolean;\r\n    isKeywordThis(): boolean;\r\n    isError(): boolean;\r\n    toNumber(): number;\r\n    toString(): string | null;\r\n}\r\nexport declare const EOF: Token;\r\nexport declare function isIdentifier(input: string): boolean;\r\nexport declare function isQuote(code: number): boolean;\r\n",
  "/node_modules/@angular/compiler/src/expression_parser/parser.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { InterpolationConfig } from '../ml_parser/interpolation_config';\r\nimport { AST, ASTWithSource, BindingPipe, LiteralMap, ParseSpan, ParserError, TemplateBinding } from './ast';\r\nimport { Lexer, Token } from './lexer';\r\nexport declare class SplitInterpolation {\r\n    strings: string[];\r\n    expressions: string[];\r\n    offsets: number[];\r\n    constructor(strings: string[], expressions: string[], offsets: number[]);\r\n}\r\nexport declare class TemplateBindingParseResult {\r\n    templateBindings: TemplateBinding[];\r\n    warnings: string[];\r\n    errors: ParserError[];\r\n    constructor(templateBindings: TemplateBinding[], warnings: string[], errors: ParserError[]);\r\n}\r\nexport declare class Parser {\r\n    private _lexer;\r\n    private errors;\r\n    constructor(_lexer: Lexer);\r\n    parseAction(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource;\r\n    parseBinding(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource;\r\n    parseSimpleBinding(input: string, location: string, interpolationConfig?: InterpolationConfig): ASTWithSource;\r\n    private _reportError;\r\n    private _parseBindingAst;\r\n    private _parseQuote;\r\n    parseTemplateBindings(tplKey: string, tplValue: string, location: any): TemplateBindingParseResult;\r\n    parseInterpolation(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource | null;\r\n    splitInterpolation(input: string, location: string, interpolationConfig?: InterpolationConfig): SplitInterpolation | null;\r\n    wrapLiteralPrimitive(input: string | null, location: any): ASTWithSource;\r\n    private _stripComments;\r\n    private _commentStart;\r\n    private _checkNoInterpolation;\r\n    private _findInterpolationErrorColumn;\r\n}\r\nexport declare class _ParseAST {\r\n    input: string;\r\n    location: any;\r\n    tokens: Token[];\r\n    inputLength: number;\r\n    parseAction: boolean;\r\n    private errors;\r\n    private offset;\r\n    private rparensExpected;\r\n    private rbracketsExpected;\r\n    private rbracesExpected;\r\n    index: number;\r\n    constructor(input: string, location: any, tokens: Token[], inputLength: number, parseAction: boolean, errors: ParserError[], offset: number);\r\n    peek(offset: number): Token;\r\n    readonly next: Token;\r\n    readonly inputIndex: number;\r\n    span(start: number): ParseSpan;\r\n    advance(): void;\r\n    optionalCharacter(code: number): boolean;\r\n    peekKeywordLet(): boolean;\r\n    peekKeywordAs(): boolean;\r\n    expectCharacter(code: number): void;\r\n    optionalOperator(op: string): boolean;\r\n    expectOperator(operator: string): void;\r\n    expectIdentifierOrKeyword(): string;\r\n    expectIdentifierOrKeywordOrString(): string;\r\n    parseChain(): AST;\r\n    parsePipe(): AST;\r\n    parseExpression(): AST;\r\n    parseConditional(): AST;\r\n    parseLogicalOr(): AST;\r\n    parseLogicalAnd(): AST;\r\n    parseEquality(): AST;\r\n    parseRelational(): AST;\r\n    parseAdditive(): AST;\r\n    parseMultiplicative(): AST;\r\n    parsePrefix(): AST;\r\n    parseCallChain(): AST;\r\n    parsePrimary(): AST;\r\n    parseExpressionList(terminator: number): AST[];\r\n    parseLiteralMap(): LiteralMap;\r\n    parseAccessMemberOrMethodCall(receiver: AST, isSafe?: boolean): AST;\r\n    parseCallArguments(): BindingPipe[];\r\n    /**\r\n     * An identifier, a keyword, a string with an optional `-` in between.\r\n     */\r\n    expectTemplateBindingKey(): string;\r\n    parseTemplateBindings(tplKey: string): TemplateBindingParseResult;\r\n    error(message: string, index?: number | null): void;\r\n    private locationText;\r\n    private skip;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/i18n/digest.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as i18n from './i18n_ast';\r\nexport declare function digest(message: i18n.Message): string;\r\nexport declare function decimalDigest(message: i18n.Message): string;\r\nexport declare function serializeNodes(nodes: i18n.Node[]): string[];\r\n/**\r\n * Compute the SHA1 of the given string\r\n *\r\n * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\r\n *\r\n * WARNING: this function has not been designed not tested with security in mind.\r\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\r\n */\r\nexport declare function sha1(str: string): string;\r\n/**\r\n * Compute the fingerprint of the given string\r\n *\r\n * The output is 64 bit number encoded as a decimal string\r\n *\r\n * based on:\r\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\r\n */\r\nexport declare function fingerprint(str: string): [number, number];\r\nexport declare function computeMsgId(msg: string, meaning: string): string;\r\n",
  "/node_modules/@angular/compiler/src/i18n/extractor.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { StaticReflector } from '../aot/static_reflector';\r\nimport { StaticSymbolResolver, StaticSymbolResolverHost } from '../aot/static_symbol_resolver';\r\nimport { AotSummaryResolverHost } from '../aot/summary_resolver';\r\nimport { CompileMetadataResolver } from '../metadata_resolver';\r\nimport { MessageBundle } from './message_bundle';\r\n/**\r\n * The host of the Extractor disconnects the implementation from TypeScript / other language\r\n * services and from underlying file systems.\r\n */\r\nexport interface ExtractorHost extends StaticSymbolResolverHost, AotSummaryResolverHost {\r\n    /**\r\n     * Converts a path that refers to a resource into an absolute filePath\r\n     * that can be lateron used for loading the resource via `loadResource.\r\n     */\r\n    resourceNameToFileName(path: string, containingFile: string): string | null;\r\n    /**\r\n     * Loads a resource (e.g. html / css)\r\n     */\r\n    loadResource(path: string): Promise<string> | string;\r\n}\r\nexport declare class Extractor {\r\n    host: ExtractorHost;\r\n    private staticSymbolResolver;\r\n    private messageBundle;\r\n    private metadataResolver;\r\n    constructor(host: ExtractorHost, staticSymbolResolver: StaticSymbolResolver, messageBundle: MessageBundle, metadataResolver: CompileMetadataResolver);\r\n    extract(rootFiles: string[]): Promise<MessageBundle>;\r\n    static create(host: ExtractorHost, locale: string | null): {\r\n        extractor: Extractor;\r\n        staticReflector: StaticReflector;\r\n    };\r\n}\r\n",
  "/node_modules/@angular/compiler/src/i18n/extractor_merger.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as html from '../ml_parser/ast';\r\nimport { InterpolationConfig } from '../ml_parser/interpolation_config';\r\nimport { ParseTreeResult } from '../ml_parser/parser';\r\nimport * as i18n from './i18n_ast';\r\nimport { I18nError } from './parse_util';\r\nimport { TranslationBundle } from './translation_bundle';\r\n/**\r\n * Extract translatable messages from an html AST\r\n */\r\nexport declare function extractMessages(nodes: html.Node[], interpolationConfig: InterpolationConfig, implicitTags: string[], implicitAttrs: {\r\n    [k: string]: string[];\r\n}): ExtractionResult;\r\nexport declare function mergeTranslations(nodes: html.Node[], translations: TranslationBundle, interpolationConfig: InterpolationConfig, implicitTags: string[], implicitAttrs: {\r\n    [k: string]: string[];\r\n}): ParseTreeResult;\r\nexport declare class ExtractionResult {\r\n    messages: i18n.Message[];\r\n    errors: I18nError[];\r\n    constructor(messages: i18n.Message[], errors: I18nError[]);\r\n}\r\n",
  "/node_modules/@angular/compiler/src/i18n/i18n_ast.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ParseSourceSpan } from '../parse_util';\r\nexport declare class Message {\r\n    nodes: Node[];\r\n    placeholders: {\r\n        [phName: string]: string;\r\n    };\r\n    placeholderToMessage: {\r\n        [phName: string]: Message;\r\n    };\r\n    meaning: string;\r\n    description: string;\r\n    id: string;\r\n    sources: MessageSpan[];\r\n    /**\r\n     * @param nodes message AST\r\n     * @param placeholders maps placeholder names to static content\r\n     * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\r\n     * @param meaning\r\n     * @param description\r\n     * @param id\r\n     */\r\n    constructor(nodes: Node[], placeholders: {\r\n        [phName: string]: string;\r\n    }, placeholderToMessage: {\r\n        [phName: string]: Message;\r\n    }, meaning: string, description: string, id: string);\r\n}\r\nexport interface MessageSpan {\r\n    filePath: string;\r\n    startLine: number;\r\n    startCol: number;\r\n    endLine: number;\r\n    endCol: number;\r\n}\r\nexport interface Node {\r\n    sourceSpan: ParseSourceSpan;\r\n    visit(visitor: Visitor, context?: any): any;\r\n}\r\nexport declare class Text implements Node {\r\n    value: string;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(value: string, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: Visitor, context?: any): any;\r\n}\r\nexport declare class Container implements Node {\r\n    children: Node[];\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(children: Node[], sourceSpan: ParseSourceSpan);\r\n    visit(visitor: Visitor, context?: any): any;\r\n}\r\nexport declare class Icu implements Node {\r\n    expression: string;\r\n    type: string;\r\n    cases: {\r\n        [k: string]: Node;\r\n    };\r\n    sourceSpan: ParseSourceSpan;\r\n    expressionPlaceholder: string;\r\n    constructor(expression: string, type: string, cases: {\r\n        [k: string]: Node;\r\n    }, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: Visitor, context?: any): any;\r\n}\r\nexport declare class TagPlaceholder implements Node {\r\n    tag: string;\r\n    attrs: {\r\n        [k: string]: string;\r\n    };\r\n    startName: string;\r\n    closeName: string;\r\n    children: Node[];\r\n    isVoid: boolean;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(tag: string, attrs: {\r\n        [k: string]: string;\r\n    }, startName: string, closeName: string, children: Node[], isVoid: boolean, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: Visitor, context?: any): any;\r\n}\r\nexport declare class Placeholder implements Node {\r\n    value: string;\r\n    name: string;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(value: string, name: string, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: Visitor, context?: any): any;\r\n}\r\nexport declare class IcuPlaceholder implements Node {\r\n    value: Icu;\r\n    name: string;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(value: Icu, name: string, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: Visitor, context?: any): any;\r\n}\r\nexport interface Visitor {\r\n    visitText(text: Text, context?: any): any;\r\n    visitContainer(container: Container, context?: any): any;\r\n    visitIcu(icu: Icu, context?: any): any;\r\n    visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;\r\n    visitPlaceholder(ph: Placeholder, context?: any): any;\r\n    visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;\r\n}\r\nexport declare class CloneVisitor implements Visitor {\r\n    visitText(text: Text, context?: any): Text;\r\n    visitContainer(container: Container, context?: any): Container;\r\n    visitIcu(icu: Icu, context?: any): Icu;\r\n    visitTagPlaceholder(ph: TagPlaceholder, context?: any): TagPlaceholder;\r\n    visitPlaceholder(ph: Placeholder, context?: any): Placeholder;\r\n    visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): IcuPlaceholder;\r\n}\r\nexport declare class RecurseVisitor implements Visitor {\r\n    visitText(text: Text, context?: any): any;\r\n    visitContainer(container: Container, context?: any): any;\r\n    visitIcu(icu: Icu, context?: any): any;\r\n    visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;\r\n    visitPlaceholder(ph: Placeholder, context?: any): any;\r\n    visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/i18n/i18n_html_parser.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { MissingTranslationStrategy } from '../core';\r\nimport { HtmlParser } from '../ml_parser/html_parser';\r\nimport { InterpolationConfig } from '../ml_parser/interpolation_config';\r\nimport { ParseTreeResult } from '../ml_parser/parser';\r\nimport { Console } from '../util';\r\nexport declare class I18NHtmlParser implements HtmlParser {\r\n    private _htmlParser;\r\n    getTagDefinition: any;\r\n    private _translationBundle;\r\n    constructor(_htmlParser: HtmlParser, translations?: string, translationsFormat?: string, missingTranslation?: MissingTranslationStrategy, console?: Console);\r\n    parse(source: string, url: string, parseExpansionForms?: boolean, interpolationConfig?: InterpolationConfig): ParseTreeResult;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/i18n/i18n_parser.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as html from '../ml_parser/ast';\r\nimport { InterpolationConfig } from '../ml_parser/interpolation_config';\r\nimport * as i18n from './i18n_ast';\r\n/**\r\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\r\n */\r\nexport declare function createI18nMessageFactory(interpolationConfig: InterpolationConfig): (nodes: html.Node[], meaning: string, description: string, id: string) => i18n.Message;\r\n",
  "/node_modules/@angular/compiler/src/i18n/index.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { Extractor, ExtractorHost } from './extractor';\r\nexport { I18NHtmlParser } from './i18n_html_parser';\r\nexport { MessageBundle } from './message_bundle';\r\nexport { Serializer } from './serializers/serializer';\r\nexport { Xliff } from './serializers/xliff';\r\nexport { Xliff2 } from './serializers/xliff2';\r\nexport { Xmb } from './serializers/xmb';\r\nexport { Xtb } from './serializers/xtb';\r\n",
  "/node_modules/@angular/compiler/src/i18n/message_bundle.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { HtmlParser } from '../ml_parser/html_parser';\r\nimport { InterpolationConfig } from '../ml_parser/interpolation_config';\r\nimport { ParseError } from '../parse_util';\r\nimport * as i18n from './i18n_ast';\r\nimport { Serializer } from './serializers/serializer';\r\n/**\r\n * A container for message extracted from the templates.\r\n */\r\nexport declare class MessageBundle {\r\n    private _htmlParser;\r\n    private _implicitTags;\r\n    private _implicitAttrs;\r\n    private _locale;\r\n    private _messages;\r\n    constructor(_htmlParser: HtmlParser, _implicitTags: string[], _implicitAttrs: {\r\n        [k: string]: string[];\r\n    }, _locale?: string | null);\r\n    updateFromTemplate(html: string, url: string, interpolationConfig: InterpolationConfig): ParseError[];\r\n    getMessages(): i18n.Message[];\r\n    write(serializer: Serializer, filterSources?: (path: string) => string): string;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/i18n/parse_util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ParseError, ParseSourceSpan } from '../parse_util';\r\n/**\r\n * An i18n error.\r\n */\r\nexport declare class I18nError extends ParseError {\r\n    constructor(span: ParseSourceSpan, msg: string);\r\n}\r\n",
  "/node_modules/@angular/compiler/src/i18n/serializers/placeholder.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Creates unique names for placeholder with different content.\r\n *\r\n * Returns the same placeholder name when the content is identical.\r\n */\r\nexport declare class PlaceholderRegistry {\r\n    private _placeHolderNameCounts;\r\n    private _signatureToName;\r\n    getStartTagPlaceholderName(tag: string, attrs: {\r\n        [k: string]: string;\r\n    }, isVoid: boolean): string;\r\n    getCloseTagPlaceholderName(tag: string): string;\r\n    getPlaceholderName(name: string, content: string): string;\r\n    getUniquePlaceholder(name: string): string;\r\n    private _hashTag;\r\n    private _hashClosingTag;\r\n    private _generateUniqueName;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/i18n/serializers/serializer.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as i18n from '../i18n_ast';\r\nexport declare abstract class Serializer {\r\n    abstract write(messages: i18n.Message[], locale: string | null): string;\r\n    abstract load(content: string, url: string): {\r\n        locale: string | null;\r\n        i18nNodesByMsgId: {\r\n            [msgId: string]: i18n.Node[];\r\n        };\r\n    };\r\n    abstract digest(message: i18n.Message): string;\r\n    createNameMapper(message: i18n.Message): PlaceholderMapper | null;\r\n}\r\n/**\r\n * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and\r\n * back.\r\n *\r\n * It should be used for serialization format that put constraints on the placeholder names.\r\n */\r\nexport interface PlaceholderMapper {\r\n    toPublicName(internalName: string): string | null;\r\n    toInternalName(publicName: string): string | null;\r\n}\r\n/**\r\n * A simple mapper that take a function to transform an internal name to a public name\r\n */\r\nexport declare class SimplePlaceholderMapper extends i18n.RecurseVisitor implements PlaceholderMapper {\r\n    private mapName;\r\n    private internalToPublic;\r\n    private publicToNextId;\r\n    private publicToInternal;\r\n    constructor(message: i18n.Message, mapName: (name: string) => string);\r\n    toPublicName(internalName: string): string | null;\r\n    toInternalName(publicName: string): string | null;\r\n    visitText(text: i18n.Text, context?: any): any;\r\n    visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): any;\r\n    visitPlaceholder(ph: i18n.Placeholder, context?: any): any;\r\n    visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any;\r\n    private visitPlaceholderName;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/i18n/serializers/xliff.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as i18n from '../i18n_ast';\r\nimport { Serializer } from './serializer';\r\nexport declare class Xliff extends Serializer {\r\n    write(messages: i18n.Message[], locale: string | null): string;\r\n    load(content: string, url: string): {\r\n        locale: string;\r\n        i18nNodesByMsgId: {\r\n            [msgId: string]: i18n.Node[];\r\n        };\r\n    };\r\n    digest(message: i18n.Message): string;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/i18n/serializers/xliff2.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as i18n from '../i18n_ast';\r\nimport { Serializer } from './serializer';\r\nexport declare class Xliff2 extends Serializer {\r\n    write(messages: i18n.Message[], locale: string | null): string;\r\n    load(content: string, url: string): {\r\n        locale: string;\r\n        i18nNodesByMsgId: {\r\n            [msgId: string]: i18n.Node[];\r\n        };\r\n    };\r\n    digest(message: i18n.Message): string;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/i18n/serializers/xmb.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as i18n from '../i18n_ast';\r\nimport { PlaceholderMapper, Serializer } from './serializer';\r\nexport declare class Xmb extends Serializer {\r\n    write(messages: i18n.Message[], locale: string | null): string;\r\n    load(content: string, url: string): {\r\n        locale: string;\r\n        i18nNodesByMsgId: {\r\n            [msgId: string]: i18n.Node[];\r\n        };\r\n    };\r\n    digest(message: i18n.Message): string;\r\n    createNameMapper(message: i18n.Message): PlaceholderMapper;\r\n}\r\nexport declare function digest(message: i18n.Message): string;\r\nexport declare function toPublicName(internalName: string): string;\r\n",
  "/node_modules/@angular/compiler/src/i18n/serializers/xml_helper.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport interface IVisitor {\r\n    visitTag(tag: Tag): any;\r\n    visitText(text: Text): any;\r\n    visitDeclaration(decl: Declaration): any;\r\n    visitDoctype(doctype: Doctype): any;\r\n}\r\nexport declare function serialize(nodes: Node[]): string;\r\nexport interface Node {\r\n    visit(visitor: IVisitor): any;\r\n}\r\nexport declare class Declaration implements Node {\r\n    attrs: {\r\n        [k: string]: string;\r\n    };\r\n    constructor(unescapedAttrs: {\r\n        [k: string]: string;\r\n    });\r\n    visit(visitor: IVisitor): any;\r\n}\r\nexport declare class Doctype implements Node {\r\n    rootTag: string;\r\n    dtd: string;\r\n    constructor(rootTag: string, dtd: string);\r\n    visit(visitor: IVisitor): any;\r\n}\r\nexport declare class Tag implements Node {\r\n    name: string;\r\n    children: Node[];\r\n    attrs: {\r\n        [k: string]: string;\r\n    };\r\n    constructor(name: string, unescapedAttrs?: {\r\n        [k: string]: string;\r\n    }, children?: Node[]);\r\n    visit(visitor: IVisitor): any;\r\n}\r\nexport declare class Text implements Node {\r\n    value: string;\r\n    constructor(unescapedValue: string);\r\n    visit(visitor: IVisitor): any;\r\n}\r\nexport declare class CR extends Text {\r\n    constructor(ws?: number);\r\n}\r\nexport declare function escapeXml(text: string): string;\r\n",
  "/node_modules/@angular/compiler/src/i18n/serializers/xtb.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as i18n from '../i18n_ast';\r\nimport { PlaceholderMapper, Serializer } from './serializer';\r\nexport declare class Xtb extends Serializer {\r\n    write(messages: i18n.Message[], locale: string | null): string;\r\n    load(content: string, url: string): {\r\n        locale: string;\r\n        i18nNodesByMsgId: {\r\n            [msgId: string]: i18n.Node[];\r\n        };\r\n    };\r\n    digest(message: i18n.Message): string;\r\n    createNameMapper(message: i18n.Message): PlaceholderMapper;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/i18n/translation_bundle.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { MissingTranslationStrategy } from '../core';\r\nimport * as html from '../ml_parser/ast';\r\nimport { Console } from '../util';\r\nimport * as i18n from './i18n_ast';\r\nimport { PlaceholderMapper, Serializer } from './serializers/serializer';\r\n/**\r\n * A container for translated messages\r\n */\r\nexport declare class TranslationBundle {\r\n    private _i18nNodesByMsgId;\r\n    digest: (m: i18n.Message) => string;\r\n    mapperFactory?: (m: i18n.Message) => PlaceholderMapper;\r\n    private _i18nToHtml;\r\n    constructor(_i18nNodesByMsgId: {\r\n        [msgId: string]: i18n.Node[];\r\n    }, locale: string | null, digest: (m: i18n.Message) => string, mapperFactory?: (m: i18n.Message) => PlaceholderMapper, missingTranslationStrategy?: MissingTranslationStrategy, console?: Console);\r\n    static load(content: string, url: string, serializer: Serializer, missingTranslationStrategy: MissingTranslationStrategy, console?: Console): TranslationBundle;\r\n    get(srcMsg: i18n.Message): html.Node[];\r\n    has(srcMsg: i18n.Message): boolean;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/identifiers.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileTokenMetadata } from './compile_metadata';\r\nimport { CompileReflector } from './compile_reflector';\r\nimport * as o from './output/output_ast';\r\nexport declare class Identifiers {\r\n    static ANALYZE_FOR_ENTRY_COMPONENTS: o.ExternalReference;\r\n    static ElementRef: o.ExternalReference;\r\n    static NgModuleRef: o.ExternalReference;\r\n    static ViewContainerRef: o.ExternalReference;\r\n    static ChangeDetectorRef: o.ExternalReference;\r\n    static QueryList: o.ExternalReference;\r\n    static TemplateRef: o.ExternalReference;\r\n    static Renderer2: o.ExternalReference;\r\n    static CodegenComponentFactoryResolver: o.ExternalReference;\r\n    static ComponentFactoryResolver: o.ExternalReference;\r\n    static ComponentFactory: o.ExternalReference;\r\n    static ComponentRef: o.ExternalReference;\r\n    static NgModuleFactory: o.ExternalReference;\r\n    static createModuleFactory: o.ExternalReference;\r\n    static moduleDef: o.ExternalReference;\r\n    static moduleProviderDef: o.ExternalReference;\r\n    static RegisterModuleFactoryFn: o.ExternalReference;\r\n    static inject: o.ExternalReference;\r\n    static INJECTOR: o.ExternalReference;\r\n    static Injector: o.ExternalReference;\r\n    static defineInjectable: o.ExternalReference;\r\n    static InjectableDef: o.ExternalReference;\r\n    static ViewEncapsulation: o.ExternalReference;\r\n    static ChangeDetectionStrategy: o.ExternalReference;\r\n    static SecurityContext: o.ExternalReference;\r\n    static LOCALE_ID: o.ExternalReference;\r\n    static TRANSLATIONS_FORMAT: o.ExternalReference;\r\n    static inlineInterpolate: o.ExternalReference;\r\n    static interpolate: o.ExternalReference;\r\n    static EMPTY_ARRAY: o.ExternalReference;\r\n    static EMPTY_MAP: o.ExternalReference;\r\n    static Renderer: o.ExternalReference;\r\n    static viewDef: o.ExternalReference;\r\n    static elementDef: o.ExternalReference;\r\n    static anchorDef: o.ExternalReference;\r\n    static textDef: o.ExternalReference;\r\n    static directiveDef: o.ExternalReference;\r\n    static providerDef: o.ExternalReference;\r\n    static queryDef: o.ExternalReference;\r\n    static pureArrayDef: o.ExternalReference;\r\n    static pureObjectDef: o.ExternalReference;\r\n    static purePipeDef: o.ExternalReference;\r\n    static pipeDef: o.ExternalReference;\r\n    static nodeValue: o.ExternalReference;\r\n    static ngContentDef: o.ExternalReference;\r\n    static unwrapValue: o.ExternalReference;\r\n    static createRendererType2: o.ExternalReference;\r\n    static RendererType2: o.ExternalReference;\r\n    static ViewDefinition: o.ExternalReference;\r\n    static createComponentFactory: o.ExternalReference;\r\n}\r\nexport declare function createTokenForReference(reference: any): CompileTokenMetadata;\r\nexport declare function createTokenForExternalReference(reflector: CompileReflector, reference: o.ExternalReference): CompileTokenMetadata;\r\n",
  "/node_modules/@angular/compiler/src/injectable_compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileInjectableMetadata } from './compile_metadata';\r\nimport { CompileReflector } from './compile_reflector';\r\nimport * as o from './output/output_ast';\r\nimport { OutputContext } from './util';\r\nexport declare class InjectableCompiler {\r\n    private reflector;\r\n    private alwaysGenerateDef;\r\n    private tokenInjector;\r\n    constructor(reflector: CompileReflector, alwaysGenerateDef: boolean);\r\n    private depsArray;\r\n    factoryFor(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression;\r\n    injectableDef(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression;\r\n    compile(injectable: CompileInjectableMetadata, ctx: OutputContext): void;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/injectable_compiler_2.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as o from './output/output_ast';\r\nimport { R3DependencyMetadata } from './render3/r3_factory';\r\nexport interface InjectableDef {\r\n    expression: o.Expression;\r\n    type: o.Type;\r\n    statements: o.Statement[];\r\n}\r\nexport interface R3InjectableMetadata {\r\n    name: string;\r\n    type: o.Expression;\r\n    ctorDeps: R3DependencyMetadata[] | null;\r\n    providedIn: o.Expression;\r\n    useClass?: o.Expression;\r\n    useFactory?: o.Expression;\r\n    useExisting?: o.Expression;\r\n    useValue?: o.Expression;\r\n    userDeps?: R3DependencyMetadata[];\r\n}\r\nexport declare function compileInjectable(meta: R3InjectableMetadata): InjectableDef;\r\n",
  "/node_modules/@angular/compiler/src/jit/compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileProviderMetadata } from '../compile_metadata';\r\nimport { CompileReflector } from '../compile_reflector';\r\nimport { CompilerConfig } from '../config';\r\nimport { Type } from '../core';\r\nimport { CompileMetadataResolver } from '../metadata_resolver';\r\nimport { NgModuleCompiler } from '../ng_module_compiler';\r\nimport { StyleCompiler } from '../style_compiler';\r\nimport { SummaryResolver } from '../summary_resolver';\r\nimport { TemplateParser } from '../template_parser/template_parser';\r\nimport { Console } from '../util';\r\nimport { ViewCompiler } from '../view_compiler/view_compiler';\r\nexport interface ModuleWithComponentFactories {\r\n    ngModuleFactory: object;\r\n    componentFactories: object[];\r\n}\r\n/**\r\n * An internal module of the Angular compiler that begins with component types,\r\n * extracts templates, and eventually produces a compiled version of the component\r\n * ready for linking into an application.\r\n *\r\n * @security  When compiling templates at runtime, you must ensure that the entire template comes\r\n * from a trusted source. Attacker-controlled data introduced by a template could expose your\r\n * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).\r\n */\r\nexport declare class JitCompiler {\r\n    private _metadataResolver;\r\n    private _templateParser;\r\n    private _styleCompiler;\r\n    private _viewCompiler;\r\n    private _ngModuleCompiler;\r\n    private _summaryResolver;\r\n    private _reflector;\r\n    private _compilerConfig;\r\n    private _console;\r\n    private getExtraNgModuleProviders;\r\n    private _compiledTemplateCache;\r\n    private _compiledHostTemplateCache;\r\n    private _compiledDirectiveWrapperCache;\r\n    private _compiledNgModuleCache;\r\n    private _sharedStylesheetCount;\r\n    private _addedAotSummaries;\r\n    constructor(_metadataResolver: CompileMetadataResolver, _templateParser: TemplateParser, _styleCompiler: StyleCompiler, _viewCompiler: ViewCompiler, _ngModuleCompiler: NgModuleCompiler, _summaryResolver: SummaryResolver<Type>, _reflector: CompileReflector, _compilerConfig: CompilerConfig, _console: Console, getExtraNgModuleProviders: (ngModule: any) => CompileProviderMetadata[]);\r\n    compileModuleSync(moduleType: Type): object;\r\n    compileModuleAsync(moduleType: Type): Promise<object>;\r\n    compileModuleAndAllComponentsSync(moduleType: Type): ModuleWithComponentFactories;\r\n    compileModuleAndAllComponentsAsync(moduleType: Type): Promise<ModuleWithComponentFactories>;\r\n    getComponentFactory(component: Type): object;\r\n    loadAotSummaries(summaries: () => any[]): void;\r\n    private _addAotSummaries;\r\n    hasAotSummary(ref: Type): boolean;\r\n    private _filterJitIdentifiers;\r\n    private _compileModuleAndComponents;\r\n    private _compileModuleAndAllComponents;\r\n    private _loadModules;\r\n    private _compileModule;\r\n    /**\r\n     * @internal\r\n     */\r\n    _compileComponents(mainModule: Type, allComponentFactories: object[] | null): void;\r\n    clearCacheFor(type: Type): void;\r\n    clearCache(): void;\r\n    private _createCompiledHostTemplate;\r\n    private _createCompiledTemplate;\r\n    private _compileTemplate;\r\n    private _parseTemplate;\r\n    private _resolveStylesCompileResult;\r\n    private _resolveAndEvalStylesCompileResult;\r\n    private _interpretOrJit;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/lifecycle_reflector.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileReflector } from './compile_reflector';\r\nexport declare enum LifecycleHooks {\r\n    OnInit = 0,\r\n    OnDestroy = 1,\r\n    DoCheck = 2,\r\n    OnChanges = 3,\r\n    AfterContentInit = 4,\r\n    AfterContentChecked = 5,\r\n    AfterViewInit = 6,\r\n    AfterViewChecked = 7\r\n}\r\nexport declare const LIFECYCLE_HOOKS_VALUES: LifecycleHooks[];\r\nexport declare function hasLifecycleHook(reflector: CompileReflector, hook: LifecycleHooks, token: any): boolean;\r\nexport declare function getAllLifecycleHooks(reflector: CompileReflector, token: any): LifecycleHooks[];\r\n",
  "/node_modules/@angular/compiler/src/metadata_resolver.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { StaticSymbol, StaticSymbolCache } from './aot/static_symbol';\r\nimport * as cpl from './compile_metadata';\r\nimport { CompileReflector } from './compile_reflector';\r\nimport { CompilerConfig } from './config';\r\nimport { Directive, Type } from './core';\r\nimport { DirectiveNormalizer } from './directive_normalizer';\r\nimport { DirectiveResolver } from './directive_resolver';\r\nimport { HtmlParser } from './ml_parser/html_parser';\r\nimport { NgModuleResolver } from './ng_module_resolver';\r\nimport { PipeResolver } from './pipe_resolver';\r\nimport { ElementSchemaRegistry } from './schema/element_schema_registry';\r\nimport { SummaryResolver } from './summary_resolver';\r\nimport { Console, SyncAsync } from './util';\r\nexport declare type ErrorCollector = (error: any, type?: any) => void;\r\nexport declare const ERROR_COMPONENT_TYPE = \"ngComponentType\";\r\nexport declare class CompileMetadataResolver {\r\n    private _config;\r\n    private _htmlParser;\r\n    private _ngModuleResolver;\r\n    private _directiveResolver;\r\n    private _pipeResolver;\r\n    private _summaryResolver;\r\n    private _schemaRegistry;\r\n    private _directiveNormalizer;\r\n    private _console;\r\n    private _staticSymbolCache;\r\n    private _reflector;\r\n    private _errorCollector?;\r\n    private _nonNormalizedDirectiveCache;\r\n    private _directiveCache;\r\n    private _summaryCache;\r\n    private _pipeCache;\r\n    private _ngModuleCache;\r\n    private _ngModuleOfTypes;\r\n    private _shallowModuleCache;\r\n    constructor(_config: CompilerConfig, _htmlParser: HtmlParser, _ngModuleResolver: NgModuleResolver, _directiveResolver: DirectiveResolver, _pipeResolver: PipeResolver, _summaryResolver: SummaryResolver<any>, _schemaRegistry: ElementSchemaRegistry, _directiveNormalizer: DirectiveNormalizer, _console: Console, _staticSymbolCache: StaticSymbolCache, _reflector: CompileReflector, _errorCollector?: ErrorCollector);\r\n    getReflector(): CompileReflector;\r\n    clearCacheFor(type: Type): void;\r\n    clearCache(): void;\r\n    private _createProxyClass;\r\n    private getGeneratedClass;\r\n    private getComponentViewClass;\r\n    getHostComponentViewClass(dirType: any): StaticSymbol | cpl.ProxyClass;\r\n    getHostComponentType(dirType: any): StaticSymbol | cpl.ProxyClass;\r\n    private getRendererType;\r\n    private getComponentFactory;\r\n    private initComponentFactory;\r\n    private _loadSummary;\r\n    getHostComponentMetadata(compMeta: cpl.CompileDirectiveMetadata, hostViewType?: StaticSymbol | cpl.ProxyClass): cpl.CompileDirectiveMetadata;\r\n    loadDirectiveMetadata(ngModuleType: any, directiveType: any, isSync: boolean): SyncAsync<null>;\r\n    getNonNormalizedDirectiveMetadata(directiveType: any): {\r\n        annotation: Directive;\r\n        metadata: cpl.CompileDirectiveMetadata;\r\n    } | null;\r\n    /**\r\n     * Gets the metadata for the given directive.\r\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\r\n     */\r\n    getDirectiveMetadata(directiveType: any): cpl.CompileDirectiveMetadata;\r\n    getDirectiveSummary(dirType: any): cpl.CompileDirectiveSummary;\r\n    isDirective(type: any): boolean;\r\n    isPipe(type: any): boolean;\r\n    isNgModule(type: any): boolean;\r\n    getNgModuleSummary(moduleType: any, alreadyCollecting?: Set<any> | null): cpl.CompileNgModuleSummary | null;\r\n    /**\r\n     * Loads the declared directives and pipes of an NgModule.\r\n     */\r\n    loadNgModuleDirectiveAndPipeMetadata(moduleType: any, isSync: boolean, throwIfNotFound?: boolean): Promise<any>;\r\n    getShallowModuleMetadata(moduleType: any): cpl.CompileShallowModuleMetadata | null;\r\n    getNgModuleMetadata(moduleType: any, throwIfNotFound?: boolean, alreadyCollecting?: Set<any> | null): cpl.CompileNgModuleMetadata | null;\r\n    private _checkSelfImport;\r\n    private _getTypeDescriptor;\r\n    private _addTypeToModule;\r\n    private _getTransitiveNgModuleMetadata;\r\n    private _getIdentifierMetadata;\r\n    isInjectable(type: any): boolean;\r\n    getInjectableSummary(type: any): cpl.CompileTypeSummary;\r\n    getInjectableMetadata(type: any, dependencies?: any[] | null, throwOnUnknownDeps?: boolean): cpl.CompileInjectableMetadata | null;\r\n    private _getTypeMetadata;\r\n    private _getFactoryMetadata;\r\n    /**\r\n     * Gets the metadata for the given pipe.\r\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\r\n     */\r\n    getPipeMetadata(pipeType: any): cpl.CompilePipeMetadata | null;\r\n    getPipeSummary(pipeType: any): cpl.CompilePipeSummary;\r\n    getOrLoadPipeMetadata(pipeType: any): cpl.CompilePipeMetadata;\r\n    private _loadPipeMetadata;\r\n    private _getDependenciesMetadata;\r\n    private _getTokenMetadata;\r\n    private _getProvidersMetadata;\r\n    private _validateProvider;\r\n    private _getEntryComponentsFromProvider;\r\n    private _getEntryComponentMetadata;\r\n    private _getInjectableTypeMetadata;\r\n    getProviderMetadata(provider: cpl.ProviderMeta): cpl.CompileProviderMetadata;\r\n    private _getQueriesMetadata;\r\n    private _queryVarBindings;\r\n    private _getQueryMetadata;\r\n    private _reportError;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/ml_parser/ast.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { AstPath } from '../ast_path';\r\nimport { ParseSourceSpan } from '../parse_util';\r\nexport interface Node {\r\n    sourceSpan: ParseSourceSpan;\r\n    visit(visitor: Visitor, context: any): any;\r\n}\r\nexport declare class Text implements Node {\r\n    value: string;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(value: string, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: Visitor, context: any): any;\r\n}\r\nexport declare class Expansion implements Node {\r\n    switchValue: string;\r\n    type: string;\r\n    cases: ExpansionCase[];\r\n    sourceSpan: ParseSourceSpan;\r\n    switchValueSourceSpan: ParseSourceSpan;\r\n    constructor(switchValue: string, type: string, cases: ExpansionCase[], sourceSpan: ParseSourceSpan, switchValueSourceSpan: ParseSourceSpan);\r\n    visit(visitor: Visitor, context: any): any;\r\n}\r\nexport declare class ExpansionCase implements Node {\r\n    value: string;\r\n    expression: Node[];\r\n    sourceSpan: ParseSourceSpan;\r\n    valueSourceSpan: ParseSourceSpan;\r\n    expSourceSpan: ParseSourceSpan;\r\n    constructor(value: string, expression: Node[], sourceSpan: ParseSourceSpan, valueSourceSpan: ParseSourceSpan, expSourceSpan: ParseSourceSpan);\r\n    visit(visitor: Visitor, context: any): any;\r\n}\r\nexport declare class Attribute implements Node {\r\n    name: string;\r\n    value: string;\r\n    sourceSpan: ParseSourceSpan;\r\n    valueSpan?: ParseSourceSpan;\r\n    constructor(name: string, value: string, sourceSpan: ParseSourceSpan, valueSpan?: ParseSourceSpan);\r\n    visit(visitor: Visitor, context: any): any;\r\n}\r\nexport declare class Element implements Node {\r\n    name: string;\r\n    attrs: Attribute[];\r\n    children: Node[];\r\n    sourceSpan: ParseSourceSpan;\r\n    startSourceSpan: ParseSourceSpan | null;\r\n    endSourceSpan: ParseSourceSpan | null;\r\n    constructor(name: string, attrs: Attribute[], children: Node[], sourceSpan: ParseSourceSpan, startSourceSpan?: ParseSourceSpan | null, endSourceSpan?: ParseSourceSpan | null);\r\n    visit(visitor: Visitor, context: any): any;\r\n}\r\nexport declare class Comment implements Node {\r\n    value: string | null;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(value: string | null, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: Visitor, context: any): any;\r\n}\r\nexport interface Visitor {\r\n    visit?(node: Node, context: any): any;\r\n    visitElement(element: Element, context: any): any;\r\n    visitAttribute(attribute: Attribute, context: any): any;\r\n    visitText(text: Text, context: any): any;\r\n    visitComment(comment: Comment, context: any): any;\r\n    visitExpansion(expansion: Expansion, context: any): any;\r\n    visitExpansionCase(expansionCase: ExpansionCase, context: any): any;\r\n}\r\nexport declare function visitAll(visitor: Visitor, nodes: Node[], context?: any): any[];\r\nexport declare class RecursiveVisitor implements Visitor {\r\n    constructor();\r\n    visitElement(ast: Element, context: any): any;\r\n    visitAttribute(ast: Attribute, context: any): any;\r\n    visitText(ast: Text, context: any): any;\r\n    visitComment(ast: Comment, context: any): any;\r\n    visitExpansion(ast: Expansion, context: any): any;\r\n    visitExpansionCase(ast: ExpansionCase, context: any): any;\r\n    private visitChildren;\r\n}\r\nexport declare type HtmlAstPath = AstPath<Node>;\r\nexport declare function findNode(nodes: Node[], position: number): HtmlAstPath;\r\n",
  "/node_modules/@angular/compiler/src/ml_parser/html_parser.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { InterpolationConfig } from './interpolation_config';\r\nimport { ParseTreeResult, Parser } from './parser';\r\nexport { ParseTreeResult, TreeError } from './parser';\r\nexport declare class HtmlParser extends Parser {\r\n    constructor();\r\n    parse(source: string, url: string, parseExpansionForms?: boolean, interpolationConfig?: InterpolationConfig): ParseTreeResult;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/ml_parser/html_tags.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { TagContentType, TagDefinition } from './tags';\r\nexport declare class HtmlTagDefinition implements TagDefinition {\r\n    private closedByChildren;\r\n    closedByParent: boolean;\r\n    requiredParents: {\r\n        [key: string]: boolean;\r\n    };\r\n    parentToAdd: string;\r\n    implicitNamespacePrefix: string | null;\r\n    contentType: TagContentType;\r\n    isVoid: boolean;\r\n    ignoreFirstLf: boolean;\r\n    canSelfClose: boolean;\r\n    constructor({ closedByChildren, requiredParents, implicitNamespacePrefix, contentType, closedByParent, isVoid, ignoreFirstLf }?: {\r\n        closedByChildren?: string[];\r\n        closedByParent?: boolean;\r\n        requiredParents?: string[];\r\n        implicitNamespacePrefix?: string;\r\n        contentType?: TagContentType;\r\n        isVoid?: boolean;\r\n        ignoreFirstLf?: boolean;\r\n    });\r\n    requireExtraParent(currentParent: string): boolean;\r\n    isClosedByChild(name: string): boolean;\r\n}\r\nexport declare function getHtmlTagDefinition(tagName: string): HtmlTagDefinition;\r\n",
  "/node_modules/@angular/compiler/src/ml_parser/html_whitespaces.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as html from './ast';\r\nimport { ParseTreeResult } from './parser';\r\nexport declare const PRESERVE_WS_ATTR_NAME = \"ngPreserveWhitespaces\";\r\n/**\r\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\r\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\r\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\r\n * and later on replaced by a space. We are re-implementing the same idea here.\r\n */\r\nexport declare function replaceNgsp(value: string): string;\r\n/**\r\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\r\n * - consider spaces, tabs and new lines as whitespace characters;\r\n * - drop text nodes consisting of whitespace characters only;\r\n * - for all other text nodes replace consecutive whitespace characters with one space;\r\n * - convert &ngsp; pseudo-entity to a single space;\r\n *\r\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\r\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\r\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\r\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\r\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\r\n * and might be changed to \"on\" by default.\r\n */\r\nexport declare class WhitespaceVisitor implements html.Visitor {\r\n    visitElement(element: html.Element, context: any): any;\r\n    visitAttribute(attribute: html.Attribute, context: any): any;\r\n    visitText(text: html.Text, context: any): any;\r\n    visitComment(comment: html.Comment, context: any): any;\r\n    visitExpansion(expansion: html.Expansion, context: any): any;\r\n    visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any;\r\n}\r\nexport declare function removeWhitespaces(htmlAstWithErrors: ParseTreeResult): ParseTreeResult;\r\n",
  "/node_modules/@angular/compiler/src/ml_parser/icu_ast_expander.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ParseError, ParseSourceSpan } from '../parse_util';\r\nimport * as html from './ast';\r\n/**\r\n * Expands special forms into elements.\r\n *\r\n * For example,\r\n *\r\n * ```\r\n * { messages.length, plural,\r\n *   =0 {zero}\r\n *   =1 {one}\r\n *   other {more than one}\r\n * }\r\n * ```\r\n *\r\n * will be expanded into\r\n *\r\n * ```\r\n * <ng-container [ngPlural]=\"messages.length\">\r\n *   <ng-template ngPluralCase=\"=0\">zero</ng-template>\r\n *   <ng-template ngPluralCase=\"=1\">one</ng-template>\r\n *   <ng-template ngPluralCase=\"other\">more than one</ng-template>\r\n * </ng-container>\r\n * ```\r\n */\r\nexport declare function expandNodes(nodes: html.Node[]): ExpansionResult;\r\nexport declare class ExpansionResult {\r\n    nodes: html.Node[];\r\n    expanded: boolean;\r\n    errors: ParseError[];\r\n    constructor(nodes: html.Node[], expanded: boolean, errors: ParseError[]);\r\n}\r\nexport declare class ExpansionError extends ParseError {\r\n    constructor(span: ParseSourceSpan, errorMsg: string);\r\n}\r\n",
  "/node_modules/@angular/compiler/src/ml_parser/interpolation_config.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare class InterpolationConfig {\r\n    start: string;\r\n    end: string;\r\n    static fromArray(markers: [string, string] | null): InterpolationConfig;\r\n    constructor(start: string, end: string);\r\n}\r\nexport declare const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig;\r\n",
  "/node_modules/@angular/compiler/src/ml_parser/lexer.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ParseError, ParseSourceSpan } from '../parse_util';\r\nimport { InterpolationConfig } from './interpolation_config';\r\nimport { TagDefinition } from './tags';\r\nexport declare enum TokenType {\r\n    TAG_OPEN_START = 0,\r\n    TAG_OPEN_END = 1,\r\n    TAG_OPEN_END_VOID = 2,\r\n    TAG_CLOSE = 3,\r\n    TEXT = 4,\r\n    ESCAPABLE_RAW_TEXT = 5,\r\n    RAW_TEXT = 6,\r\n    COMMENT_START = 7,\r\n    COMMENT_END = 8,\r\n    CDATA_START = 9,\r\n    CDATA_END = 10,\r\n    ATTR_NAME = 11,\r\n    ATTR_VALUE = 12,\r\n    DOC_TYPE = 13,\r\n    EXPANSION_FORM_START = 14,\r\n    EXPANSION_CASE_VALUE = 15,\r\n    EXPANSION_CASE_EXP_START = 16,\r\n    EXPANSION_CASE_EXP_END = 17,\r\n    EXPANSION_FORM_END = 18,\r\n    EOF = 19\r\n}\r\nexport declare class Token {\r\n    type: TokenType;\r\n    parts: string[];\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(type: TokenType, parts: string[], sourceSpan: ParseSourceSpan);\r\n}\r\nexport declare class TokenError extends ParseError {\r\n    tokenType: TokenType;\r\n    constructor(errorMsg: string, tokenType: TokenType, span: ParseSourceSpan);\r\n}\r\nexport declare class TokenizeResult {\r\n    tokens: Token[];\r\n    errors: TokenError[];\r\n    constructor(tokens: Token[], errors: TokenError[]);\r\n}\r\nexport declare function tokenize(source: string, url: string, getTagDefinition: (tagName: string) => TagDefinition, tokenizeExpansionForms?: boolean, interpolationConfig?: InterpolationConfig): TokenizeResult;\r\n",
  "/node_modules/@angular/compiler/src/ml_parser/parser.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ParseError, ParseSourceSpan } from '../parse_util';\r\nimport * as html from './ast';\r\nimport { InterpolationConfig } from './interpolation_config';\r\nimport { TagDefinition } from './tags';\r\nexport declare class TreeError extends ParseError {\r\n    elementName: string | null;\r\n    static create(elementName: string | null, span: ParseSourceSpan, msg: string): TreeError;\r\n    constructor(elementName: string | null, span: ParseSourceSpan, msg: string);\r\n}\r\nexport declare class ParseTreeResult {\r\n    rootNodes: html.Node[];\r\n    errors: ParseError[];\r\n    constructor(rootNodes: html.Node[], errors: ParseError[]);\r\n}\r\nexport declare class Parser {\r\n    getTagDefinition: (tagName: string) => TagDefinition;\r\n    constructor(getTagDefinition: (tagName: string) => TagDefinition);\r\n    parse(source: string, url: string, parseExpansionForms?: boolean, interpolationConfig?: InterpolationConfig): ParseTreeResult;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/ml_parser/tags.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare enum TagContentType {\r\n    RAW_TEXT = 0,\r\n    ESCAPABLE_RAW_TEXT = 1,\r\n    PARSABLE_DATA = 2\r\n}\r\nexport interface TagDefinition {\r\n    closedByParent: boolean;\r\n    requiredParents: {\r\n        [key: string]: boolean;\r\n    };\r\n    parentToAdd: string;\r\n    implicitNamespacePrefix: string | null;\r\n    contentType: TagContentType;\r\n    isVoid: boolean;\r\n    ignoreFirstLf: boolean;\r\n    canSelfClose: boolean;\r\n    requireExtraParent(currentParent: string): boolean;\r\n    isClosedByChild(name: string): boolean;\r\n}\r\nexport declare function splitNsName(elementName: string): [string | null, string];\r\nexport declare function isNgContainer(tagName: string): boolean;\r\nexport declare function isNgContent(tagName: string): boolean;\r\nexport declare function isNgTemplate(tagName: string): boolean;\r\nexport declare function getNsPrefix(fullName: string): string;\r\nexport declare function getNsPrefix(fullName: null): null;\r\nexport declare function mergeNsAndName(prefix: string, localName: string): string;\r\nexport declare const NAMED_ENTITIES: {\r\n    [k: string]: string;\r\n};\r\nexport declare const NGSP_UNICODE = \"\\uE500\";\r\n",
  "/node_modules/@angular/compiler/src/ml_parser/xml_parser.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ParseTreeResult, Parser } from './parser';\r\nexport { ParseTreeResult, TreeError } from './parser';\r\nexport declare class XmlParser extends Parser {\r\n    constructor();\r\n    parse(source: string, url: string, parseExpansionForms?: boolean): ParseTreeResult;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/ml_parser/xml_tags.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { TagContentType, TagDefinition } from './tags';\r\nexport declare class XmlTagDefinition implements TagDefinition {\r\n    closedByParent: boolean;\r\n    requiredParents: {\r\n        [key: string]: boolean;\r\n    };\r\n    parentToAdd: string;\r\n    implicitNamespacePrefix: string;\r\n    contentType: TagContentType;\r\n    isVoid: boolean;\r\n    ignoreFirstLf: boolean;\r\n    canSelfClose: boolean;\r\n    requireExtraParent(currentParent: string): boolean;\r\n    isClosedByChild(name: string): boolean;\r\n}\r\nexport declare function getXmlTagDefinition(tagName: string): XmlTagDefinition;\r\n",
  "/node_modules/@angular/compiler/src/ng_module_compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileNgModuleMetadata, CompileProviderMetadata } from './compile_metadata';\r\nimport { CompileReflector } from './compile_reflector';\r\nimport { OutputContext } from './util';\r\nexport declare class NgModuleCompileResult {\r\n    ngModuleFactoryVar: string;\r\n    constructor(ngModuleFactoryVar: string);\r\n}\r\nexport declare class NgModuleCompiler {\r\n    private reflector;\r\n    constructor(reflector: CompileReflector);\r\n    compile(ctx: OutputContext, ngModuleMeta: CompileNgModuleMetadata, extraProviders: CompileProviderMetadata[]): NgModuleCompileResult;\r\n    createStub(ctx: OutputContext, ngModuleReference: any): void;\r\n    private _createNgModuleFactory;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/ng_module_resolver.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileReflector } from './compile_reflector';\r\nimport { NgModule, Type } from './core';\r\n/**\r\n * Resolves types to {@link NgModule}.\r\n */\r\nexport declare class NgModuleResolver {\r\n    private _reflector;\r\n    constructor(_reflector: CompileReflector);\r\n    isNgModule(type: any): boolean;\r\n    resolve(type: Type, throwIfNotFound?: boolean): NgModule | null;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/output/abstract_emitter.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ParseSourceSpan } from '../parse_util';\r\nimport * as o from './output_ast';\r\nimport { SourceMapGenerator } from './source_map';\r\nexport declare const CATCH_ERROR_VAR: o.ReadVarExpr;\r\nexport declare const CATCH_STACK_VAR: o.ReadVarExpr;\r\nexport interface OutputEmitter {\r\n    emitStatements(genFilePath: string, stmts: o.Statement[], preamble?: string | null): string;\r\n}\r\nexport declare class EmitterVisitorContext {\r\n    private _indent;\r\n    static createRoot(): EmitterVisitorContext;\r\n    private _lines;\r\n    private _classes;\r\n    private _preambleLineCount;\r\n    constructor(_indent: number);\r\n    private readonly _currentLine;\r\n    println(from?: {\r\n        sourceSpan: ParseSourceSpan | null;\r\n    } | null, lastPart?: string): void;\r\n    lineIsEmpty(): boolean;\r\n    lineLength(): number;\r\n    print(from: {\r\n        sourceSpan: ParseSourceSpan | null;\r\n    } | null, part: string, newLine?: boolean): void;\r\n    removeEmptyLastLine(): void;\r\n    incIndent(): void;\r\n    decIndent(): void;\r\n    pushClass(clazz: o.ClassStmt): void;\r\n    popClass(): o.ClassStmt;\r\n    readonly currentClass: o.ClassStmt | null;\r\n    toSource(): string;\r\n    toSourceMapGenerator(genFilePath: string, startsAtLine?: number): SourceMapGenerator;\r\n    setPreambleLineCount(count: number): number;\r\n    spanOf(line: number, column: number): ParseSourceSpan | null;\r\n    private readonly sourceLines;\r\n}\r\nexport declare abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {\r\n    private _escapeDollarInStrings;\r\n    constructor(_escapeDollarInStrings: boolean);\r\n    visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any;\r\n    visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any;\r\n    abstract visitCastExpr(ast: o.CastExpr, context: any): any;\r\n    abstract visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any;\r\n    visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any;\r\n    abstract visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any;\r\n    visitThrowStmt(stmt: o.ThrowStmt, ctx: EmitterVisitorContext): any;\r\n    visitCommentStmt(stmt: o.CommentStmt, ctx: EmitterVisitorContext): any;\r\n    visitJSDocCommentStmt(stmt: o.JSDocCommentStmt, ctx: EmitterVisitorContext): any;\r\n    abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\r\n    visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any;\r\n    visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any;\r\n    visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any;\r\n    visitInvokeMethodExpr(expr: o.InvokeMethodExpr, ctx: EmitterVisitorContext): any;\r\n    abstract getBuiltinMethodName(method: o.BuiltinMethod): string;\r\n    visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any;\r\n    visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any;\r\n    visitTypeofExpr(expr: o.TypeofExpr, ctx: EmitterVisitorContext): any;\r\n    visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any;\r\n    visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any;\r\n    visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any;\r\n    abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;\r\n    visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any;\r\n    visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any;\r\n    visitAssertNotNullExpr(ast: o.AssertNotNull, ctx: EmitterVisitorContext): any;\r\n    abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;\r\n    abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;\r\n    visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any;\r\n    visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any;\r\n    visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any;\r\n    visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any;\r\n    visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any;\r\n    visitCommaExpr(ast: o.CommaExpr, ctx: EmitterVisitorContext): any;\r\n    visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string): void;\r\n    visitAllObjects<T>(handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext, separator: string): void;\r\n    visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void;\r\n}\r\nexport declare function escapeIdentifier(input: string, escapeDollar: boolean, alwaysQuote?: boolean): any;\r\n",
  "/node_modules/@angular/compiler/src/output/abstract_js_emitter.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { AbstractEmitterVisitor, EmitterVisitorContext } from './abstract_emitter';\r\nimport * as o from './output_ast';\r\nexport declare abstract class AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\r\n    constructor();\r\n    visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any;\r\n    private _visitClassConstructor;\r\n    private _visitClassGetter;\r\n    private _visitClassMethod;\r\n    visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any;\r\n    visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): string | null;\r\n    visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\r\n    visitCastExpr(ast: o.CastExpr, ctx: EmitterVisitorContext): any;\r\n    visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): string | null;\r\n    visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;\r\n    visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any;\r\n    visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any;\r\n    private _visitParams;\r\n    getBuiltinMethodName(method: o.BuiltinMethod): string;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/output/js_emitter.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { OutputEmitter } from './abstract_emitter';\r\nimport * as o from './output_ast';\r\nexport declare class JavaScriptEmitter implements OutputEmitter {\r\n    emitStatements(genFilePath: string, stmts: o.Statement[], preamble?: string): string;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/output/map_util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as o from './output_ast';\r\nexport declare type MapEntry = {\r\n    key: string;\r\n    quoted: boolean;\r\n    value: o.Expression;\r\n};\r\nexport declare type MapLiteral = MapEntry[];\r\nexport declare function mapEntry(key: string, value: o.Expression): MapEntry;\r\nexport declare function mapLiteral(obj: {\r\n    [key: string]: o.Expression;\r\n}): o.Expression;\r\n",
  "/node_modules/@angular/compiler/src/output/output_ast.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ParseSourceSpan } from '../parse_util';\r\nexport declare enum TypeModifier {\r\n    Const = 0\r\n}\r\nexport declare abstract class Type {\r\n    modifiers: TypeModifier[] | null;\r\n    constructor(modifiers?: TypeModifier[] | null);\r\n    abstract visitType(visitor: TypeVisitor, context: any): any;\r\n    hasModifier(modifier: TypeModifier): boolean;\r\n}\r\nexport declare enum BuiltinTypeName {\r\n    Dynamic = 0,\r\n    Bool = 1,\r\n    String = 2,\r\n    Int = 3,\r\n    Number = 4,\r\n    Function = 5,\r\n    Inferred = 6,\r\n    None = 7\r\n}\r\nexport declare class BuiltinType extends Type {\r\n    name: BuiltinTypeName;\r\n    constructor(name: BuiltinTypeName, modifiers?: TypeModifier[] | null);\r\n    visitType(visitor: TypeVisitor, context: any): any;\r\n}\r\nexport declare class ExpressionType extends Type {\r\n    value: Expression;\r\n    typeParams: Type[] | null;\r\n    constructor(value: Expression, modifiers?: TypeModifier[] | null, typeParams?: Type[] | null);\r\n    visitType(visitor: TypeVisitor, context: any): any;\r\n}\r\nexport declare class ArrayType extends Type {\r\n    of: Type;\r\n    constructor(of: Type, modifiers?: TypeModifier[] | null);\r\n    visitType(visitor: TypeVisitor, context: any): any;\r\n}\r\nexport declare class MapType extends Type {\r\n    valueType: Type | null;\r\n    constructor(valueType: Type | null | undefined, modifiers?: TypeModifier[] | null);\r\n    visitType(visitor: TypeVisitor, context: any): any;\r\n}\r\nexport declare const DYNAMIC_TYPE: BuiltinType;\r\nexport declare const INFERRED_TYPE: BuiltinType;\r\nexport declare const BOOL_TYPE: BuiltinType;\r\nexport declare const INT_TYPE: BuiltinType;\r\nexport declare const NUMBER_TYPE: BuiltinType;\r\nexport declare const STRING_TYPE: BuiltinType;\r\nexport declare const FUNCTION_TYPE: BuiltinType;\r\nexport declare const NONE_TYPE: BuiltinType;\r\nexport interface TypeVisitor {\r\n    visitBuiltinType(type: BuiltinType, context: any): any;\r\n    visitExpressionType(type: ExpressionType, context: any): any;\r\n    visitArrayType(type: ArrayType, context: any): any;\r\n    visitMapType(type: MapType, context: any): any;\r\n}\r\nexport declare enum BinaryOperator {\r\n    Equals = 0,\r\n    NotEquals = 1,\r\n    Identical = 2,\r\n    NotIdentical = 3,\r\n    Minus = 4,\r\n    Plus = 5,\r\n    Divide = 6,\r\n    Multiply = 7,\r\n    Modulo = 8,\r\n    And = 9,\r\n    Or = 10,\r\n    BitwiseAnd = 11,\r\n    Lower = 12,\r\n    LowerEquals = 13,\r\n    Bigger = 14,\r\n    BiggerEquals = 15\r\n}\r\nexport declare function nullSafeIsEquivalent<T extends {\r\n    isEquivalent(other: T): boolean;\r\n}>(base: T | null, other: T | null): boolean;\r\nexport declare function areAllEquivalent<T extends {\r\n    isEquivalent(other: T): boolean;\r\n}>(base: T[], other: T[]): boolean;\r\nexport declare abstract class Expression {\r\n    type: Type | null;\r\n    sourceSpan: ParseSourceSpan | null;\r\n    constructor(type: Type | null | undefined, sourceSpan?: ParseSourceSpan | null);\r\n    abstract visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n    /**\r\n     * Calculates whether this expression produces the same value as the given expression.\r\n     * Note: We don't check Types nor ParseSourceSpans nor function arguments.\r\n     */\r\n    abstract isEquivalent(e: Expression): boolean;\r\n    /**\r\n     * Return true if the expression is constant.\r\n     */\r\n    abstract isConstant(): boolean;\r\n    prop(name: string, sourceSpan?: ParseSourceSpan | null): ReadPropExpr;\r\n    key(index: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null): ReadKeyExpr;\r\n    callMethod(name: string | BuiltinMethod, params: Expression[], sourceSpan?: ParseSourceSpan | null): InvokeMethodExpr;\r\n    callFn(params: Expression[], sourceSpan?: ParseSourceSpan | null): InvokeFunctionExpr;\r\n    instantiate(params: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null): InstantiateExpr;\r\n    conditional(trueCase: Expression, falseCase?: Expression | null, sourceSpan?: ParseSourceSpan | null): ConditionalExpr;\r\n    equals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    notEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    identical(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    notIdentical(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    minus(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    plus(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    divide(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    multiply(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    modulo(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    and(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    bitwiseAnd(rhs: Expression, sourceSpan?: ParseSourceSpan | null, parens?: boolean): BinaryOperatorExpr;\r\n    or(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    lower(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    lowerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    bigger(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    biggerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;\r\n    isBlank(sourceSpan?: ParseSourceSpan | null): Expression;\r\n    cast(type: Type, sourceSpan?: ParseSourceSpan | null): Expression;\r\n    toStmt(): Statement;\r\n}\r\nexport declare enum BuiltinVar {\r\n    This = 0,\r\n    Super = 1,\r\n    CatchError = 2,\r\n    CatchStack = 3\r\n}\r\nexport declare class ReadVarExpr extends Expression {\r\n    name: string | null;\r\n    builtin: BuiltinVar | null;\r\n    constructor(name: string | BuiltinVar, type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n    set(value: Expression): WriteVarExpr;\r\n}\r\nexport declare class TypeofExpr extends Expression {\r\n    expr: Expression;\r\n    constructor(expr: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n}\r\nexport declare class WrappedNodeExpr<T> extends Expression {\r\n    node: T;\r\n    constructor(node: T, type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class WriteVarExpr extends Expression {\r\n    name: string;\r\n    value: Expression;\r\n    constructor(name: string, value: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n    toDeclStmt(type?: Type | null, modifiers?: StmtModifier[] | null): DeclareVarStmt;\r\n    toConstDecl(): DeclareVarStmt;\r\n}\r\nexport declare class WriteKeyExpr extends Expression {\r\n    receiver: Expression;\r\n    index: Expression;\r\n    value: Expression;\r\n    constructor(receiver: Expression, index: Expression, value: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class WritePropExpr extends Expression {\r\n    receiver: Expression;\r\n    name: string;\r\n    value: Expression;\r\n    constructor(receiver: Expression, name: string, value: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare enum BuiltinMethod {\r\n    ConcatArray = 0,\r\n    SubscribeObservable = 1,\r\n    Bind = 2\r\n}\r\nexport declare class InvokeMethodExpr extends Expression {\r\n    receiver: Expression;\r\n    args: Expression[];\r\n    name: string | null;\r\n    builtin: BuiltinMethod | null;\r\n    constructor(receiver: Expression, method: string | BuiltinMethod, args: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class InvokeFunctionExpr extends Expression {\r\n    fn: Expression;\r\n    args: Expression[];\r\n    constructor(fn: Expression, args: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class InstantiateExpr extends Expression {\r\n    classExpr: Expression;\r\n    args: Expression[];\r\n    constructor(classExpr: Expression, args: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class LiteralExpr extends Expression {\r\n    value: number | string | boolean | null | undefined;\r\n    constructor(value: number | string | boolean | null | undefined, type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class ExternalExpr extends Expression {\r\n    value: ExternalReference;\r\n    typeParams: Type[] | null;\r\n    constructor(value: ExternalReference, type?: Type | null, typeParams?: Type[] | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class ExternalReference {\r\n    moduleName: string | null;\r\n    name: string | null;\r\n    runtime?: any | null;\r\n    constructor(moduleName: string | null, name: string | null, runtime?: any | null);\r\n}\r\nexport declare class ConditionalExpr extends Expression {\r\n    condition: Expression;\r\n    falseCase: Expression | null;\r\n    trueCase: Expression;\r\n    constructor(condition: Expression, trueCase: Expression, falseCase?: Expression | null, type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class NotExpr extends Expression {\r\n    condition: Expression;\r\n    constructor(condition: Expression, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class AssertNotNull extends Expression {\r\n    condition: Expression;\r\n    constructor(condition: Expression, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class CastExpr extends Expression {\r\n    value: Expression;\r\n    constructor(value: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class FnParam {\r\n    name: string;\r\n    type: Type | null;\r\n    constructor(name: string, type?: Type | null);\r\n    isEquivalent(param: FnParam): boolean;\r\n}\r\nexport declare class FunctionExpr extends Expression {\r\n    params: FnParam[];\r\n    statements: Statement[];\r\n    name?: string | null;\r\n    constructor(params: FnParam[], statements: Statement[], type?: Type | null, sourceSpan?: ParseSourceSpan | null, name?: string | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n    toDeclStmt(name: string, modifiers?: StmtModifier[] | null): DeclareFunctionStmt;\r\n}\r\nexport declare class BinaryOperatorExpr extends Expression {\r\n    operator: BinaryOperator;\r\n    rhs: Expression;\r\n    parens: boolean;\r\n    lhs: Expression;\r\n    constructor(operator: BinaryOperator, lhs: Expression, rhs: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null, parens?: boolean);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class ReadPropExpr extends Expression {\r\n    receiver: Expression;\r\n    name: string;\r\n    constructor(receiver: Expression, name: string, type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n    set(value: Expression): WritePropExpr;\r\n}\r\nexport declare class ReadKeyExpr extends Expression {\r\n    receiver: Expression;\r\n    index: Expression;\r\n    constructor(receiver: Expression, index: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n    set(value: Expression): WriteKeyExpr;\r\n}\r\nexport declare class LiteralArrayExpr extends Expression {\r\n    entries: Expression[];\r\n    constructor(entries: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null);\r\n    isConstant(): boolean;\r\n    isEquivalent(e: Expression): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class LiteralMapEntry {\r\n    key: string;\r\n    value: Expression;\r\n    quoted: boolean;\r\n    constructor(key: string, value: Expression, quoted: boolean);\r\n    isEquivalent(e: LiteralMapEntry): boolean;\r\n}\r\nexport declare class LiteralMapExpr extends Expression {\r\n    entries: LiteralMapEntry[];\r\n    valueType: Type | null;\r\n    constructor(entries: LiteralMapEntry[], type?: MapType | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport declare class CommaExpr extends Expression {\r\n    parts: Expression[];\r\n    constructor(parts: Expression[], sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(e: Expression): boolean;\r\n    isConstant(): boolean;\r\n    visitExpression(visitor: ExpressionVisitor, context: any): any;\r\n}\r\nexport interface ExpressionVisitor {\r\n    visitReadVarExpr(ast: ReadVarExpr, context: any): any;\r\n    visitWriteVarExpr(expr: WriteVarExpr, context: any): any;\r\n    visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;\r\n    visitWritePropExpr(expr: WritePropExpr, context: any): any;\r\n    visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;\r\n    visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;\r\n    visitInstantiateExpr(ast: InstantiateExpr, context: any): any;\r\n    visitLiteralExpr(ast: LiteralExpr, context: any): any;\r\n    visitExternalExpr(ast: ExternalExpr, context: any): any;\r\n    visitConditionalExpr(ast: ConditionalExpr, context: any): any;\r\n    visitNotExpr(ast: NotExpr, context: any): any;\r\n    visitAssertNotNullExpr(ast: AssertNotNull, context: any): any;\r\n    visitCastExpr(ast: CastExpr, context: any): any;\r\n    visitFunctionExpr(ast: FunctionExpr, context: any): any;\r\n    visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;\r\n    visitReadPropExpr(ast: ReadPropExpr, context: any): any;\r\n    visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;\r\n    visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;\r\n    visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;\r\n    visitCommaExpr(ast: CommaExpr, context: any): any;\r\n    visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any;\r\n    visitTypeofExpr(ast: TypeofExpr, context: any): any;\r\n}\r\nexport declare const THIS_EXPR: ReadVarExpr;\r\nexport declare const SUPER_EXPR: ReadVarExpr;\r\nexport declare const CATCH_ERROR_VAR: ReadVarExpr;\r\nexport declare const CATCH_STACK_VAR: ReadVarExpr;\r\nexport declare const NULL_EXPR: LiteralExpr;\r\nexport declare const TYPED_NULL_EXPR: LiteralExpr;\r\nexport declare enum StmtModifier {\r\n    Final = 0,\r\n    Private = 1,\r\n    Exported = 2,\r\n    Static = 3\r\n}\r\nexport declare abstract class Statement {\r\n    modifiers: StmtModifier[];\r\n    sourceSpan: ParseSourceSpan | null;\r\n    constructor(modifiers?: StmtModifier[] | null, sourceSpan?: ParseSourceSpan | null);\r\n    /**\r\n     * Calculates whether this statement produces the same value as the given statement.\r\n     * Note: We don't check Types nor ParseSourceSpans nor function arguments.\r\n     */\r\n    abstract isEquivalent(stmt: Statement): boolean;\r\n    abstract visitStatement(visitor: StatementVisitor, context: any): any;\r\n    hasModifier(modifier: StmtModifier): boolean;\r\n}\r\nexport declare class DeclareVarStmt extends Statement {\r\n    name: string;\r\n    value?: Expression;\r\n    type: Type | null;\r\n    constructor(name: string, value?: Expression, type?: Type | null, modifiers?: StmtModifier[] | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(stmt: Statement): boolean;\r\n    visitStatement(visitor: StatementVisitor, context: any): any;\r\n}\r\nexport declare class DeclareFunctionStmt extends Statement {\r\n    name: string;\r\n    params: FnParam[];\r\n    statements: Statement[];\r\n    type: Type | null;\r\n    constructor(name: string, params: FnParam[], statements: Statement[], type?: Type | null, modifiers?: StmtModifier[] | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(stmt: Statement): boolean;\r\n    visitStatement(visitor: StatementVisitor, context: any): any;\r\n}\r\nexport declare class ExpressionStatement extends Statement {\r\n    expr: Expression;\r\n    constructor(expr: Expression, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(stmt: Statement): boolean;\r\n    visitStatement(visitor: StatementVisitor, context: any): any;\r\n}\r\nexport declare class ReturnStatement extends Statement {\r\n    value: Expression;\r\n    constructor(value: Expression, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(stmt: Statement): boolean;\r\n    visitStatement(visitor: StatementVisitor, context: any): any;\r\n}\r\nexport declare class AbstractClassPart {\r\n    modifiers: StmtModifier[] | null;\r\n    type: Type | null;\r\n    constructor(type: Type | null | undefined, modifiers: StmtModifier[] | null);\r\n    hasModifier(modifier: StmtModifier): boolean;\r\n}\r\nexport declare class ClassField extends AbstractClassPart {\r\n    name: string;\r\n    initializer?: Expression;\r\n    constructor(name: string, type?: Type | null, modifiers?: StmtModifier[] | null, initializer?: Expression);\r\n    isEquivalent(f: ClassField): boolean;\r\n}\r\nexport declare class ClassMethod extends AbstractClassPart {\r\n    name: string | null;\r\n    params: FnParam[];\r\n    body: Statement[];\r\n    constructor(name: string | null, params: FnParam[], body: Statement[], type?: Type | null, modifiers?: StmtModifier[] | null);\r\n    isEquivalent(m: ClassMethod): boolean;\r\n}\r\nexport declare class ClassGetter extends AbstractClassPart {\r\n    name: string;\r\n    body: Statement[];\r\n    constructor(name: string, body: Statement[], type?: Type | null, modifiers?: StmtModifier[] | null);\r\n    isEquivalent(m: ClassGetter): boolean;\r\n}\r\nexport declare class ClassStmt extends Statement {\r\n    name: string;\r\n    parent: Expression | null;\r\n    fields: ClassField[];\r\n    getters: ClassGetter[];\r\n    constructorMethod: ClassMethod;\r\n    methods: ClassMethod[];\r\n    constructor(name: string, parent: Expression | null, fields: ClassField[], getters: ClassGetter[], constructorMethod: ClassMethod, methods: ClassMethod[], modifiers?: StmtModifier[] | null, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(stmt: Statement): boolean;\r\n    visitStatement(visitor: StatementVisitor, context: any): any;\r\n}\r\nexport declare class IfStmt extends Statement {\r\n    condition: Expression;\r\n    trueCase: Statement[];\r\n    falseCase: Statement[];\r\n    constructor(condition: Expression, trueCase: Statement[], falseCase?: Statement[], sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(stmt: Statement): boolean;\r\n    visitStatement(visitor: StatementVisitor, context: any): any;\r\n}\r\nexport declare class CommentStmt extends Statement {\r\n    comment: string;\r\n    multiline: boolean;\r\n    constructor(comment: string, multiline?: boolean, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(stmt: Statement): boolean;\r\n    visitStatement(visitor: StatementVisitor, context: any): any;\r\n}\r\nexport declare class JSDocCommentStmt extends Statement {\r\n    tags: JSDocTag[];\r\n    constructor(tags?: JSDocTag[], sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(stmt: Statement): boolean;\r\n    visitStatement(visitor: StatementVisitor, context: any): any;\r\n    toString(): string;\r\n}\r\nexport declare class TryCatchStmt extends Statement {\r\n    bodyStmts: Statement[];\r\n    catchStmts: Statement[];\r\n    constructor(bodyStmts: Statement[], catchStmts: Statement[], sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(stmt: Statement): boolean;\r\n    visitStatement(visitor: StatementVisitor, context: any): any;\r\n}\r\nexport declare class ThrowStmt extends Statement {\r\n    error: Expression;\r\n    constructor(error: Expression, sourceSpan?: ParseSourceSpan | null);\r\n    isEquivalent(stmt: ThrowStmt): boolean;\r\n    visitStatement(visitor: StatementVisitor, context: any): any;\r\n}\r\nexport interface StatementVisitor {\r\n    visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;\r\n    visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;\r\n    visitExpressionStmt(stmt: ExpressionStatement, context: any): any;\r\n    visitReturnStmt(stmt: ReturnStatement, context: any): any;\r\n    visitDeclareClassStmt(stmt: ClassStmt, context: any): any;\r\n    visitIfStmt(stmt: IfStmt, context: any): any;\r\n    visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;\r\n    visitThrowStmt(stmt: ThrowStmt, context: any): any;\r\n    visitCommentStmt(stmt: CommentStmt, context: any): any;\r\n    visitJSDocCommentStmt(stmt: JSDocCommentStmt, context: any): any;\r\n}\r\nexport declare class AstTransformer implements StatementVisitor, ExpressionVisitor {\r\n    transformExpr(expr: Expression, context: any): Expression;\r\n    transformStmt(stmt: Statement, context: any): Statement;\r\n    visitReadVarExpr(ast: ReadVarExpr, context: any): any;\r\n    visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any;\r\n    visitTypeofExpr(expr: TypeofExpr, context: any): any;\r\n    visitWriteVarExpr(expr: WriteVarExpr, context: any): any;\r\n    visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;\r\n    visitWritePropExpr(expr: WritePropExpr, context: any): any;\r\n    visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;\r\n    visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;\r\n    visitInstantiateExpr(ast: InstantiateExpr, context: any): any;\r\n    visitLiteralExpr(ast: LiteralExpr, context: any): any;\r\n    visitExternalExpr(ast: ExternalExpr, context: any): any;\r\n    visitConditionalExpr(ast: ConditionalExpr, context: any): any;\r\n    visitNotExpr(ast: NotExpr, context: any): any;\r\n    visitAssertNotNullExpr(ast: AssertNotNull, context: any): any;\r\n    visitCastExpr(ast: CastExpr, context: any): any;\r\n    visitFunctionExpr(ast: FunctionExpr, context: any): any;\r\n    visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;\r\n    visitReadPropExpr(ast: ReadPropExpr, context: any): any;\r\n    visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;\r\n    visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;\r\n    visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;\r\n    visitCommaExpr(ast: CommaExpr, context: any): any;\r\n    visitAllExpressions(exprs: Expression[], context: any): Expression[];\r\n    visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;\r\n    visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;\r\n    visitExpressionStmt(stmt: ExpressionStatement, context: any): any;\r\n    visitReturnStmt(stmt: ReturnStatement, context: any): any;\r\n    visitDeclareClassStmt(stmt: ClassStmt, context: any): any;\r\n    visitIfStmt(stmt: IfStmt, context: any): any;\r\n    visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;\r\n    visitThrowStmt(stmt: ThrowStmt, context: any): any;\r\n    visitCommentStmt(stmt: CommentStmt, context: any): any;\r\n    visitJSDocCommentStmt(stmt: JSDocCommentStmt, context: any): any;\r\n    visitAllStatements(stmts: Statement[], context: any): Statement[];\r\n}\r\nexport declare class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor {\r\n    visitType(ast: Type, context: any): any;\r\n    visitExpression(ast: Expression, context: any): any;\r\n    visitBuiltinType(type: BuiltinType, context: any): any;\r\n    visitExpressionType(type: ExpressionType, context: any): any;\r\n    visitArrayType(type: ArrayType, context: any): any;\r\n    visitMapType(type: MapType, context: any): any;\r\n    visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any;\r\n    visitTypeofExpr(ast: TypeofExpr, context: any): any;\r\n    visitReadVarExpr(ast: ReadVarExpr, context: any): any;\r\n    visitWriteVarExpr(ast: WriteVarExpr, context: any): any;\r\n    visitWriteKeyExpr(ast: WriteKeyExpr, context: any): any;\r\n    visitWritePropExpr(ast: WritePropExpr, context: any): any;\r\n    visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;\r\n    visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;\r\n    visitInstantiateExpr(ast: InstantiateExpr, context: any): any;\r\n    visitLiteralExpr(ast: LiteralExpr, context: any): any;\r\n    visitExternalExpr(ast: ExternalExpr, context: any): any;\r\n    visitConditionalExpr(ast: ConditionalExpr, context: any): any;\r\n    visitNotExpr(ast: NotExpr, context: any): any;\r\n    visitAssertNotNullExpr(ast: AssertNotNull, context: any): any;\r\n    visitCastExpr(ast: CastExpr, context: any): any;\r\n    visitFunctionExpr(ast: FunctionExpr, context: any): any;\r\n    visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;\r\n    visitReadPropExpr(ast: ReadPropExpr, context: any): any;\r\n    visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;\r\n    visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;\r\n    visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;\r\n    visitCommaExpr(ast: CommaExpr, context: any): any;\r\n    visitAllExpressions(exprs: Expression[], context: any): void;\r\n    visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;\r\n    visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;\r\n    visitExpressionStmt(stmt: ExpressionStatement, context: any): any;\r\n    visitReturnStmt(stmt: ReturnStatement, context: any): any;\r\n    visitDeclareClassStmt(stmt: ClassStmt, context: any): any;\r\n    visitIfStmt(stmt: IfStmt, context: any): any;\r\n    visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;\r\n    visitThrowStmt(stmt: ThrowStmt, context: any): any;\r\n    visitCommentStmt(stmt: CommentStmt, context: any): any;\r\n    visitJSDocCommentStmt(stmt: JSDocCommentStmt, context: any): any;\r\n    visitAllStatements(stmts: Statement[], context: any): void;\r\n}\r\nexport declare function findReadVarNames(stmts: Statement[]): Set<string>;\r\nexport declare function collectExternalReferences(stmts: Statement[]): ExternalReference[];\r\nexport declare function applySourceSpanToStatementIfNeeded(stmt: Statement, sourceSpan: ParseSourceSpan | null): Statement;\r\nexport declare function applySourceSpanToExpressionIfNeeded(expr: Expression, sourceSpan: ParseSourceSpan | null): Expression;\r\nexport declare function variable(name: string, type?: Type | null, sourceSpan?: ParseSourceSpan | null): ReadVarExpr;\r\nexport declare function importExpr(id: ExternalReference, typeParams?: Type[] | null, sourceSpan?: ParseSourceSpan | null): ExternalExpr;\r\nexport declare function importType(id: ExternalReference, typeParams?: Type[] | null, typeModifiers?: TypeModifier[] | null): ExpressionType | null;\r\nexport declare function expressionType(expr: Expression, typeModifiers?: TypeModifier[] | null, typeParams?: Type[] | null): ExpressionType;\r\nexport declare function typeofExpr(expr: Expression): TypeofExpr;\r\nexport declare function literalArr(values: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null): LiteralArrayExpr;\r\nexport declare function literalMap(values: {\r\n    key: string;\r\n    quoted: boolean;\r\n    value: Expression;\r\n}[], type?: MapType | null): LiteralMapExpr;\r\nexport declare function not(expr: Expression, sourceSpan?: ParseSourceSpan | null): NotExpr;\r\nexport declare function assertNotNull(expr: Expression, sourceSpan?: ParseSourceSpan | null): AssertNotNull;\r\nexport declare function fn(params: FnParam[], body: Statement[], type?: Type | null, sourceSpan?: ParseSourceSpan | null, name?: string | null): FunctionExpr;\r\nexport declare function ifStmt(condition: Expression, thenClause: Statement[], elseClause?: Statement[]): IfStmt;\r\nexport declare function literal(value: any, type?: Type | null, sourceSpan?: ParseSourceSpan | null): LiteralExpr;\r\nexport declare function isNull(exp: Expression): boolean;\r\nexport declare const enum JSDocTagName {\r\n    Desc = \"desc\",\r\n    Id = \"id\",\r\n    Meaning = \"meaning\"\r\n}\r\nexport declare type JSDocTag = {\r\n    tagName: JSDocTagName | string;\r\n    text?: string;\r\n} | {\r\n    tagName?: undefined;\r\n    text: string;\r\n};\r\n",
  "/node_modules/@angular/compiler/src/output/output_interpreter.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileReflector } from '../compile_reflector';\r\nimport * as o from './output_ast';\r\nexport declare function interpretStatements(statements: o.Statement[], reflector: CompileReflector): {\r\n    [key: string]: any;\r\n};\r\n",
  "/node_modules/@angular/compiler/src/output/output_jit.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileReflector } from '../compile_reflector';\r\nimport { EmitterVisitorContext } from './abstract_emitter';\r\nimport { AbstractJsEmitterVisitor } from './abstract_js_emitter';\r\nimport * as o from './output_ast';\r\nexport declare function jitStatements(sourceUrl: string, statements: o.Statement[], reflector: CompileReflector, createSourceMaps: boolean): {\r\n    [key: string]: any;\r\n};\r\nexport declare class JitEmitterVisitor extends AbstractJsEmitterVisitor {\r\n    private reflector;\r\n    private _evalArgNames;\r\n    private _evalArgValues;\r\n    private _evalExportedVars;\r\n    constructor(reflector: CompileReflector);\r\n    createReturnStmt(ctx: EmitterVisitorContext): void;\r\n    getArgs(): {\r\n        [key: string]: any;\r\n    };\r\n    visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;\r\n    visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any;\r\n    visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\r\n    visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any;\r\n    visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any;\r\n    private _emitReferenceToExternal;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/output/source_map.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare type SourceMap = {\r\n    version: number;\r\n    file?: string;\r\n    sourceRoot: string;\r\n    sources: string[];\r\n    sourcesContent: (string | null)[];\r\n    mappings: string;\r\n};\r\nexport declare class SourceMapGenerator {\r\n    private file;\r\n    private sourcesContent;\r\n    private lines;\r\n    private lastCol0;\r\n    private hasMappings;\r\n    constructor(file?: string | null);\r\n    addSource(url: string, content?: string | null): this;\r\n    addLine(): this;\r\n    addMapping(col0: number, sourceUrl?: string, sourceLine0?: number, sourceCol0?: number): this;\r\n    private readonly currentLine;\r\n    toJSON(): SourceMap | null;\r\n    toJsComment(): string;\r\n}\r\nexport declare function toBase64String(value: string): string;\r\n",
  "/node_modules/@angular/compiler/src/output/ts_emitter.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { EmitterVisitorContext, OutputEmitter } from './abstract_emitter';\r\nimport * as o from './output_ast';\r\nexport declare function debugOutputAstAsTypeScript(ast: o.Statement | o.Expression | o.Type | any[]): string;\r\nexport declare type ReferenceFilter = (reference: o.ExternalReference) => boolean;\r\nexport declare class TypeScriptEmitter implements OutputEmitter {\r\n    emitStatementsAndContext(genFilePath: string, stmts: o.Statement[], preamble?: string, emitSourceMaps?: boolean, referenceFilter?: ReferenceFilter, importFilter?: ReferenceFilter): {\r\n        sourceText: string;\r\n        context: EmitterVisitorContext;\r\n    };\r\n    emitStatements(genFilePath: string, stmts: o.Statement[], preamble?: string): string;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/output/value_util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { OutputContext } from '../util';\r\nimport * as o from './output_ast';\r\nexport declare const QUOTED_KEYS = \"$quoted$\";\r\nexport declare function convertValueToOutputAst(ctx: OutputContext, value: any, type?: o.Type | null): o.Expression;\r\n",
  "/node_modules/@angular/compiler/src/parse_util.d.ts": "import { CompileIdentifierMetadata } from './compile_metadata';\r\nexport declare class ParseLocation {\r\n    file: ParseSourceFile;\r\n    offset: number;\r\n    line: number;\r\n    col: number;\r\n    constructor(file: ParseSourceFile, offset: number, line: number, col: number);\r\n    toString(): string;\r\n    moveBy(delta: number): ParseLocation;\r\n    getContext(maxChars: number, maxLines: number): {\r\n        before: string;\r\n        after: string;\r\n    } | null;\r\n}\r\nexport declare class ParseSourceFile {\r\n    content: string;\r\n    url: string;\r\n    constructor(content: string, url: string);\r\n}\r\nexport declare class ParseSourceSpan {\r\n    start: ParseLocation;\r\n    end: ParseLocation;\r\n    details: string | null;\r\n    constructor(start: ParseLocation, end: ParseLocation, details?: string | null);\r\n    toString(): string;\r\n}\r\nexport declare enum ParseErrorLevel {\r\n    WARNING = 0,\r\n    ERROR = 1\r\n}\r\nexport declare class ParseError {\r\n    span: ParseSourceSpan;\r\n    msg: string;\r\n    level: ParseErrorLevel;\r\n    constructor(span: ParseSourceSpan, msg: string, level?: ParseErrorLevel);\r\n    contextualMessage(): string;\r\n    toString(): string;\r\n}\r\nexport declare function typeSourceSpan(kind: string, type: CompileIdentifierMetadata): ParseSourceSpan;\r\n",
  "/node_modules/@angular/compiler/src/pipe_resolver.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileReflector } from './compile_reflector';\r\nimport { Pipe, Type } from './core';\r\n/**\r\n * Resolve a `Type` for {@link Pipe}.\r\n *\r\n * This interface can be overridden by the application developer to create custom behavior.\r\n *\r\n * See {@link Compiler}\r\n */\r\nexport declare class PipeResolver {\r\n    private _reflector;\r\n    constructor(_reflector: CompileReflector);\r\n    isPipe(type: Type): boolean;\r\n    /**\r\n     * Return {@link Pipe} for a given `Type`.\r\n     */\r\n    resolve(type: Type, throwIfNotFound?: boolean): Pipe | null;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/provider_analyzer.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileDirectiveMetadata, CompileNgModuleMetadata, CompileProviderMetadata, CompileQueryMetadata } from './compile_metadata';\r\nimport { CompileReflector } from './compile_reflector';\r\nimport { ParseError, ParseSourceSpan } from './parse_util';\r\nimport { AttrAst, DirectiveAst, ProviderAst, QueryMatch, ReferenceAst } from './template_parser/template_ast';\r\nexport declare class ProviderError extends ParseError {\r\n    constructor(message: string, span: ParseSourceSpan);\r\n}\r\nexport interface QueryWithId {\r\n    meta: CompileQueryMetadata;\r\n    queryId: number;\r\n}\r\nexport declare class ProviderViewContext {\r\n    reflector: CompileReflector;\r\n    component: CompileDirectiveMetadata;\r\n    /**\r\n     * @internal\r\n     */\r\n    viewQueries: Map<any, QueryWithId[]>;\r\n    /**\r\n     * @internal\r\n     */\r\n    viewProviders: Map<any, boolean>;\r\n    errors: ProviderError[];\r\n    constructor(reflector: CompileReflector, component: CompileDirectiveMetadata);\r\n}\r\nexport declare class ProviderElementContext {\r\n    viewContext: ProviderViewContext;\r\n    private _parent;\r\n    private _isViewRoot;\r\n    private _directiveAsts;\r\n    private _sourceSpan;\r\n    private _contentQueries;\r\n    private _transformedProviders;\r\n    private _seenProviders;\r\n    private _allProviders;\r\n    private _attrs;\r\n    private _queriedTokens;\r\n    readonly transformedHasViewContainer: boolean;\r\n    constructor(viewContext: ProviderViewContext, _parent: ProviderElementContext, _isViewRoot: boolean, _directiveAsts: DirectiveAst[], attrs: AttrAst[], refs: ReferenceAst[], isTemplate: boolean, contentQueryStartId: number, _sourceSpan: ParseSourceSpan);\r\n    afterElement(): void;\r\n    readonly transformProviders: ProviderAst[];\r\n    readonly transformedDirectiveAsts: DirectiveAst[];\r\n    readonly queryMatches: QueryMatch[];\r\n    private _addQueryReadsTo;\r\n    private _getQueriesFor;\r\n    private _getOrCreateLocalProvider;\r\n    private _getLocalDependency;\r\n    private _getDependency;\r\n}\r\nexport declare class NgModuleProviderAnalyzer {\r\n    private reflector;\r\n    private _transformedProviders;\r\n    private _seenProviders;\r\n    private _allProviders;\r\n    private _errors;\r\n    constructor(reflector: CompileReflector, ngModule: CompileNgModuleMetadata, extraProviders: CompileProviderMetadata[], sourceSpan: ParseSourceSpan);\r\n    parse(): ProviderAst[];\r\n    private _getOrCreateLocalProvider;\r\n    private _getDependency;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/render3/r3_ast.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { SecurityContext } from '../core';\r\nimport { AST, BindingType, BoundElementProperty, ParsedEvent } from '../expression_parser/ast';\r\nimport { ParseSourceSpan } from '../parse_util';\r\nexport interface Node {\r\n    sourceSpan: ParseSourceSpan;\r\n    visit<Result>(visitor: Visitor<Result>): Result;\r\n}\r\nexport declare class Text implements Node {\r\n    value: string;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(value: string, sourceSpan: ParseSourceSpan);\r\n    visit<Result>(visitor: Visitor<Result>): Result;\r\n}\r\nexport declare class BoundText implements Node {\r\n    value: AST;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(value: AST, sourceSpan: ParseSourceSpan);\r\n    visit<Result>(visitor: Visitor<Result>): Result;\r\n}\r\nexport declare class TextAttribute implements Node {\r\n    name: string;\r\n    value: string;\r\n    sourceSpan: ParseSourceSpan;\r\n    valueSpan?: ParseSourceSpan;\r\n    constructor(name: string, value: string, sourceSpan: ParseSourceSpan, valueSpan?: ParseSourceSpan);\r\n    visit<Result>(visitor: Visitor<Result>): Result;\r\n}\r\nexport declare class BoundAttribute implements Node {\r\n    name: string;\r\n    type: BindingType;\r\n    securityContext: SecurityContext;\r\n    value: AST;\r\n    unit: string | null;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(name: string, type: BindingType, securityContext: SecurityContext, value: AST, unit: string | null, sourceSpan: ParseSourceSpan);\r\n    static fromBoundElementProperty(prop: BoundElementProperty): BoundAttribute;\r\n    visit<Result>(visitor: Visitor<Result>): Result;\r\n}\r\nexport declare class BoundEvent implements Node {\r\n    name: string;\r\n    handler: AST;\r\n    target: string | null;\r\n    phase: string | null;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(name: string, handler: AST, target: string | null, phase: string | null, sourceSpan: ParseSourceSpan);\r\n    static fromParsedEvent(event: ParsedEvent): BoundEvent;\r\n    visit<Result>(visitor: Visitor<Result>): Result;\r\n}\r\nexport declare class Element implements Node {\r\n    name: string;\r\n    attributes: TextAttribute[];\r\n    inputs: BoundAttribute[];\r\n    outputs: BoundEvent[];\r\n    children: Node[];\r\n    references: Reference[];\r\n    sourceSpan: ParseSourceSpan;\r\n    startSourceSpan: ParseSourceSpan | null;\r\n    endSourceSpan: ParseSourceSpan | null;\r\n    constructor(name: string, attributes: TextAttribute[], inputs: BoundAttribute[], outputs: BoundEvent[], children: Node[], references: Reference[], sourceSpan: ParseSourceSpan, startSourceSpan: ParseSourceSpan | null, endSourceSpan: ParseSourceSpan | null);\r\n    visit<Result>(visitor: Visitor<Result>): Result;\r\n}\r\nexport declare class Template implements Node {\r\n    attributes: TextAttribute[];\r\n    inputs: BoundAttribute[];\r\n    outputs: BoundEvent[];\r\n    children: Node[];\r\n    references: Reference[];\r\n    variables: Variable[];\r\n    sourceSpan: ParseSourceSpan;\r\n    startSourceSpan: ParseSourceSpan | null;\r\n    endSourceSpan: ParseSourceSpan | null;\r\n    constructor(attributes: TextAttribute[], inputs: BoundAttribute[], outputs: BoundEvent[], children: Node[], references: Reference[], variables: Variable[], sourceSpan: ParseSourceSpan, startSourceSpan: ParseSourceSpan | null, endSourceSpan: ParseSourceSpan | null);\r\n    visit<Result>(visitor: Visitor<Result>): Result;\r\n}\r\nexport declare class Content implements Node {\r\n    selectorIndex: number;\r\n    attributes: TextAttribute[];\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(selectorIndex: number, attributes: TextAttribute[], sourceSpan: ParseSourceSpan);\r\n    visit<Result>(visitor: Visitor<Result>): Result;\r\n}\r\nexport declare class Variable implements Node {\r\n    name: string;\r\n    value: string;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(name: string, value: string, sourceSpan: ParseSourceSpan);\r\n    visit<Result>(visitor: Visitor<Result>): Result;\r\n}\r\nexport declare class Reference implements Node {\r\n    name: string;\r\n    value: string;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(name: string, value: string, sourceSpan: ParseSourceSpan);\r\n    visit<Result>(visitor: Visitor<Result>): Result;\r\n}\r\nexport interface Visitor<Result = any> {\r\n    visit?(node: Node): Result;\r\n    visitElement(element: Element): Result;\r\n    visitTemplate(template: Template): Result;\r\n    visitContent(content: Content): Result;\r\n    visitVariable(variable: Variable): Result;\r\n    visitReference(reference: Reference): Result;\r\n    visitTextAttribute(attribute: TextAttribute): Result;\r\n    visitBoundAttribute(attribute: BoundAttribute): Result;\r\n    visitBoundEvent(attribute: BoundEvent): Result;\r\n    visitText(text: Text): Result;\r\n    visitBoundText(text: BoundText): Result;\r\n}\r\nexport declare class NullVisitor implements Visitor<void> {\r\n    visitElement(element: Element): void;\r\n    visitTemplate(template: Template): void;\r\n    visitContent(content: Content): void;\r\n    visitVariable(variable: Variable): void;\r\n    visitReference(reference: Reference): void;\r\n    visitTextAttribute(attribute: TextAttribute): void;\r\n    visitBoundAttribute(attribute: BoundAttribute): void;\r\n    visitBoundEvent(attribute: BoundEvent): void;\r\n    visitText(text: Text): void;\r\n    visitBoundText(text: BoundText): void;\r\n}\r\nexport declare class RecursiveVisitor implements Visitor<void> {\r\n    visitElement(element: Element): void;\r\n    visitTemplate(template: Template): void;\r\n    visitContent(content: Content): void;\r\n    visitVariable(variable: Variable): void;\r\n    visitReference(reference: Reference): void;\r\n    visitTextAttribute(attribute: TextAttribute): void;\r\n    visitBoundAttribute(attribute: BoundAttribute): void;\r\n    visitBoundEvent(attribute: BoundEvent): void;\r\n    visitText(text: Text): void;\r\n    visitBoundText(text: BoundText): void;\r\n}\r\nexport declare class TransformVisitor implements Visitor<Node> {\r\n    visitElement(element: Element): Node;\r\n    visitTemplate(template: Template): Node;\r\n    visitContent(content: Content): Node;\r\n    visitVariable(variable: Variable): Node;\r\n    visitReference(reference: Reference): Node;\r\n    visitTextAttribute(attribute: TextAttribute): Node;\r\n    visitBoundAttribute(attribute: BoundAttribute): Node;\r\n    visitBoundEvent(attribute: BoundEvent): Node;\r\n    visitText(text: Text): Node;\r\n    visitBoundText(text: BoundText): Node;\r\n}\r\nexport declare function visitAll<Result>(visitor: Visitor<Result>, nodes: Node[]): Result[];\r\nexport declare function transformAll<Result extends Node>(visitor: Visitor<Node>, nodes: Result[]): Result[];\r\n",
  "/node_modules/@angular/compiler/src/render3/r3_factory.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileTypeMetadata } from '../compile_metadata';\r\nimport { CompileReflector } from '../compile_reflector';\r\nimport * as o from '../output/output_ast';\r\nimport { OutputContext } from '../util';\r\n/**\r\n * Metadata required by the factory generator to generate a `factory` function for a type.\r\n */\r\nexport interface R3ConstructorFactoryMetadata {\r\n    /**\r\n     * String name of the type being generated (used to name the factory function).\r\n     */\r\n    name: string;\r\n    /**\r\n     * An expression representing the function (or constructor) which will instantiate the requested\r\n     * type.\r\n     *\r\n     * This could be a reference to a constructor type, or to a user-defined factory function. The\r\n     * `useNew` property determines whether it will be called as a constructor or not.\r\n     */\r\n    type: o.Expression;\r\n    /**\r\n     * Regardless of whether `fnOrClass` is a constructor function or a user-defined factory, it\r\n     * may have 0 or more parameters, which will be injected according to the `R3DependencyMetadata`\r\n     * for those parameters. If this is `null`, then the type's constructor is nonexistent and will\r\n     * be inherited from `fnOrClass` which is interpreted as the current type.\r\n     */\r\n    deps: R3DependencyMetadata[] | null;\r\n    /**\r\n     * An expression for the function which will be used to inject dependencies. The API of this\r\n     * function could be different, and other options control how it will be invoked.\r\n     */\r\n    injectFn: o.ExternalReference;\r\n}\r\nexport declare enum R3FactoryDelegateType {\r\n    Class = 0,\r\n    Function = 1,\r\n    Factory = 2\r\n}\r\nexport interface R3DelegatedFactoryMetadata extends R3ConstructorFactoryMetadata {\r\n    delegate: o.Expression;\r\n    delegateType: R3FactoryDelegateType.Factory;\r\n}\r\nexport interface R3DelegatedFnOrClassMetadata extends R3ConstructorFactoryMetadata {\r\n    delegate: o.Expression;\r\n    delegateType: R3FactoryDelegateType.Class | R3FactoryDelegateType.Function;\r\n    delegateDeps: R3DependencyMetadata[];\r\n}\r\nexport interface R3ExpressionFactoryMetadata extends R3ConstructorFactoryMetadata {\r\n    expression: o.Expression;\r\n}\r\nexport declare type R3FactoryMetadata = R3ConstructorFactoryMetadata | R3DelegatedFactoryMetadata | R3DelegatedFnOrClassMetadata | R3ExpressionFactoryMetadata;\r\n/**\r\n * Resolved type of a dependency.\r\n *\r\n * Occasionally, dependencies will have special significance which is known statically. In that\r\n * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency\r\n * should be generated specially (usually by calling a special injection function instead of the\r\n * standard one).\r\n */\r\nexport declare enum R3ResolvedDependencyType {\r\n    /**\r\n     * A normal token dependency.\r\n     */\r\n    Token = 0,\r\n    /**\r\n     * The dependency is for an attribute.\r\n     *\r\n     * The token expression is a string representing the attribute name.\r\n     */\r\n    Attribute = 1,\r\n    /**\r\n     * The dependency is for the `Injector` type itself.\r\n     */\r\n    Injector = 2,\r\n    /**\r\n     * The dependency is for `ElementRef`.\r\n     */\r\n    ElementRef = 3,\r\n    /**\r\n     * The dependency is for `TemplateRef`.\r\n     */\r\n    TemplateRef = 4,\r\n    /**\r\n     * The dependency is for `ViewContainerRef`.\r\n     */\r\n    ViewContainerRef = 5,\r\n    /**\r\n     * The dependency is for `ChangeDetectorRef`.\r\n     */\r\n    ChangeDetectorRef = 6,\r\n    /**\r\n     * The dependency is for `Renderer2`.\r\n     */\r\n    Renderer2 = 7\r\n}\r\n/**\r\n * Metadata representing a single dependency to be injected into a constructor or function call.\r\n */\r\nexport interface R3DependencyMetadata {\r\n    /**\r\n     * An expression representing the token or value to be injected.\r\n     */\r\n    token: o.Expression;\r\n    /**\r\n     * An enum indicating whether this dependency has special meaning to Angular and needs to be\r\n     * injected specially.\r\n     */\r\n    resolved: R3ResolvedDependencyType;\r\n    /**\r\n     * Whether the dependency has an @Host qualifier.\r\n     */\r\n    host: boolean;\r\n    /**\r\n     * Whether the dependency has an @Optional qualifier.\r\n     */\r\n    optional: boolean;\r\n    /**\r\n     * Whether the dependency has an @Self qualifier.\r\n     */\r\n    self: boolean;\r\n    /**\r\n     * Whether the dependency has an @SkipSelf qualifier.\r\n     */\r\n    skipSelf: boolean;\r\n}\r\n/**\r\n * Construct a factory function expression for the given `R3FactoryMetadata`.\r\n */\r\nexport declare function compileFactoryFunction(meta: R3FactoryMetadata): {\r\n    factory: o.Expression;\r\n    statements: o.Statement[];\r\n};\r\n/**\r\n * A helper function useful for extracting `R3DependencyMetadata` from a Render2\r\n * `CompileTypeMetadata` instance.\r\n */\r\nexport declare function dependenciesFromGlobalMetadata(type: CompileTypeMetadata, outputCtx: OutputContext, reflector: CompileReflector): R3DependencyMetadata[];\r\n",
  "/node_modules/@angular/compiler/src/render3/r3_identifiers.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as o from '../output/output_ast';\r\nexport declare class Identifiers {\r\n    static NEW_METHOD: string;\r\n    static TRANSFORM_METHOD: string;\r\n    static PATCH_DEPS: string;\r\n    static namespaceHTML: o.ExternalReference;\r\n    static namespaceMathML: o.ExternalReference;\r\n    static namespaceSVG: o.ExternalReference;\r\n    static element: o.ExternalReference;\r\n    static elementStart: o.ExternalReference;\r\n    static elementEnd: o.ExternalReference;\r\n    static elementProperty: o.ExternalReference;\r\n    static elementAttribute: o.ExternalReference;\r\n    static elementClassProp: o.ExternalReference;\r\n    static elementContainerStart: o.ExternalReference;\r\n    static elementContainerEnd: o.ExternalReference;\r\n    static elementStyling: o.ExternalReference;\r\n    static elementStylingMap: o.ExternalReference;\r\n    static elementStyleProp: o.ExternalReference;\r\n    static elementStylingApply: o.ExternalReference;\r\n    static containerCreate: o.ExternalReference;\r\n    static nextContext: o.ExternalReference;\r\n    static templateCreate: o.ExternalReference;\r\n    static text: o.ExternalReference;\r\n    static textBinding: o.ExternalReference;\r\n    static bind: o.ExternalReference;\r\n    static getCurrentView: o.ExternalReference;\r\n    static restoreView: o.ExternalReference;\r\n    static interpolation1: o.ExternalReference;\r\n    static interpolation2: o.ExternalReference;\r\n    static interpolation3: o.ExternalReference;\r\n    static interpolation4: o.ExternalReference;\r\n    static interpolation5: o.ExternalReference;\r\n    static interpolation6: o.ExternalReference;\r\n    static interpolation7: o.ExternalReference;\r\n    static interpolation8: o.ExternalReference;\r\n    static interpolationV: o.ExternalReference;\r\n    static pureFunction0: o.ExternalReference;\r\n    static pureFunction1: o.ExternalReference;\r\n    static pureFunction2: o.ExternalReference;\r\n    static pureFunction3: o.ExternalReference;\r\n    static pureFunction4: o.ExternalReference;\r\n    static pureFunction5: o.ExternalReference;\r\n    static pureFunction6: o.ExternalReference;\r\n    static pureFunction7: o.ExternalReference;\r\n    static pureFunction8: o.ExternalReference;\r\n    static pureFunctionV: o.ExternalReference;\r\n    static pipeBind1: o.ExternalReference;\r\n    static pipeBind2: o.ExternalReference;\r\n    static pipeBind3: o.ExternalReference;\r\n    static pipeBind4: o.ExternalReference;\r\n    static pipeBindV: o.ExternalReference;\r\n    static load: o.ExternalReference;\r\n    static loadDirective: o.ExternalReference;\r\n    static loadQueryList: o.ExternalReference;\r\n    static pipe: o.ExternalReference;\r\n    static projection: o.ExternalReference;\r\n    static projectionDef: o.ExternalReference;\r\n    static reference: o.ExternalReference;\r\n    static inject: o.ExternalReference;\r\n    static injectAttribute: o.ExternalReference;\r\n    static injectElementRef: o.ExternalReference;\r\n    static injectTemplateRef: o.ExternalReference;\r\n    static injectViewContainerRef: o.ExternalReference;\r\n    static injectChangeDetectorRef: o.ExternalReference;\r\n    static injectRenderer2: o.ExternalReference;\r\n    static directiveInject: o.ExternalReference;\r\n    static templateRefExtractor: o.ExternalReference;\r\n    static defineBase: o.ExternalReference;\r\n    static BaseDef: o.ExternalReference;\r\n    static defineComponent: o.ExternalReference;\r\n    static ComponentDef: o.ExternalReference;\r\n    static defineDirective: o.ExternalReference;\r\n    static DirectiveDef: o.ExternalReference;\r\n    static InjectorDef: o.ExternalReference;\r\n    static defineInjector: o.ExternalReference;\r\n    static NgModuleDef: o.ExternalReference;\r\n    static defineNgModule: o.ExternalReference;\r\n    static PipeDef: o.ExternalReference;\r\n    static definePipe: o.ExternalReference;\r\n    static query: o.ExternalReference;\r\n    static queryRefresh: o.ExternalReference;\r\n    static registerContentQuery: o.ExternalReference;\r\n    static NgOnChangesFeature: o.ExternalReference;\r\n    static InheritDefinitionFeature: o.ExternalReference;\r\n    static PublicFeature: o.ExternalReference;\r\n    static listener: o.ExternalReference;\r\n    static getFactoryOf: o.ExternalReference;\r\n    static getInheritedFactory: o.ExternalReference;\r\n    static sanitizeHtml: o.ExternalReference;\r\n    static sanitizeStyle: o.ExternalReference;\r\n    static defaultStyleSanitizer: o.ExternalReference;\r\n    static sanitizeResourceUrl: o.ExternalReference;\r\n    static sanitizeScript: o.ExternalReference;\r\n    static sanitizeUrl: o.ExternalReference;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/render3/r3_jit.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as o from '../output/output_ast';\r\n/**\r\n * JIT compiles an expression and returns the result of executing that expression.\r\n *\r\n * @param def the definition which will be compiled and executed to get the value to patch\r\n * @param context an object map of @angular/core symbol names to symbols which will be available in\r\n * the context of the compiled expression\r\n * @param sourceUrl a URL to use for the source map of the compiled expression\r\n * @param constantPool an optional `ConstantPool` which contains constants used in the expression\r\n */\r\nexport declare function jitExpression(def: o.Expression, context: {\r\n    [key: string]: any;\r\n}, sourceUrl: string, preStatements: o.Statement[]): any;\r\n",
  "/node_modules/@angular/compiler/src/render3/r3_module_compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileShallowModuleMetadata } from '../compile_metadata';\r\nimport { InjectableCompiler } from '../injectable_compiler';\r\nimport * as o from '../output/output_ast';\r\nimport { OutputContext } from '../util';\r\nimport { R3DependencyMetadata } from './r3_factory';\r\nimport { R3Reference } from './util';\r\nexport interface R3NgModuleDef {\r\n    expression: o.Expression;\r\n    type: o.Type;\r\n    additionalStatements: o.Statement[];\r\n}\r\n/**\r\n * Metadata required by the module compiler to generate a `ngModuleDef` for a type.\r\n */\r\nexport interface R3NgModuleMetadata {\r\n    /**\r\n     * An expression representing the module type being compiled.\r\n     */\r\n    type: o.Expression;\r\n    /**\r\n     * An array of expressions representing the bootstrap components specified by the module.\r\n     */\r\n    bootstrap: R3Reference[];\r\n    /**\r\n     * An array of expressions representing the directives and pipes declared by the module.\r\n     */\r\n    declarations: R3Reference[];\r\n    /**\r\n     * An array of expressions representing the imports of the module.\r\n     */\r\n    imports: R3Reference[];\r\n    /**\r\n     * An array of expressions representing the exports of the module.\r\n     */\r\n    exports: R3Reference[];\r\n    /**\r\n     * Whether to emit the selector scope values (declarations, imports, exports) inline into the\r\n     * module definition, or to generate additional statements which patch them on. Inline emission\r\n     * does not allow components to be tree-shaken, but is useful for JIT mode.\r\n     */\r\n    emitInline: boolean;\r\n}\r\n/**\r\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\r\n */\r\nexport declare function compileNgModule(meta: R3NgModuleMetadata): R3NgModuleDef;\r\nexport interface R3InjectorDef {\r\n    expression: o.Expression;\r\n    type: o.Type;\r\n    statements: o.Statement[];\r\n}\r\nexport interface R3InjectorMetadata {\r\n    name: string;\r\n    type: o.Expression;\r\n    deps: R3DependencyMetadata[] | null;\r\n    providers: o.Expression;\r\n    imports: o.Expression;\r\n}\r\nexport declare function compileInjector(meta: R3InjectorMetadata): R3InjectorDef;\r\nexport declare function compileNgModuleFromRender2(ctx: OutputContext, ngModule: CompileShallowModuleMetadata, injectableCompiler: InjectableCompiler): void;\r\n",
  "/node_modules/@angular/compiler/src/render3/r3_module_factory_compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileNgModuleMetadata, CompileTypeMetadata } from '../compile_metadata';\r\nimport { CompileMetadataResolver } from '../metadata_resolver';\r\nimport * as o from '../output/output_ast';\r\nimport { OutputContext } from '../util';\r\n/**\r\n * Write a Renderer2 compatibility module factory to the output context.\r\n */\r\nexport declare function compileModuleFactory(outputCtx: OutputContext, module: CompileNgModuleMetadata, backPatchReferenceOf: (module: CompileTypeMetadata) => o.Expression, resolver: CompileMetadataResolver): void;\r\n",
  "/node_modules/@angular/compiler/src/render3/r3_pipe_compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompilePipeMetadata } from '../compile_metadata';\r\nimport { CompileReflector } from '../compile_reflector';\r\nimport * as o from '../output/output_ast';\r\nimport { OutputContext } from '../util';\r\nimport { R3DependencyMetadata } from './r3_factory';\r\nexport interface R3PipeMetadata {\r\n    name: string;\r\n    type: o.Expression;\r\n    pipeName: string;\r\n    deps: R3DependencyMetadata[] | null;\r\n    pure: boolean;\r\n}\r\nexport interface R3PipeDef {\r\n    expression: o.Expression;\r\n    type: o.Type;\r\n    statements: o.Statement[];\r\n}\r\nexport declare function compilePipeFromMetadata(metadata: R3PipeMetadata): {\r\n    expression: o.InvokeFunctionExpr;\r\n    type: o.ExpressionType;\r\n    statements: o.Statement[];\r\n};\r\n/**\r\n * Write a pipe definition to the output context.\r\n */\r\nexport declare function compilePipeFromRender2(outputCtx: OutputContext, pipe: CompilePipeMetadata, reflector: CompileReflector): never;\r\n",
  "/node_modules/@angular/compiler/src/render3/r3_template_transform.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as html from '../ml_parser/ast';\r\nimport { ParseError } from '../parse_util';\r\nimport { BindingParser } from '../template_parser/binding_parser';\r\nimport * as t from './r3_ast';\r\nexport declare type Render3ParseResult = {\r\n    nodes: t.Node[];\r\n    errors: ParseError[];\r\n    ngContentSelectors: string[];\r\n    hasNgContent: boolean;\r\n};\r\nexport declare function htmlAstToRender3Ast(htmlNodes: html.Node[], bindingParser: BindingParser): Render3ParseResult;\r\n",
  "/node_modules/@angular/compiler/src/render3/r3_types.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Comment to insert above back-patch\r\n */\r\nexport declare const BUILD_OPTIMIZER_COLOCATE = \"@__BUILD_OPTIMIZER_COLOCATE__\";\r\n/**\r\n * Comment to mark removable expressions\r\n */\r\nexport declare const BUILD_OPTIMIZER_REMOVE = \"@__BUILD_OPTIMIZER_REMOVE__\";\r\n",
  "/node_modules/@angular/compiler/src/render3/util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as o from '../output/output_ast';\r\nimport { OutputContext } from '../util';\r\n/**\r\n * Convert an object map with `Expression` values into a `LiteralMapExpr`.\r\n */\r\nexport declare function mapToMapExpression(map: {\r\n    [key: string]: o.Expression;\r\n}): o.LiteralMapExpr;\r\n/**\r\n * Convert metadata into an `Expression` in the given `OutputContext`.\r\n *\r\n * This operation will handle arrays, references to symbols, or literal `null` or `undefined`.\r\n */\r\nexport declare function convertMetaToOutput(meta: any, ctx: OutputContext): o.Expression;\r\nexport declare function typeWithParameters(type: o.Expression, numParams: number): o.ExpressionType;\r\nexport interface R3Reference {\r\n    value: o.Expression;\r\n    type: o.Expression;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/render3/view/api.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ViewEncapsulation } from '../../core';\r\nimport * as o from '../../output/output_ast';\r\nimport { ParseSourceSpan } from '../../parse_util';\r\nimport * as t from '../r3_ast';\r\nimport { R3DependencyMetadata } from '../r3_factory';\r\n/**\r\n * Information needed to compile a directive for the render3 runtime.\r\n */\r\nexport interface R3DirectiveMetadata {\r\n    /**\r\n     * Name of the directive type.\r\n     */\r\n    name: string;\r\n    /**\r\n     * An expression representing a reference to the directive itself.\r\n     */\r\n    type: o.Expression;\r\n    /**\r\n     * Number of generic type parameters of the type itself.\r\n     */\r\n    typeArgumentCount: number;\r\n    /**\r\n     * A source span for the directive type.\r\n     */\r\n    typeSourceSpan: ParseSourceSpan;\r\n    /**\r\n     * Dependencies of the directive's constructor.\r\n     */\r\n    deps: R3DependencyMetadata[] | null;\r\n    /**\r\n     * Unparsed selector of the directive, or `null` if there was no selector.\r\n     */\r\n    selector: string | null;\r\n    /**\r\n     * Information about the content queries made by the directive.\r\n     */\r\n    queries: R3QueryMetadata[];\r\n    /**\r\n     * Mappings indicating how the directive interacts with its host element (host bindings,\r\n     * listeners, etc).\r\n     */\r\n    host: {\r\n        /**\r\n         * A mapping of attribute binding keys to unparsed expressions.\r\n         */\r\n        attributes: {\r\n            [key: string]: string;\r\n        };\r\n        /**\r\n         * A mapping of event binding keys to unparsed expressions.\r\n         */\r\n        listeners: {\r\n            [key: string]: string;\r\n        };\r\n        /**\r\n         * A mapping of property binding keys to unparsed expressions.\r\n         */\r\n        properties: {\r\n            [key: string]: string;\r\n        };\r\n    };\r\n    /**\r\n     * Information about usage of specific lifecycle events which require special treatment in the\r\n     * code generator.\r\n     */\r\n    lifecycle: {\r\n        /**\r\n         * Whether the directive uses NgOnChanges.\r\n         */\r\n        usesOnChanges: boolean;\r\n    };\r\n    /**\r\n     * A mapping of input field names to the property names.\r\n     */\r\n    inputs: {\r\n        [field: string]: string;\r\n    };\r\n    /**\r\n     * A mapping of output field names to the property names.\r\n     */\r\n    outputs: {\r\n        [field: string]: string;\r\n    };\r\n    /**\r\n     * Whether or not the component or directive inherits from another class\r\n     */\r\n    usesInheritance: boolean;\r\n    /**\r\n     * Reference name under which to export the directive's type in a template,\r\n     * if any.\r\n     */\r\n    exportAs: string | null;\r\n}\r\n/**\r\n * Information needed to compile a component for the render3 runtime.\r\n */\r\nexport interface R3ComponentMetadata extends R3DirectiveMetadata {\r\n    /**\r\n     * Information about the component's template.\r\n     */\r\n    template: {\r\n        /**\r\n         * Parsed nodes of the template.\r\n         */\r\n        nodes: t.Node[];\r\n        /**\r\n         * Whether the template includes <ng-content> tags.\r\n         */\r\n        hasNgContent: boolean;\r\n        /**\r\n         * Selectors found in the <ng-content> tags in the template.\r\n         */\r\n        ngContentSelectors: string[];\r\n        /**\r\n         * Path to the .ts file in which this template's generated code will be included, relative to\r\n         * the compilation root. This will be used to generate identifiers that need to be globally\r\n         * unique in certain contexts (such as g3).\r\n         */\r\n        relativeContextFilePath: string;\r\n    };\r\n    /**\r\n     * Information about the view queries made by the component.\r\n     */\r\n    viewQueries: R3QueryMetadata[];\r\n    /**\r\n     * A map of pipe names to an expression referencing the pipe type which are in the scope of the\r\n     * compilation.\r\n     */\r\n    pipes: Map<string, o.Expression>;\r\n    /**\r\n     * A map of directive selectors to an expression referencing the directive type which are in the\r\n     * scope of the compilation.\r\n     */\r\n    directives: Map<string, o.Expression>;\r\n    /**\r\n     * Whether to wrap the 'directives' array, if one is generated, in a closure.\r\n     *\r\n     * This is done when the directives contain forward references.\r\n     */\r\n    wrapDirectivesInClosure: boolean;\r\n    /**\r\n     * A collection of styling data that will be applied and scoped to the component.\r\n     */\r\n    styles: string[];\r\n    /**\r\n     * An encapsulation policy for the template and CSS styles. One of:\r\n     * - `ViewEncapsulation.Native`: Use shadow roots. This works only if natively available on the\r\n     *   platform (note that this is marked the as the \"deprecated shadow DOM\" as of Angular v6.1.\r\n     * - `ViewEncapsulation.Emulated`: Use shimmed CSS that emulates the native behavior.\r\n     * - `ViewEncapsulation.None`: Use global CSS without any encapsulation.\r\n     * - `ViewEncapsulation.ShadowDom`: Use the latest ShadowDOM API to natively encapsulate styles\r\n     * into a shadow root.\r\n     */\r\n    encapsulation: ViewEncapsulation;\r\n    /**\r\n     * A collection of animation triggers that will be used in the component template.\r\n     */\r\n    animations: {\r\n        [key: string]: any;\r\n    }[] | null;\r\n}\r\n/**\r\n * Information needed to compile a query (view or content).\r\n */\r\nexport interface R3QueryMetadata {\r\n    /**\r\n     * Name of the property on the class to update with query results.\r\n     */\r\n    propertyName: string;\r\n    /**\r\n     * Whether to read only the first matching result, or an array of results.\r\n     */\r\n    first: boolean;\r\n    /**\r\n     * Either an expression representing a type for the query predicate, or a set of string selectors.\r\n     */\r\n    predicate: o.Expression | string[];\r\n    /**\r\n     * Whether to include only direct children or all descendants.\r\n     */\r\n    descendants: boolean;\r\n    /**\r\n     * An expression representing a type to read from each matched node, or null if the node itself\r\n     * is to be returned.\r\n     */\r\n    read: o.Expression | null;\r\n}\r\n/**\r\n * Output of render3 directive compilation.\r\n */\r\nexport interface R3DirectiveDef {\r\n    expression: o.Expression;\r\n    type: o.Type;\r\n    statements: o.Statement[];\r\n}\r\n/**\r\n * Output of render3 component compilation.\r\n */\r\nexport interface R3ComponentDef {\r\n    expression: o.Expression;\r\n    type: o.Type;\r\n    statements: o.Statement[];\r\n}\r\n",
  "/node_modules/@angular/compiler/src/render3/view/compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileDirectiveMetadata } from '../../compile_metadata';\r\nimport { CompileReflector } from '../../compile_reflector';\r\nimport { ConstantPool } from '../../constant_pool';\r\nimport * as o from '../../output/output_ast';\r\nimport { BindingParser } from '../../template_parser/binding_parser';\r\nimport { OutputContext } from '../../util';\r\nimport { Render3ParseResult } from '../r3_template_transform';\r\nimport { R3ComponentDef, R3ComponentMetadata, R3DirectiveDef, R3DirectiveMetadata } from './api';\r\n/**\r\n * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.\r\n */\r\nexport declare function compileDirectiveFromMetadata(meta: R3DirectiveMetadata, constantPool: ConstantPool, bindingParser: BindingParser): R3DirectiveDef;\r\nexport interface R3BaseRefMetaData {\r\n    inputs?: {\r\n        [key: string]: string | [string, string];\r\n    };\r\n    outputs?: {\r\n        [key: string]: string;\r\n    };\r\n}\r\n/**\r\n * Compile a base definition for the render3 runtime as defined by {@link R3BaseRefMetadata}\r\n * @param meta the metadata used for compilation.\r\n */\r\nexport declare function compileBaseDefFromMetadata(meta: R3BaseRefMetaData): {\r\n    expression: o.InvokeFunctionExpr;\r\n    type: o.ExpressionType;\r\n};\r\n/**\r\n * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.\r\n */\r\nexport declare function compileComponentFromMetadata(meta: R3ComponentMetadata, constantPool: ConstantPool, bindingParser: BindingParser): R3ComponentDef;\r\n/**\r\n * A wrapper around `compileDirective` which depends on render2 global analysis data as its input\r\n * instead of the `R3DirectiveMetadata`.\r\n *\r\n * `R3DirectiveMetadata` is computed from `CompileDirectiveMetadata` and other statically reflected\r\n * information.\r\n */\r\nexport declare function compileDirectiveFromRender2(outputCtx: OutputContext, directive: CompileDirectiveMetadata, reflector: CompileReflector, bindingParser: BindingParser): void;\r\n/**\r\n * A wrapper around `compileComponent` which depends on render2 global analysis data as its input\r\n * instead of the `R3DirectiveMetadata`.\r\n *\r\n * `R3ComponentMetadata` is computed from `CompileDirectiveMetadata` and other statically reflected\r\n * information.\r\n */\r\nexport declare function compileComponentFromRender2(outputCtx: OutputContext, component: CompileDirectiveMetadata, render3Ast: Render3ParseResult, reflector: CompileReflector, bindingParser: BindingParser, directiveTypeBySel: Map<string, any>, pipeTypeByName: Map<string, any>): void;\r\nexport declare function parseHostBindings(host: {\r\n    [key: string]: string;\r\n}): {\r\n    attributes: {\r\n        [key: string]: string;\r\n    };\r\n    listeners: {\r\n        [key: string]: string;\r\n    };\r\n    properties: {\r\n        [key: string]: string;\r\n    };\r\n    animations: {\r\n        [key: string]: string;\r\n    };\r\n};\r\n",
  "/node_modules/@angular/compiler/src/render3/view/styling.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Parses string representation of a style and converts it into object literal.\r\n *\r\n * @param value string representation of style as used in the `style` attribute in HTML.\r\n *   Example: `color: red; height: auto`.\r\n * @returns an object literal. `{ color: 'red', height: 'auto'}`.\r\n */\r\nexport declare function parseStyle(value: string): {\r\n    [key: string]: any;\r\n};\r\nexport declare function stripUnnecessaryQuotes(value: string): string;\r\nexport declare function hyphenate(value: string): string;\r\n",
  "/node_modules/@angular/compiler/src/render3/view/template.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { LocalResolver } from '../../compiler_util/expression_converter';\r\nimport { ConstantPool } from '../../constant_pool';\r\nimport * as core from '../../core';\r\nimport { AST, AstMemoryEfficientTransformer, BindingPipe, LiteralArray, LiteralMap } from '../../expression_parser/ast';\r\nimport * as o from '../../output/output_ast';\r\nimport { ParseError } from '../../parse_util';\r\nimport { SelectorMatcher } from '../../selector';\r\nimport { BindingParser } from '../../template_parser/binding_parser';\r\nimport * as t from '../r3_ast';\r\nimport { R3QueryMetadata } from './api';\r\nimport { invalid } from './util';\r\nexport declare function renderFlagCheckIfStmt(flags: core.RenderFlags, statements: o.Statement[]): o.IfStmt;\r\nexport declare class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver {\r\n    private constantPool;\r\n    private level;\r\n    private contextName;\r\n    private templateName;\r\n    private viewQueries;\r\n    private directiveMatcher;\r\n    private directives;\r\n    private pipeTypeByName;\r\n    private pipes;\r\n    private _namespace;\r\n    private relativeContextFilePath;\r\n    private _dataIndex;\r\n    private _bindingContext;\r\n    private _prefixCode;\r\n    /**\r\n     * List of callbacks to generate creation mode instructions. We store them here as we process\r\n     * the template so bindings in listeners are resolved only once all nodes have been visited.\r\n     * This ensures all local refs and context variables are available for matching.\r\n     */\r\n    private _creationCodeFns;\r\n    /**\r\n     * List of callbacks to generate update mode instructions. We store them here as we process\r\n     * the template so bindings are resolved only once all nodes have been visited. This ensures\r\n     * all local refs and context variables are available for matching.\r\n     */\r\n    private _updateCodeFns;\r\n    /** Temporary variable declarations generated from visiting pipes, literals, etc. */\r\n    private _tempVariables;\r\n    /**\r\n     * List of callbacks to build nested templates. Nested templates must not be visited until\r\n     * after the parent template has finished visiting all of its nodes. This ensures that all\r\n     * local ref bindings in nested templates are able to find local ref values if the refs\r\n     * are defined after the template declaration.\r\n     */\r\n    private _nestedTemplateFns;\r\n    /**\r\n     * This scope contains local variables declared in the update mode block of the template.\r\n     * (e.g. refs and context vars in bindings)\r\n     */\r\n    private _bindingScope;\r\n    private _valueConverter;\r\n    private _unsupported;\r\n    private _inI18nSection;\r\n    private _i18nSectionIndex;\r\n    private _phToNodeIdxes;\r\n    private _pureFunctionSlots;\r\n    private _bindingSlots;\r\n    private fileBasedI18nSuffix;\r\n    constructor(constantPool: ConstantPool, parentBindingScope: BindingScope, level: number, contextName: string | null, templateName: string | null, viewQueries: R3QueryMetadata[], directiveMatcher: SelectorMatcher | null, directives: Set<o.Expression>, pipeTypeByName: Map<string, o.Expression>, pipes: Set<o.Expression>, _namespace: o.ExternalReference, relativeContextFilePath: string);\r\n    registerContextVariables(variable: t.Variable): void;\r\n    buildTemplateFunction(nodes: t.Node[], variables: t.Variable[], hasNgContent?: boolean, ngContentSelectors?: string[]): o.FunctionExpr;\r\n    getLocal(name: string): o.Expression | null;\r\n    visitContent(ngContent: t.Content): void;\r\n    getNamespaceInstruction(namespaceKey: string | null): o.ExternalReference;\r\n    addNamespaceInstruction(nsInstruction: o.ExternalReference, element: t.Element): void;\r\n    visitElement(element: t.Element): void;\r\n    visitTemplate(template: t.Template): void;\r\n    readonly visitReference: typeof invalid;\r\n    readonly visitVariable: typeof invalid;\r\n    readonly visitTextAttribute: typeof invalid;\r\n    readonly visitBoundAttribute: typeof invalid;\r\n    readonly visitBoundEvent: typeof invalid;\r\n    visitBoundText(text: t.BoundText): void;\r\n    visitText(text: t.Text): void;\r\n    visitSingleI18nTextChild(text: t.Text, i18nMeta: string): void;\r\n    private allocateDataSlot;\r\n    getConstCount(): number;\r\n    getVarCount(): number;\r\n    private bindingContext;\r\n    private instructionFn;\r\n    private creationInstruction;\r\n    private updateInstruction;\r\n    private allocatePureFunctionSlots;\r\n    private allocateBindingSlots;\r\n    private convertPropertyBinding;\r\n    private matchDirectives;\r\n    private getAttrsForDirectiveMatching;\r\n    private prepareSyntheticAndSelectOnlyAttrs;\r\n    private toAttrsParam;\r\n    private prepareRefsParameter;\r\n    private prepareListenerParameter;\r\n}\r\nexport declare class ValueConverter extends AstMemoryEfficientTransformer {\r\n    private constantPool;\r\n    private allocateSlot;\r\n    private allocatePureFunctionSlots;\r\n    private definePipe;\r\n    private _pipeBindExprs;\r\n    constructor(constantPool: ConstantPool, allocateSlot: () => number, allocatePureFunctionSlots: (numSlots: number) => number, definePipe: (name: string, localName: string, slot: number, value: o.Expression) => void);\r\n    visitPipe(pipe: BindingPipe, context: any): AST;\r\n    updatePipeSlotOffsets(bindingSlots: number): void;\r\n    visitLiteralArray(array: LiteralArray, context: any): AST;\r\n    visitLiteralMap(map: LiteralMap, context: any): AST;\r\n}\r\n/**\r\n * Function which is executed whenever a variable is referenced for the first time in a given\r\n * scope.\r\n *\r\n * It is expected that the function creates the `const localName = expression`; statement.\r\n */\r\nexport declare type DeclareLocalVarCallback = (scope: BindingScope, relativeLevel: number) => o.Statement[];\r\n/**\r\n * This is used when one refers to variable such as: 'let abc = x(2).$implicit`.\r\n * - key to the map is the string literal `\"abc\"`.\r\n * - value `retrievalLevel` is the level from which this value can be retrieved, which is 2 levels\r\n * up in example.\r\n * - value `lhs` is the left hand side which is an AST representing `abc`.\r\n * - value `declareLocalCallback` is a callback that is invoked when declaring the local.\r\n * - value `declare` is true if this value needs to be declared.\r\n * - value `priority` dictates the sorting priority of this var declaration compared\r\n * to other var declarations on the same retrieval level. For example, if there is a\r\n * context variable and a local ref accessing the same parent view, the context var\r\n * declaration should always come before the local ref declaration.\r\n */\r\ndeclare type BindingData = {\r\n    retrievalLevel: number;\r\n    lhs: o.ReadVarExpr;\r\n    declareLocalCallback?: DeclareLocalVarCallback;\r\n    declare: boolean;\r\n    priority: number;\r\n};\r\nexport declare class BindingScope implements LocalResolver {\r\n    bindingLevel: number;\r\n    private parent;\r\n    /** Keeps a map from local variables to their BindingData. */\r\n    private map;\r\n    private referenceNameIndex;\r\n    private restoreViewVariable;\r\n    private static _ROOT_SCOPE;\r\n    static readonly ROOT_SCOPE: BindingScope;\r\n    private constructor();\r\n    get(name: string): o.Expression | null;\r\n    /**\r\n     * Create a local variable for later reference.\r\n     *\r\n     * @param retrievalLevel The level from which this value can be retrieved\r\n     * @param name Name of the variable.\r\n     * @param lhs AST representing the left hand side of the `let lhs = rhs;`.\r\n     * @param priority The sorting priority of this var\r\n     * @param declareLocalCallback The callback to invoke when declaring this local var\r\n     */\r\n    set(retrievalLevel: number, name: string, lhs: o.ReadVarExpr, priority?: number, declareLocalCallback?: DeclareLocalVarCallback): BindingScope;\r\n    getLocal(name: string): (o.Expression | null);\r\n    nestedScope(level: number): BindingScope;\r\n    getSharedContextName(retrievalLevel: number): o.ReadVarExpr | null;\r\n    maybeGenerateSharedContextVar(value: BindingData): void;\r\n    generateSharedContextVar(retrievalLevel: number): void;\r\n    getComponentProperty(name: string): o.Expression;\r\n    maybeRestoreView(retrievalLevel: number): void;\r\n    restoreViewStatement(): o.Statement[];\r\n    viewSnapshotStatements(): o.Statement[];\r\n    isListenerScope(): boolean;\r\n    variableDeclarations(): o.Statement[];\r\n    freshReferenceName(): string;\r\n}\r\n/**\r\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\r\n *\r\n * @param template text of the template to parse\r\n * @param templateUrl URL to use for source mapping of the parsed template\r\n */\r\nexport declare function parseTemplate(template: string, templateUrl: string, options: {\r\n    preserveWhitespaces?: boolean;\r\n}, relativeContextFilePath: string): {\r\n    errors?: ParseError[];\r\n    nodes: t.Node[];\r\n    hasNgContent: boolean;\r\n    ngContentSelectors: string[];\r\n    relativeContextFilePath: string;\r\n};\r\n/**\r\n * Construct a `BindingParser` with a default configuration.\r\n */\r\nexport declare function makeBindingParser(): BindingParser;\r\nexport {};\r\n",
  "/node_modules/@angular/compiler/src/render3/view/util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ConstantPool } from '../../constant_pool';\r\nimport * as o from '../../output/output_ast';\r\nimport * as t from '../r3_ast';\r\nimport { R3QueryMetadata } from './api';\r\n/** Name of the temporary to use during data binding */\r\nexport declare const TEMPORARY_NAME = \"_t\";\r\n/** Name of the context parameter passed into a template function */\r\nexport declare const CONTEXT_NAME = \"ctx\";\r\n/** Name of the RenderFlag passed into a template function */\r\nexport declare const RENDER_FLAGS = \"rf\";\r\n/** The prefix reference variables */\r\nexport declare const REFERENCE_PREFIX = \"_r\";\r\n/** The name of the implicit context reference */\r\nexport declare const IMPLICIT_REFERENCE = \"$implicit\";\r\n/** Name of the i18n attributes **/\r\nexport declare const I18N_ATTR = \"i18n\";\r\nexport declare const I18N_ATTR_PREFIX = \"i18n-\";\r\n/** I18n separators for metadata **/\r\nexport declare const MEANING_SEPARATOR = \"|\";\r\nexport declare const ID_SEPARATOR = \"@@\";\r\n/**\r\n * Creates an allocator for a temporary variable.\r\n *\r\n * A variable declaration is added to the statements the first time the allocator is invoked.\r\n */\r\nexport declare function temporaryAllocator(statements: o.Statement[], name: string): () => o.ReadVarExpr;\r\nexport declare function unsupported(feature: string): never;\r\nexport declare function invalid<T>(arg: o.Expression | o.Statement | t.Node): never;\r\nexport declare function isI18NAttribute(name: string): boolean;\r\nexport declare function asLiteral(value: any): o.Expression;\r\nexport declare function conditionallyCreateMapObjectLiteral(keys: {\r\n    [key: string]: string;\r\n}): o.Expression | null;\r\nexport declare function mapToExpression(map: {\r\n    [key: string]: any;\r\n}, quoted?: boolean): o.Expression;\r\n/**\r\n *  Remove trailing null nodes as they are implied.\r\n */\r\nexport declare function trimTrailingNulls(parameters: o.Expression[]): o.Expression[];\r\nexport declare function getQueryPredicate(query: R3QueryMetadata, constantPool: ConstantPool): o.Expression;\r\nexport declare function noop(): void;\r\nexport declare class DefinitionMap {\r\n    values: {\r\n        key: string;\r\n        quoted: boolean;\r\n        value: o.Expression;\r\n    }[];\r\n    set(key: string, value: o.Expression | null): void;\r\n    toLiteralMap(): o.LiteralMapExpr;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/resource_loader.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * An interface for retrieving documents by URL that the compiler uses\r\n * to load templates.\r\n */\r\nexport declare class ResourceLoader {\r\n    get(url: string): Promise<string> | string;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/schema/dom_element_schema_registry.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { SchemaMetadata, SecurityContext } from '../core';\r\nimport { ElementSchemaRegistry } from './element_schema_registry';\r\nexport declare class DomElementSchemaRegistry extends ElementSchemaRegistry {\r\n    private _schema;\r\n    constructor();\r\n    hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean;\r\n    hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean;\r\n    /**\r\n     * securityContext returns the security context for the given property on the given DOM tag.\r\n     *\r\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\r\n     * possible to bind a value into a changing attribute or tag name.\r\n     *\r\n     * The filtering is white list based. All attributes in the schema above are assumed to have the\r\n     * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known\r\n     * attack vectors are assigned their appropriate context.\r\n     */\r\n    securityContext(tagName: string, propName: string, isAttribute: boolean): SecurityContext;\r\n    getMappedPropName(propName: string): string;\r\n    getDefaultComponentElementName(): string;\r\n    validateProperty(name: string): {\r\n        error: boolean;\r\n        msg?: string;\r\n    };\r\n    validateAttribute(name: string): {\r\n        error: boolean;\r\n        msg?: string;\r\n    };\r\n    allKnownElementNames(): string[];\r\n    normalizeAnimationStyleProperty(propName: string): string;\r\n    normalizeAnimationStyleValue(camelCaseProp: string, userProvidedProp: string, val: string | number): {\r\n        error: string;\r\n        value: string;\r\n    };\r\n}\r\n",
  "/node_modules/@angular/compiler/src/schema/dom_security_schema.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { SecurityContext } from '../core';\r\nexport declare function SECURITY_SCHEMA(): {\r\n    [k: string]: SecurityContext;\r\n};\r\n",
  "/node_modules/@angular/compiler/src/schema/element_schema_registry.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { SchemaMetadata, SecurityContext } from '../core';\r\nexport declare abstract class ElementSchemaRegistry {\r\n    abstract hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean;\r\n    abstract hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean;\r\n    abstract securityContext(elementName: string, propName: string, isAttribute: boolean): SecurityContext;\r\n    abstract allKnownElementNames(): string[];\r\n    abstract getMappedPropName(propName: string): string;\r\n    abstract getDefaultComponentElementName(): string;\r\n    abstract validateProperty(name: string): {\r\n        error: boolean;\r\n        msg?: string;\r\n    };\r\n    abstract validateAttribute(name: string): {\r\n        error: boolean;\r\n        msg?: string;\r\n    };\r\n    abstract normalizeAnimationStyleProperty(propName: string): string;\r\n    abstract normalizeAnimationStyleValue(camelCaseProp: string, userProvidedProp: string, val: string | number): {\r\n        error: string;\r\n        value: string;\r\n    };\r\n}\r\n",
  "/node_modules/@angular/compiler/src/selector.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A css selector contains an element name,\r\n * css classes and attribute/value pairs with the purpose\r\n * of selecting subsets out of them.\r\n */\r\nexport declare class CssSelector {\r\n    element: string | null;\r\n    classNames: string[];\r\n    /**\r\n     * The selectors are encoded in pairs where:\r\n     * - even locations are attribute names\r\n     * - odd locations are attribute values.\r\n     *\r\n     * Example:\r\n     * Selector: `[key1=value1][key2]` would parse to:\r\n     * ```\r\n     * ['key1', 'value1', 'key2', '']\r\n     * ```\r\n     */\r\n    attrs: string[];\r\n    notSelectors: CssSelector[];\r\n    static parse(selector: string): CssSelector[];\r\n    isElementSelector(): boolean;\r\n    hasElementSelector(): boolean;\r\n    setElement(element?: string | null): void;\r\n    /** Gets a template string for an element that matches the selector. */\r\n    getMatchingElementTemplate(): string;\r\n    getAttrs(): string[];\r\n    addAttribute(name: string, value?: string): void;\r\n    addClassName(name: string): void;\r\n    toString(): string;\r\n}\r\n/**\r\n * Reads a list of CssSelectors and allows to calculate which ones\r\n * are contained in a given CssSelector.\r\n */\r\nexport declare class SelectorMatcher {\r\n    static createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher;\r\n    private _elementMap;\r\n    private _elementPartialMap;\r\n    private _classMap;\r\n    private _classPartialMap;\r\n    private _attrValueMap;\r\n    private _attrValuePartialMap;\r\n    private _listContexts;\r\n    addSelectables(cssSelectors: CssSelector[], callbackCtxt?: any): void;\r\n    /**\r\n     * Add an object that can be found later on by calling `match`.\r\n     * @param cssSelector A css selector\r\n     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\r\n     */\r\n    private _addSelectable;\r\n    private _addTerminal;\r\n    private _addPartial;\r\n    /**\r\n     * Find the objects that have been added via `addSelectable`\r\n     * whose css selector is contained in the given css selector.\r\n     * @param cssSelector A css selector\r\n     * @param matchedCallback This callback will be called with the object handed into `addSelectable`\r\n     * @return boolean true if a match was found\r\n    */\r\n    match(cssSelector: CssSelector, matchedCallback: ((c: CssSelector, a: any) => void) | null): boolean;\r\n    /** @internal */\r\n    _matchTerminal(map: Map<string, SelectorContext[]>, name: string, cssSelector: CssSelector, matchedCallback: ((c: CssSelector, a: any) => void) | null): boolean;\r\n    /** @internal */\r\n    _matchPartial(map: Map<string, SelectorMatcher>, name: string, cssSelector: CssSelector, matchedCallback: ((c: CssSelector, a: any) => void) | null): boolean;\r\n}\r\nexport declare class SelectorListContext {\r\n    selectors: CssSelector[];\r\n    alreadyMatched: boolean;\r\n    constructor(selectors: CssSelector[]);\r\n}\r\nexport declare class SelectorContext {\r\n    selector: CssSelector;\r\n    cbContext: any;\r\n    listContext: SelectorListContext;\r\n    notSelectors: CssSelector[];\r\n    constructor(selector: CssSelector, cbContext: any, listContext: SelectorListContext);\r\n    finalize(cssSelector: CssSelector, callback: ((c: CssSelector, a: any) => void) | null): boolean;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/shadow_css.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\r\n *\r\n * Please make sure to keep to edits in sync with the source file.\r\n *\r\n * Source:\r\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\r\n *\r\n * The original file level comment is reproduced below\r\n */\r\nexport declare class ShadowCss {\r\n    strictStyling: boolean;\r\n    constructor();\r\n    shimCssText(cssText: string, selector: string, hostSelector?: string): string;\r\n    private _insertDirectives;\r\n    private _insertPolyfillDirectivesInCssText;\r\n    private _insertPolyfillRulesInCssText;\r\n    private _scopeCssText;\r\n    private _extractUnscopedRulesFromCssText;\r\n    private _convertColonHost;\r\n    private _convertColonHostContext;\r\n    private _convertColonRule;\r\n    private _colonHostContextPartReplacer;\r\n    private _colonHostPartReplacer;\r\n    private _convertShadowDOMSelectors;\r\n    private _scopeSelectors;\r\n    private _scopeSelector;\r\n    private _selectorNeedsScoping;\r\n    private _makeScopeMatcher;\r\n    private _applySelectorScope;\r\n    private _applySimpleSelectorScope;\r\n    private _applyStrictSelectorScope;\r\n    private _insertPolyfillHostInCssText;\r\n}\r\nexport declare class CssRule {\r\n    selector: string;\r\n    content: string;\r\n    constructor(selector: string, content: string);\r\n}\r\nexport declare function processRules(input: string, ruleCallback: (rule: CssRule) => CssRule): string;\r\n",
  "/node_modules/@angular/compiler/src/style_compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileDirectiveMetadata, CompileStylesheetMetadata } from './compile_metadata';\r\nimport { UrlResolver } from './url_resolver';\r\nimport { OutputContext } from './util';\r\nexport declare const HOST_ATTR: string;\r\nexport declare const CONTENT_ATTR: string;\r\nexport declare class StylesCompileDependency {\r\n    name: string;\r\n    moduleUrl: string;\r\n    setValue: (value: any) => void;\r\n    constructor(name: string, moduleUrl: string, setValue: (value: any) => void);\r\n}\r\nexport declare class CompiledStylesheet {\r\n    outputCtx: OutputContext;\r\n    stylesVar: string;\r\n    dependencies: StylesCompileDependency[];\r\n    isShimmed: boolean;\r\n    meta: CompileStylesheetMetadata;\r\n    constructor(outputCtx: OutputContext, stylesVar: string, dependencies: StylesCompileDependency[], isShimmed: boolean, meta: CompileStylesheetMetadata);\r\n}\r\nexport declare class StyleCompiler {\r\n    private _urlResolver;\r\n    private _shadowCss;\r\n    constructor(_urlResolver: UrlResolver);\r\n    compileComponent(outputCtx: OutputContext, comp: CompileDirectiveMetadata): CompiledStylesheet;\r\n    compileStyles(outputCtx: OutputContext, comp: CompileDirectiveMetadata, stylesheet: CompileStylesheetMetadata, shim?: boolean): CompiledStylesheet;\r\n    needsStyleShim(comp: CompileDirectiveMetadata): boolean;\r\n    private _compileStyles;\r\n    private _shimIfNeeded;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/style_url_resolver.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { UrlResolver } from './url_resolver';\r\nexport declare class StyleWithImports {\r\n    style: string;\r\n    styleUrls: string[];\r\n    constructor(style: string, styleUrls: string[]);\r\n}\r\nexport declare function isStyleUrlResolvable(url: string): boolean;\r\n/**\r\n * Rewrites stylesheets by resolving and removing the @import urls that\r\n * are either relative or don't have a `package:` scheme\r\n */\r\nexport declare function extractStyleUrls(resolver: UrlResolver, baseUrl: string, cssText: string): StyleWithImports;\r\n",
  "/node_modules/@angular/compiler/src/summary_resolver.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileTypeSummary } from './compile_metadata';\r\nimport { Type } from './core';\r\nexport interface Summary<T> {\r\n    symbol: T;\r\n    metadata: any;\r\n    type?: CompileTypeSummary;\r\n}\r\nexport declare abstract class SummaryResolver<T> {\r\n    abstract isLibraryFile(fileName: string): boolean;\r\n    abstract toSummaryFileName(fileName: string, referringSrcFileName: string): string;\r\n    abstract fromSummaryFileName(fileName: string, referringLibFileName: string): string;\r\n    abstract resolveSummary(reference: T): Summary<T> | null;\r\n    abstract getSymbolsOf(filePath: string): T[] | null;\r\n    abstract getImportAs(reference: T): T;\r\n    abstract getKnownModuleName(fileName: string): string | null;\r\n    abstract addSummary(summary: Summary<T>): void;\r\n}\r\nexport declare class JitSummaryResolver implements SummaryResolver<Type> {\r\n    private _summaries;\r\n    isLibraryFile(): boolean;\r\n    toSummaryFileName(fileName: string): string;\r\n    fromSummaryFileName(fileName: string): string;\r\n    resolveSummary(reference: Type): Summary<Type> | null;\r\n    getSymbolsOf(): Type[];\r\n    getImportAs(reference: Type): Type;\r\n    getKnownModuleName(fileName: string): any;\r\n    addSummary(summary: Summary<Type>): void;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/template_parser/binding_parser.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileDirectiveSummary, CompilePipeSummary } from '../compile_metadata';\r\nimport { SecurityContext } from '../core';\r\nimport { ASTWithSource, BindingPipe, BoundElementProperty, ParsedEvent, ParsedProperty, ParsedVariable, RecursiveAstVisitor } from '../expression_parser/ast';\r\nimport { Parser } from '../expression_parser/parser';\r\nimport { InterpolationConfig } from '../ml_parser/interpolation_config';\r\nimport { ParseError, ParseSourceSpan } from '../parse_util';\r\nimport { ElementSchemaRegistry } from '../schema/element_schema_registry';\r\n/**\r\n * Parses bindings in templates and in the directive host area.\r\n */\r\nexport declare class BindingParser {\r\n    private _exprParser;\r\n    private _interpolationConfig;\r\n    private _schemaRegistry;\r\n    errors: ParseError[];\r\n    pipesByName: Map<string, CompilePipeSummary> | null;\r\n    private _usedPipes;\r\n    constructor(_exprParser: Parser, _interpolationConfig: InterpolationConfig, _schemaRegistry: ElementSchemaRegistry, pipes: CompilePipeSummary[] | null, errors: ParseError[]);\r\n    getUsedPipes(): CompilePipeSummary[];\r\n    createBoundHostProperties(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan): ParsedProperty[] | null;\r\n    createDirectiveHostPropertyAsts(dirMeta: CompileDirectiveSummary, elementSelector: string, sourceSpan: ParseSourceSpan): BoundElementProperty[] | null;\r\n    createDirectiveHostEventAsts(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan): ParsedEvent[] | null;\r\n    parseInterpolation(value: string, sourceSpan: ParseSourceSpan): ASTWithSource;\r\n    parseInlineTemplateBinding(tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][], targetProps: ParsedProperty[], targetVars: ParsedVariable[]): void;\r\n    private _parseTemplateBindings;\r\n    parseLiteralAttr(name: string, value: string | null, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][], targetProps: ParsedProperty[]): void;\r\n    parsePropertyBinding(name: string, expression: string, isHost: boolean, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][], targetProps: ParsedProperty[]): void;\r\n    parsePropertyInterpolation(name: string, value: string, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][], targetProps: ParsedProperty[]): boolean;\r\n    private _parsePropertyAst;\r\n    private _parseAnimation;\r\n    private _parseBinding;\r\n    createBoundElementProperty(elementSelector: string, boundProp: ParsedProperty): BoundElementProperty;\r\n    parseEvent(name: string, expression: string, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]): void;\r\n    private _parseAnimationEvent;\r\n    private _parseRegularEvent;\r\n    private _parseAction;\r\n    private _reportError;\r\n    private _reportExpressionParserErrors;\r\n    private _checkPipes;\r\n    /**\r\n     * @param propName the name of the property / attribute\r\n     * @param sourceSpan\r\n     * @param isAttr true when binding to an attribute\r\n     */\r\n    private _validatePropertyOrAttributeName;\r\n}\r\nexport declare class PipeCollector extends RecursiveAstVisitor {\r\n    pipes: Map<string, BindingPipe>;\r\n    visitPipe(ast: BindingPipe, context: any): any;\r\n}\r\nexport declare function calcPossibleSecurityContexts(registry: ElementSchemaRegistry, selector: string, propName: string, isAttribute: boolean): SecurityContext[];\r\n",
  "/node_modules/@angular/compiler/src/template_parser/template_ast.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { AstPath } from '../ast_path';\r\nimport { CompileDirectiveSummary, CompileProviderMetadata, CompileTokenMetadata } from '../compile_metadata';\r\nimport { SecurityContext } from '../core';\r\nimport { AST, BoundElementProperty, ParsedEvent, ParsedVariable } from '../expression_parser/ast';\r\nimport { LifecycleHooks } from '../lifecycle_reflector';\r\nimport { ParseSourceSpan } from '../parse_util';\r\n/**\r\n * An Abstract Syntax Tree node representing part of a parsed Angular template.\r\n */\r\nexport interface TemplateAst {\r\n    /**\r\n     * The source span from which this node was parsed.\r\n     */\r\n    sourceSpan: ParseSourceSpan;\r\n    /**\r\n     * Visit this node and possibly transform it.\r\n     */\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\n/**\r\n * A segment of text within the template.\r\n */\r\nexport declare class TextAst implements TemplateAst {\r\n    value: string;\r\n    ngContentIndex: number;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(value: string, ngContentIndex: number, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\n/**\r\n * A bound expression within the text of a template.\r\n */\r\nexport declare class BoundTextAst implements TemplateAst {\r\n    value: AST;\r\n    ngContentIndex: number;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(value: AST, ngContentIndex: number, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\n/**\r\n * A plain attribute on an element.\r\n */\r\nexport declare class AttrAst implements TemplateAst {\r\n    name: string;\r\n    value: string;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(name: string, value: string, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\nexport declare const enum PropertyBindingType {\r\n    Property = 0,\r\n    Attribute = 1,\r\n    Class = 2,\r\n    Style = 3,\r\n    Animation = 4\r\n}\r\n/**\r\n * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\r\n * `[@trigger]=\"stateExp\"`)\r\n */\r\nexport declare class BoundElementPropertyAst implements TemplateAst {\r\n    name: string;\r\n    type: PropertyBindingType;\r\n    securityContext: SecurityContext;\r\n    value: AST;\r\n    unit: string | null;\r\n    sourceSpan: ParseSourceSpan;\r\n    readonly isAnimation: boolean;\r\n    constructor(name: string, type: PropertyBindingType, securityContext: SecurityContext, value: AST, unit: string | null, sourceSpan: ParseSourceSpan);\r\n    static fromBoundProperty(prop: BoundElementProperty): BoundElementPropertyAst;\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\n/**\r\n * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\r\n * `(@trigger.phase)=\"callback($event)\"`).\r\n */\r\nexport declare class BoundEventAst implements TemplateAst {\r\n    name: string;\r\n    target: string | null;\r\n    phase: string | null;\r\n    handler: AST;\r\n    sourceSpan: ParseSourceSpan;\r\n    readonly fullName: string;\r\n    readonly isAnimation: boolean;\r\n    constructor(name: string, target: string | null, phase: string | null, handler: AST, sourceSpan: ParseSourceSpan);\r\n    static calcFullName(name: string, target: string | null, phase: string | null): string;\r\n    static fromParsedEvent(event: ParsedEvent): BoundEventAst;\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\n/**\r\n * A reference declaration on an element (e.g. `let someName=\"expression\"`).\r\n */\r\nexport declare class ReferenceAst implements TemplateAst {\r\n    name: string;\r\n    value: CompileTokenMetadata;\r\n    originalValue: string;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(name: string, value: CompileTokenMetadata, originalValue: string, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\n/**\r\n * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\r\n */\r\nexport declare class VariableAst implements TemplateAst {\r\n    name: string;\r\n    value: string;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(name: string, value: string, sourceSpan: ParseSourceSpan);\r\n    static fromParsedVariable(v: ParsedVariable): VariableAst;\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\n/**\r\n * An element declaration in a template.\r\n */\r\nexport declare class ElementAst implements TemplateAst {\r\n    name: string;\r\n    attrs: AttrAst[];\r\n    inputs: BoundElementPropertyAst[];\r\n    outputs: BoundEventAst[];\r\n    references: ReferenceAst[];\r\n    directives: DirectiveAst[];\r\n    providers: ProviderAst[];\r\n    hasViewContainer: boolean;\r\n    queryMatches: QueryMatch[];\r\n    children: TemplateAst[];\r\n    ngContentIndex: number | null;\r\n    sourceSpan: ParseSourceSpan;\r\n    endSourceSpan: ParseSourceSpan | null;\r\n    constructor(name: string, attrs: AttrAst[], inputs: BoundElementPropertyAst[], outputs: BoundEventAst[], references: ReferenceAst[], directives: DirectiveAst[], providers: ProviderAst[], hasViewContainer: boolean, queryMatches: QueryMatch[], children: TemplateAst[], ngContentIndex: number | null, sourceSpan: ParseSourceSpan, endSourceSpan: ParseSourceSpan | null);\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\n/**\r\n * A `<ng-template>` element included in an Angular template.\r\n */\r\nexport declare class EmbeddedTemplateAst implements TemplateAst {\r\n    attrs: AttrAst[];\r\n    outputs: BoundEventAst[];\r\n    references: ReferenceAst[];\r\n    variables: VariableAst[];\r\n    directives: DirectiveAst[];\r\n    providers: ProviderAst[];\r\n    hasViewContainer: boolean;\r\n    queryMatches: QueryMatch[];\r\n    children: TemplateAst[];\r\n    ngContentIndex: number;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(attrs: AttrAst[], outputs: BoundEventAst[], references: ReferenceAst[], variables: VariableAst[], directives: DirectiveAst[], providers: ProviderAst[], hasViewContainer: boolean, queryMatches: QueryMatch[], children: TemplateAst[], ngContentIndex: number, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\n/**\r\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\r\n */\r\nexport declare class BoundDirectivePropertyAst implements TemplateAst {\r\n    directiveName: string;\r\n    templateName: string;\r\n    value: AST;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(directiveName: string, templateName: string, value: AST, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\n/**\r\n * A directive declared on an element.\r\n */\r\nexport declare class DirectiveAst implements TemplateAst {\r\n    directive: CompileDirectiveSummary;\r\n    inputs: BoundDirectivePropertyAst[];\r\n    hostProperties: BoundElementPropertyAst[];\r\n    hostEvents: BoundEventAst[];\r\n    contentQueryStartId: number;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(directive: CompileDirectiveSummary, inputs: BoundDirectivePropertyAst[], hostProperties: BoundElementPropertyAst[], hostEvents: BoundEventAst[], contentQueryStartId: number, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\n/**\r\n * A provider declared on an element\r\n */\r\nexport declare class ProviderAst implements TemplateAst {\r\n    token: CompileTokenMetadata;\r\n    multiProvider: boolean;\r\n    eager: boolean;\r\n    providers: CompileProviderMetadata[];\r\n    providerType: ProviderAstType;\r\n    lifecycleHooks: LifecycleHooks[];\r\n    sourceSpan: ParseSourceSpan;\r\n    readonly isModule: boolean;\r\n    constructor(token: CompileTokenMetadata, multiProvider: boolean, eager: boolean, providers: CompileProviderMetadata[], providerType: ProviderAstType, lifecycleHooks: LifecycleHooks[], sourceSpan: ParseSourceSpan, isModule: boolean);\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\nexport declare enum ProviderAstType {\r\n    PublicService = 0,\r\n    PrivateService = 1,\r\n    Component = 2,\r\n    Directive = 3,\r\n    Builtin = 4\r\n}\r\n/**\r\n * Position where content is to be projected (instance of `<ng-content>` in a template).\r\n */\r\nexport declare class NgContentAst implements TemplateAst {\r\n    index: number;\r\n    ngContentIndex: number;\r\n    sourceSpan: ParseSourceSpan;\r\n    constructor(index: number, ngContentIndex: number, sourceSpan: ParseSourceSpan);\r\n    visit(visitor: TemplateAstVisitor, context: any): any;\r\n}\r\nexport interface QueryMatch {\r\n    queryId: number;\r\n    value: CompileTokenMetadata;\r\n}\r\n/**\r\n * A visitor for {@link TemplateAst} trees that will process each node.\r\n */\r\nexport interface TemplateAstVisitor {\r\n    visit?(ast: TemplateAst, context: any): any;\r\n    visitNgContent(ast: NgContentAst, context: any): any;\r\n    visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any;\r\n    visitElement(ast: ElementAst, context: any): any;\r\n    visitReference(ast: ReferenceAst, context: any): any;\r\n    visitVariable(ast: VariableAst, context: any): any;\r\n    visitEvent(ast: BoundEventAst, context: any): any;\r\n    visitElementProperty(ast: BoundElementPropertyAst, context: any): any;\r\n    visitAttr(ast: AttrAst, context: any): any;\r\n    visitBoundText(ast: BoundTextAst, context: any): any;\r\n    visitText(ast: TextAst, context: any): any;\r\n    visitDirective(ast: DirectiveAst, context: any): any;\r\n    visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any;\r\n}\r\n/**\r\n * A visitor that accepts each node but doesn't do anything. It is intended to be used\r\n * as the base class for a visitor that is only interested in a subset of the node types.\r\n */\r\nexport declare class NullTemplateVisitor implements TemplateAstVisitor {\r\n    visitNgContent(ast: NgContentAst, context: any): void;\r\n    visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): void;\r\n    visitElement(ast: ElementAst, context: any): void;\r\n    visitReference(ast: ReferenceAst, context: any): void;\r\n    visitVariable(ast: VariableAst, context: any): void;\r\n    visitEvent(ast: BoundEventAst, context: any): void;\r\n    visitElementProperty(ast: BoundElementPropertyAst, context: any): void;\r\n    visitAttr(ast: AttrAst, context: any): void;\r\n    visitBoundText(ast: BoundTextAst, context: any): void;\r\n    visitText(ast: TextAst, context: any): void;\r\n    visitDirective(ast: DirectiveAst, context: any): void;\r\n    visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): void;\r\n}\r\n/**\r\n * Base class that can be used to build a visitor that visits each node\r\n * in an template ast recursively.\r\n */\r\nexport declare class RecursiveTemplateAstVisitor extends NullTemplateVisitor implements TemplateAstVisitor {\r\n    constructor();\r\n    visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any;\r\n    visitElement(ast: ElementAst, context: any): any;\r\n    visitDirective(ast: DirectiveAst, context: any): any;\r\n    protected visitChildren<T extends TemplateAst>(context: any, cb: (visit: (<V extends TemplateAst>(children: V[] | undefined) => void)) => void): any;\r\n}\r\n/**\r\n * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.\r\n */\r\nexport declare function templateVisitAll(visitor: TemplateAstVisitor, asts: TemplateAst[], context?: any): any[];\r\nexport declare type TemplateAstPath = AstPath<TemplateAst>;\r\n",
  "/node_modules/@angular/compiler/src/template_parser/template_parser.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileDirectiveMetadata, CompileDirectiveSummary, CompilePipeSummary, CompileTypeMetadata } from '../compile_metadata';\r\nimport { CompileReflector } from '../compile_reflector';\r\nimport { CompilerConfig } from '../config';\r\nimport { SchemaMetadata } from '../core';\r\nimport { Parser } from '../expression_parser/parser';\r\nimport { HtmlParser, ParseTreeResult } from '../ml_parser/html_parser';\r\nimport { InterpolationConfig } from '../ml_parser/interpolation_config';\r\nimport { ParseError, ParseErrorLevel, ParseSourceSpan } from '../parse_util';\r\nimport { ElementSchemaRegistry } from '../schema/element_schema_registry';\r\nimport { CssSelector } from '../selector';\r\nimport { Console } from '../util';\r\nimport * as t from './template_ast';\r\nexport declare class TemplateParseError extends ParseError {\r\n    constructor(message: string, span: ParseSourceSpan, level: ParseErrorLevel);\r\n}\r\nexport declare class TemplateParseResult {\r\n    templateAst?: t.TemplateAst[];\r\n    usedPipes?: CompilePipeSummary[];\r\n    errors?: ParseError[];\r\n    constructor(templateAst?: t.TemplateAst[], usedPipes?: CompilePipeSummary[], errors?: ParseError[]);\r\n}\r\nexport declare class TemplateParser {\r\n    private _config;\r\n    private _reflector;\r\n    private _exprParser;\r\n    private _schemaRegistry;\r\n    private _htmlParser;\r\n    private _console;\r\n    transforms: t.TemplateAstVisitor[];\r\n    constructor(_config: CompilerConfig, _reflector: CompileReflector, _exprParser: Parser, _schemaRegistry: ElementSchemaRegistry, _htmlParser: HtmlParser, _console: Console, transforms: t.TemplateAstVisitor[]);\r\n    readonly expressionParser: Parser;\r\n    parse(component: CompileDirectiveMetadata, template: string | ParseTreeResult, directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[], templateUrl: string, preserveWhitespaces: boolean): {\r\n        template: t.TemplateAst[];\r\n        pipes: CompilePipeSummary[];\r\n    };\r\n    tryParse(component: CompileDirectiveMetadata, template: string | ParseTreeResult, directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[], templateUrl: string, preserveWhitespaces: boolean): TemplateParseResult;\r\n    tryParseHtml(htmlAstWithErrors: ParseTreeResult, component: CompileDirectiveMetadata, directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[]): TemplateParseResult;\r\n    expandHtml(htmlAstWithErrors: ParseTreeResult, forced?: boolean): ParseTreeResult;\r\n    getInterpolationConfig(component: CompileDirectiveMetadata): InterpolationConfig | undefined;\r\n    /** @internal */\r\n    _assertNoReferenceDuplicationOnTemplate(result: t.TemplateAst[], errors: TemplateParseError[]): void;\r\n}\r\nexport declare function splitClasses(classAttrValue: string): string[];\r\nexport declare function createElementCssSelector(elementName: string, attributes: [string, string][]): CssSelector;\r\nexport declare function removeSummaryDuplicates<T extends {\r\n    type: CompileTypeMetadata;\r\n}>(items: T[]): T[];\r\n",
  "/node_modules/@angular/compiler/src/template_parser/template_preparser.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as html from '../ml_parser/ast';\r\nexport declare function preparseElement(ast: html.Element): PreparsedElement;\r\nexport declare enum PreparsedElementType {\r\n    NG_CONTENT = 0,\r\n    STYLE = 1,\r\n    STYLESHEET = 2,\r\n    SCRIPT = 3,\r\n    OTHER = 4\r\n}\r\nexport declare class PreparsedElement {\r\n    type: PreparsedElementType;\r\n    selectAttr: string;\r\n    hrefAttr: string;\r\n    nonBindable: boolean;\r\n    projectAs: string;\r\n    constructor(type: PreparsedElementType, selectAttr: string, hrefAttr: string, nonBindable: boolean, projectAs: string);\r\n}\r\n",
  "/node_modules/@angular/compiler/src/url_resolver.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Create a {@link UrlResolver} with no package prefix.\r\n */\r\nexport declare function createUrlResolverWithoutPackagePrefix(): UrlResolver;\r\nexport declare function createOfflineCompileUrlResolver(): UrlResolver;\r\n/**\r\n * Used by the {@link Compiler} when resolving HTML and CSS template URLs.\r\n *\r\n * This class can be overridden by the application developer to create custom behavior.\r\n *\r\n * See {@link Compiler}\r\n *\r\n * ## Example\r\n *\r\n * {@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}\r\n *\r\n * @security  When compiling templates at runtime, you must\r\n * ensure that the entire template comes from a trusted source.\r\n * Attacker-controlled data introduced by a template could expose your\r\n * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).\r\n */\r\nexport interface UrlResolver {\r\n    resolve(baseUrl: string, url: string): string;\r\n}\r\nexport interface UrlResolverCtor {\r\n    new (packagePrefix?: string | null): UrlResolver;\r\n}\r\nexport declare const UrlResolver: UrlResolverCtor;\r\n/**\r\n * Extract the scheme of a URL.\r\n */\r\nexport declare function getUrlScheme(url: string): string;\r\n",
  "/node_modules/@angular/compiler/src/util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ConstantPool } from './constant_pool';\r\nimport * as o from './output/output_ast';\r\nimport { ParseError } from './parse_util';\r\nexport declare function dashCaseToCamelCase(input: string): string;\r\nexport declare function splitAtColon(input: string, defaultValues: string[]): string[];\r\nexport declare function splitAtPeriod(input: string, defaultValues: string[]): string[];\r\nexport declare function visitValue(value: any, visitor: ValueVisitor, context: any): any;\r\nexport declare function isDefined(val: any): boolean;\r\nexport declare function noUndefined<T>(val: T | undefined): T;\r\nexport interface ValueVisitor {\r\n    visitArray(arr: any[], context: any): any;\r\n    visitStringMap(map: {\r\n        [key: string]: any;\r\n    }, context: any): any;\r\n    visitPrimitive(value: any, context: any): any;\r\n    visitOther(value: any, context: any): any;\r\n}\r\nexport declare class ValueTransformer implements ValueVisitor {\r\n    visitArray(arr: any[], context: any): any;\r\n    visitStringMap(map: {\r\n        [key: string]: any;\r\n    }, context: any): any;\r\n    visitPrimitive(value: any, context: any): any;\r\n    visitOther(value: any, context: any): any;\r\n}\r\nexport declare type SyncAsync<T> = T | Promise<T>;\r\nexport declare const SyncAsync: {\r\n    assertSync: <T>(value: SyncAsync<T>) => T;\r\n    then: <T, R>(value: SyncAsync<T>, cb: (value: T) => SyncAsync<R>) => SyncAsync<R>;\r\n    all: <T>(syncAsyncValues: SyncAsync<T>[]) => SyncAsync<T[]>;\r\n};\r\nexport declare function error(msg: string): never;\r\nexport declare function syntaxError(msg: string, parseErrors?: ParseError[]): Error;\r\nexport declare function isSyntaxError(error: Error): boolean;\r\nexport declare function getParseErrors(error: Error): ParseError[];\r\nexport declare function escapeRegExp(s: string): string;\r\nexport declare function utf8Encode(str: string): string;\r\nexport interface OutputContext {\r\n    genFilePath: string;\r\n    statements: o.Statement[];\r\n    constantPool: ConstantPool;\r\n    importExpr(reference: any, typeParams?: o.Type[] | null, useSummaries?: boolean): o.Expression;\r\n}\r\nexport declare function stringify(token: any): string;\r\n/**\r\n * Lazily retrieves the reference value from a forwardRef.\r\n */\r\nexport declare function resolveForwardRef(type: any): any;\r\n/**\r\n * Determine if the argument is shaped like a Promise\r\n */\r\nexport declare function isPromise(obj: any): obj is Promise<any>;\r\nexport declare class Version {\r\n    full: string;\r\n    readonly major: string;\r\n    readonly minor: string;\r\n    readonly patch: string;\r\n    constructor(full: string);\r\n}\r\nexport interface Console {\r\n    log(message: string): void;\r\n    warn(message: string): void;\r\n}\r\n",
  "/node_modules/@angular/compiler/src/version.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @module\r\n * @description\r\n * Entry point for all public APIs of the common package.\r\n */\r\nimport { Version } from './util';\r\nexport declare const VERSION: Version;\r\n",
  "/node_modules/@angular/compiler/src/view_compiler/provider_compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileDiDependencyMetadata, CompileEntryComponentMetadata } from '../compile_metadata';\r\nimport { CompileReflector } from '../compile_reflector';\r\nimport { NodeFlags } from '../core';\r\nimport { LifecycleHooks } from '../lifecycle_reflector';\r\nimport * as o from '../output/output_ast';\r\nimport { ProviderAst } from '../template_parser/template_ast';\r\nimport { OutputContext } from '../util';\r\nexport declare function providerDef(ctx: OutputContext, providerAst: ProviderAst): {\r\n    providerExpr: o.Expression;\r\n    flags: NodeFlags;\r\n    depsExpr: o.Expression;\r\n    tokenExpr: o.Expression;\r\n};\r\nexport declare function depDef(ctx: OutputContext, dep: CompileDiDependencyMetadata): o.Expression;\r\nexport declare function lifecycleHookToNodeFlag(lifecycleHook: LifecycleHooks): NodeFlags;\r\nexport declare function componentFactoryResolverProviderDef(reflector: CompileReflector, ctx: OutputContext, flags: NodeFlags, entryComponents: CompileEntryComponentMetadata[]): {\r\n    providerExpr: o.Expression;\r\n    flags: NodeFlags;\r\n    depsExpr: o.Expression;\r\n    tokenExpr: o.Expression;\r\n};\r\n",
  "/node_modules/@angular/compiler/src/view_compiler/type_check_compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { AotCompilerOptions } from '../aot/compiler_options';\r\nimport { StaticReflector } from '../aot/static_reflector';\r\nimport { StaticSymbol } from '../aot/static_symbol';\r\nimport { CompileDirectiveMetadata, CompilePipeSummary } from '../compile_metadata';\r\nimport * as o from '../output/output_ast';\r\nimport { TemplateAst } from '../template_parser/template_ast';\r\nimport { OutputContext } from '../util';\r\n/**\r\n * Generates code that is used to type check templates.\r\n */\r\nexport declare class TypeCheckCompiler {\r\n    private options;\r\n    private reflector;\r\n    constructor(options: AotCompilerOptions, reflector: StaticReflector);\r\n    /**\r\n     * Important notes:\r\n     * - This must not produce new `import` statements, but only refer to types outside\r\n     *   of the file via the variables provided via externalReferenceVars.\r\n     *   This allows Typescript to reuse the old program's structure as no imports have changed.\r\n     * - This must not produce any exports, as this would pollute the .d.ts file\r\n     *   and also violate the point above.\r\n     */\r\n    compileComponent(componentId: string, component: CompileDirectiveMetadata, template: TemplateAst[], usedPipes: CompilePipeSummary[], externalReferenceVars: Map<StaticSymbol, string>, ctx: OutputContext): o.Statement[];\r\n}\r\n",
  "/node_modules/@angular/compiler/src/view_compiler/view_compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompileDirectiveMetadata, CompilePipeSummary } from '../compile_metadata';\r\nimport { CompileReflector } from '../compile_reflector';\r\nimport * as o from '../output/output_ast';\r\nimport { TemplateAst } from '../template_parser/template_ast';\r\nimport { OutputContext } from '../util';\r\nexport declare class ViewCompileResult {\r\n    viewClassVar: string;\r\n    rendererTypeVar: string;\r\n    constructor(viewClassVar: string, rendererTypeVar: string);\r\n}\r\nexport declare class ViewCompiler {\r\n    private _reflector;\r\n    constructor(_reflector: CompileReflector);\r\n    compileComponent(outputCtx: OutputContext, component: CompileDirectiveMetadata, template: TemplateAst[], styles: o.Expression, usedPipes: CompilePipeSummary[]): ViewCompileResult;\r\n}\r\nexport declare function elementEventFullName(target: string | null, name: string): string;\r\n",
  "/node_modules/@angular/compiler/test/aot/test_util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { AotCompilerHost, AotCompilerOptions, GeneratedFile } from '@angular/compiler';\r\nimport { ModuleMetadata } from '@angular/compiler-cli/src/metadata/index';\r\nexport interface MetadataProvider {\r\n    getMetadata(source: ts.SourceFile): ModuleMetadata | undefined;\r\n}\r\nexport declare type MockFileOrDirectory = string | MockDirectory;\r\nexport declare type MockDirectory = {\r\n    [name: string]: MockFileOrDirectory | undefined;\r\n};\r\nexport declare function isDirectory(data: MockFileOrDirectory | undefined): data is MockDirectory;\r\nexport declare const settings: ts.CompilerOptions;\r\nexport interface EmitterOptions {\r\n    emitMetadata: boolean;\r\n    mockData?: MockDirectory;\r\n    context?: Map<string, string>;\r\n}\r\nexport declare class EmittingCompilerHost implements ts.CompilerHost {\r\n    private options;\r\n    private addedFiles;\r\n    private writtenFiles;\r\n    private scriptNames;\r\n    private root;\r\n    private collector;\r\n    private cachedAddedDirectories;\r\n    constructor(scriptNames: string[], options: EmitterOptions);\r\n    writtenAngularFiles(target?: Map<string, string>): Map<string, string>;\r\n    addScript(fileName: string, content: string): void;\r\n    override(fileName: string, content: string): void;\r\n    addFiles(map: Map<string, string>): void;\r\n    addWrittenFile(fileName: string, content: string): void;\r\n    getWrittenFiles(): {\r\n        name: string;\r\n        content: string;\r\n    }[];\r\n    readonly scripts: string[];\r\n    readonly written: Map<string, string>;\r\n    effectiveName(fileName: string): string;\r\n    fileExists(fileName: string): boolean;\r\n    readFile(fileName: string): string;\r\n    directoryExists(directoryName: string): boolean;\r\n    getCurrentDirectory(): string;\r\n    getDirectories(dir: string): string[];\r\n    getSourceFile(fileName: string, languageVersion: ts.ScriptTarget, onError?: (message: string) => void): ts.SourceFile;\r\n    getDefaultLibFileName(options: ts.CompilerOptions): string;\r\n    writeFile: ts.WriteFileCallback;\r\n    getCanonicalFileName(fileName: string): string;\r\n    useCaseSensitiveFileNames(): boolean;\r\n    getNewLine(): string;\r\n    private getAddedDirectories;\r\n}\r\nexport declare class MockCompilerHost implements ts.CompilerHost {\r\n    private data;\r\n    scriptNames: string[];\r\n    overrides: Map<string, string>;\r\n    writtenFiles: Map<string, string>;\r\n    private sourceFiles;\r\n    private assumeExists;\r\n    private traces;\r\n    constructor(scriptNames: string[], data: MockDirectory);\r\n    override(fileName: string, content: string): void;\r\n    addScript(fileName: string, content: string): void;\r\n    assumeFileExists(fileName: string): void;\r\n    remove(files: string[]): void;\r\n    fileExists(fileName: string): boolean;\r\n    readFile(fileName: string): string;\r\n    trace(s: string): void;\r\n    getCurrentDirectory(): string;\r\n    getDirectories(dir: string): string[];\r\n    getSourceFile(fileName: string, languageVersion: ts.ScriptTarget, onError?: (message: string) => void): ts.SourceFile;\r\n    getDefaultLibFileName(options: ts.CompilerOptions): string;\r\n    writeFile: ts.WriteFileCallback;\r\n    getCanonicalFileName(fileName: string): string;\r\n    useCaseSensitiveFileNames(): boolean;\r\n    getNewLine(): string;\r\n    private getFileContent;\r\n    private getEffectiveName;\r\n}\r\nexport declare class MockAotCompilerHost implements AotCompilerHost {\r\n    private tsHost;\r\n    private metadataProvider;\r\n    private metadataVisible;\r\n    private dtsAreSource;\r\n    private resolveModuleNameHost;\r\n    constructor(tsHost: MockCompilerHost, metadataProvider?: MetadataProvider);\r\n    hideMetadata(): void;\r\n    tsFilesOnly(): void;\r\n    getMetadataFor(modulePath: string): {\r\n        [key: string]: any;\r\n    }[] | undefined;\r\n    moduleNameToFileName(moduleName: string, containingFile: string): string | null;\r\n    getOutputName(filePath: string): string;\r\n    resourceNameToFileName(resourceName: string, containingFile: string): string;\r\n    loadSummary(filePath: string): string | null;\r\n    isSourceFile(sourceFilePath: string): boolean;\r\n    toSummaryFileName(filePath: string): string;\r\n    fromSummaryFileName(filePath: string): string;\r\n    fileNameToModuleName(importedFile: string, containingFile: string): string;\r\n    loadResource(path: string): string;\r\n}\r\nexport declare type MockFileArray = {\r\n    fileName: string;\r\n    content: string;\r\n}[];\r\nexport declare type MockData = MockDirectory | Map<string, string> | (MockDirectory | Map<string, string>)[];\r\nexport declare function toMockFileArray(data: MockData, target?: MockFileArray): MockFileArray;\r\nexport declare function arrayToMockMap(arr: MockFileArray): Map<string, string>;\r\nexport declare function arrayToMockDir(arr: MockFileArray): MockDirectory;\r\nexport declare function isInBazel(): boolean;\r\nexport declare function setup(options?: {\r\n    compileAngular: boolean;\r\n    compileAnimations: boolean;\r\n    compileCommon?: boolean;\r\n}): Map<string, string>;\r\nexport declare function expectNoDiagnostics(program: ts.Program): void;\r\nexport declare function isSource(fileName: string): boolean;\r\nexport declare function compile(rootDirs: MockData, options?: {\r\n    emit?: boolean;\r\n    useSummaries?: boolean;\r\n    preCompile?: (program: ts.Program) => void;\r\n    postCompile?: (program: ts.Program) => void;\r\n} & AotCompilerOptions, tsOptions?: ts.CompilerOptions): {\r\n    genFiles: GeneratedFile[];\r\n    outDir: MockDirectory;\r\n};\r\nexport declare function emitLibrary(context: Map<string, string>, mockData: MockDirectory, scriptFiles?: string[]): Map<string, string>;\r\nexport declare function mergeMaps<K, V>(...maps: Map<K, V>[]): Map<K, V>;\r\n",
  "/node_modules/@angular/compiler/test/render3/mock_compile.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { AotCompilerOptions } from '@angular/compiler';\r\nimport { OutputContext } from '../../src/util';\r\nimport { MockData, MockDirectory } from '../aot/test_util';\r\nexport declare function expectEmit(source: string, expected: string, description: string, assertIdentifiers?: {\r\n    [name: string]: RegExp;\r\n}): void;\r\nexport declare function compile(data: MockDirectory, angularFiles: MockData, options?: AotCompilerOptions, errorCollector?: (error: any, fileName?: string) => void): {\r\n    source: string;\r\n    outputContext: OutputContext;\r\n};\r\n",
  "/node_modules/@angular/compiler-cli/index.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { AotCompilerHost, AotCompilerHost as StaticReflectorHost, StaticReflector, StaticSymbol } from '@angular/compiler';\r\nexport { DiagnosticTemplateInfo, getExpressionScope, getTemplateExpressionDiagnostics } from './src/diagnostics/expression_diagnostics';\r\nexport { AstType, ExpressionDiagnosticsContext } from './src/diagnostics/expression_type';\r\nexport { BuiltinType, DeclarationKind, Definition, PipeInfo, Pipes, Signature, Span, Symbol, SymbolDeclaration, SymbolQuery, SymbolTable } from './src/diagnostics/symbols';\r\nexport { getClassMembersFromDeclaration, getPipesTable, getSymbolQuery } from './src/diagnostics/typescript_symbols';\r\nexport { VERSION } from './src/version';\r\nexport * from './src/metadata';\r\nexport * from './src/transformers/api';\r\nexport * from './src/transformers/entry_points';\r\nexport * from './src/perform_compile';\r\n",
  "/node_modules/@angular/compiler-cli/src/diagnostics/expression_diagnostics.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { AST, Node, TemplateAst, TemplateAstPath } from '@angular/compiler';\r\nimport { DiagnosticKind, ExpressionDiagnosticsContext, TypeDiagnostic } from './expression_type';\r\nimport { Span, SymbolQuery, SymbolTable } from './symbols';\r\nexport interface DiagnosticTemplateInfo {\r\n    fileName?: string;\r\n    offset: number;\r\n    query: SymbolQuery;\r\n    members: SymbolTable;\r\n    htmlAst: Node[];\r\n    templateAst: TemplateAst[];\r\n}\r\nexport interface ExpressionDiagnostic {\r\n    message: string;\r\n    span: Span;\r\n    kind: DiagnosticKind;\r\n}\r\nexport declare function getTemplateExpressionDiagnostics(info: DiagnosticTemplateInfo): ExpressionDiagnostic[];\r\nexport declare function getExpressionDiagnostics(scope: SymbolTable, ast: AST, query: SymbolQuery, context?: ExpressionDiagnosticsContext): TypeDiagnostic[];\r\nexport declare function getExpressionScope(info: DiagnosticTemplateInfo, path: TemplateAstPath, includeEvent: boolean): SymbolTable;\r\n",
  "/node_modules/@angular/compiler-cli/src/diagnostics/expression_type.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { AST, AstVisitor, Binary, BindingPipe, Chain, Conditional, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, NonNullAssert, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead } from '@angular/compiler';\r\nimport { Symbol, SymbolQuery, SymbolTable } from './symbols';\r\nexport interface ExpressionDiagnosticsContext {\r\n    event?: boolean;\r\n}\r\nexport declare enum DiagnosticKind {\r\n    Error = 0,\r\n    Warning = 1\r\n}\r\nexport declare class TypeDiagnostic {\r\n    kind: DiagnosticKind;\r\n    message: string;\r\n    ast: AST;\r\n    constructor(kind: DiagnosticKind, message: string, ast: AST);\r\n}\r\nexport declare class AstType implements AstVisitor {\r\n    private scope;\r\n    private query;\r\n    private context;\r\n    diagnostics: TypeDiagnostic[];\r\n    constructor(scope: SymbolTable, query: SymbolQuery, context: ExpressionDiagnosticsContext);\r\n    getType(ast: AST): Symbol;\r\n    getDiagnostics(ast: AST): TypeDiagnostic[];\r\n    visitBinary(ast: Binary): Symbol;\r\n    visitChain(ast: Chain): Symbol;\r\n    visitConditional(ast: Conditional): Symbol;\r\n    visitFunctionCall(ast: FunctionCall): Symbol;\r\n    visitImplicitReceiver(ast: ImplicitReceiver): Symbol;\r\n    visitInterpolation(ast: Interpolation): Symbol;\r\n    visitKeyedRead(ast: KeyedRead): Symbol;\r\n    visitKeyedWrite(ast: KeyedWrite): Symbol;\r\n    visitLiteralArray(ast: LiteralArray): Symbol;\r\n    visitLiteralMap(ast: LiteralMap): Symbol;\r\n    visitLiteralPrimitive(ast: LiteralPrimitive): Symbol;\r\n    visitMethodCall(ast: MethodCall): Symbol;\r\n    visitPipe(ast: BindingPipe): Symbol;\r\n    visitPrefixNot(ast: PrefixNot): Symbol;\r\n    visitNonNullAssert(ast: NonNullAssert): Symbol;\r\n    visitPropertyRead(ast: PropertyRead): Symbol;\r\n    visitPropertyWrite(ast: PropertyWrite): Symbol;\r\n    visitQuote(ast: Quote): Symbol;\r\n    visitSafeMethodCall(ast: SafeMethodCall): Symbol;\r\n    visitSafePropertyRead(ast: SafePropertyRead): Symbol;\r\n    private _anyType;\r\n    private readonly anyType;\r\n    private _undefinedType;\r\n    private readonly undefinedType;\r\n    private resolveMethodCall;\r\n    private resolvePropertyRead;\r\n    private reportError;\r\n    private reportWarning;\r\n    private isAny;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/diagnostics/symbols.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { StaticSymbol } from '@angular/compiler';\r\n/**\r\n * The range of a span of text in a source file.\r\n *\r\n * @experimental\r\n */\r\nexport interface Span {\r\n    /**\r\n     * The first code-point of the span as an offset relative to the beginning of the source assuming\r\n     * a UTF-16 encoding.\r\n     */\r\n    start: number;\r\n    /**\r\n     * The first code-point after the span as an offset relative to the beginning of the source\r\n     * assuming a UTF-16 encoding.\r\n     */\r\n    end: number;\r\n}\r\n/**\r\n * A file and span.\r\n */\r\nexport interface Location {\r\n    fileName: string;\r\n    span: Span;\r\n}\r\n/**\r\n * A defnition location(s).\r\n */\r\nexport declare type Definition = Location[] | undefined;\r\n/**\r\n * A symbol describing a language element that can be referenced by expressions\r\n * in an Angular template.\r\n *\r\n * @experimental\r\n */\r\nexport interface Symbol {\r\n    /**\r\n     * The name of the symbol as it would be referenced in an Angular expression.\r\n     */\r\n    readonly name: string;\r\n    /**\r\n     * The kind of completion this symbol should generate if included.\r\n     */\r\n    readonly kind: string;\r\n    /**\r\n     * The language of the source that defines the symbol. (e.g. typescript for TypeScript,\r\n     * ng-template for an Angular template, etc.)\r\n     */\r\n    readonly language: string;\r\n    /**\r\n     * A symbol representing type of the symbol.\r\n     */\r\n    readonly type: Symbol | undefined;\r\n    /**\r\n     * A symbol for the container of this symbol. For example, if this is a method, the container\r\n     * is the class or interface of the method. If no container is appropriate, undefined is\r\n     * returned.\r\n     */\r\n    readonly container: Symbol | undefined;\r\n    /**\r\n     * The symbol is public in the container.\r\n     */\r\n    readonly public: boolean;\r\n    /**\r\n     * `true` if the symbol can be the target of a call.\r\n     */\r\n    readonly callable: boolean;\r\n    /**\r\n     * The location of the definition of the symbol\r\n     */\r\n    readonly definition: Definition | undefined;\r\n    /**\r\n     * `true` if the symbol is a type that is nullable (can be null or undefined).\r\n     */\r\n    readonly nullable: boolean;\r\n    /**\r\n     * A table of the members of the symbol; that is, the members that can appear\r\n     * after a `.` in an Angular expression.\r\n     */\r\n    members(): SymbolTable;\r\n    /**\r\n     * The list of overloaded signatures that can be used if the symbol is the\r\n     * target of a call.\r\n     */\r\n    signatures(): Signature[];\r\n    /**\r\n     * Return which signature of returned by `signatures()` would be used selected\r\n     * given the `types` supplied. If no signature would match, this method should\r\n     * return `undefined`.\r\n     */\r\n    selectSignature(types: Symbol[]): Signature | undefined;\r\n    /**\r\n     * Return the type of the expression if this symbol is indexed by `argument`.\r\n     * If the symbol cannot be indexed, this method should return `undefined`.\r\n     */\r\n    indexed(argument: Symbol): Symbol | undefined;\r\n}\r\n/**\r\n * A table of `Symbol`s accessible by name.\r\n *\r\n * @experimental\r\n */\r\nexport interface SymbolTable {\r\n    /**\r\n     * The number of symbols in the table.\r\n     */\r\n    readonly size: number;\r\n    /**\r\n     * Get the symbol corresponding to `key` or `undefined` if there is no symbol in the\r\n     * table by the name `key`.\r\n     */\r\n    get(key: string): Symbol | undefined;\r\n    /**\r\n     * Returns `true` if the table contains a `Symbol` with the name `key`.\r\n     */\r\n    has(key: string): boolean;\r\n    /**\r\n     * Returns all the `Symbol`s in the table. The order should be, but is not required to be,\r\n     * in declaration order.\r\n     */\r\n    values(): Symbol[];\r\n}\r\n/**\r\n * A description of a function or method signature.\r\n *\r\n * @experimental\r\n */\r\nexport interface Signature {\r\n    /**\r\n     * The arguments of the signture. The order of `arguments.symbols()` must be in the order\r\n     * of argument declaration.\r\n     */\r\n    readonly arguments: SymbolTable;\r\n    /**\r\n     * The symbol of the signature result type.\r\n     */\r\n    readonly result: Symbol;\r\n}\r\n/**\r\n * An enumeration of basic types.\r\n *\r\n * @experimental\r\n */\r\nexport declare enum BuiltinType {\r\n    /**\r\n     * The type is a type that can hold any other type.\r\n     */\r\n    Any = 0,\r\n    /**\r\n     * The type of a string literal.\r\n     */\r\n    String = 1,\r\n    /**\r\n     * The type of a numeric literal.\r\n     */\r\n    Number = 2,\r\n    /**\r\n     * The type of the `true` and `false` literals.\r\n     */\r\n    Boolean = 3,\r\n    /**\r\n     * The type of the `undefined` literal.\r\n     */\r\n    Undefined = 4,\r\n    /**\r\n     * the type of the `null` literal.\r\n     */\r\n    Null = 5,\r\n    /**\r\n     * the type is an unbound type parameter.\r\n     */\r\n    Unbound = 6,\r\n    /**\r\n     * Not a built-in type.\r\n     */\r\n    Other = 7\r\n}\r\n/**\r\n * The kinds of definition.\r\n *\r\n * @experimental\r\n */\r\nexport declare type DeclarationKind = 'attribute' | 'html attribute' | 'component' | 'element' | 'entity' | 'key' | 'method' | 'pipe' | 'property' | 'type' | 'reference' | 'variable';\r\n/**\r\n * Describes a symbol to type binding used to build a symbol table.\r\n *\r\n * @experimental\r\n */\r\nexport interface SymbolDeclaration {\r\n    /**\r\n     * The name of the symbol in table.\r\n     */\r\n    readonly name: string;\r\n    /**\r\n     * The kind of symbol to declare.\r\n     */\r\n    readonly kind: DeclarationKind;\r\n    /**\r\n     * Type of the symbol. The type symbol should refer to a symbol for a type.\r\n     */\r\n    readonly type: Symbol;\r\n    /**\r\n     * The definion of the symbol if one exists.\r\n     */\r\n    readonly definition?: Definition;\r\n}\r\n/**\r\n * Information about the pipes that are available for use in a template.\r\n *\r\n * @experimental\r\n */\r\nexport interface PipeInfo {\r\n    /**\r\n     * The name of the pipe.\r\n     */\r\n    name: string;\r\n    /**\r\n     * The static symbol for the pipe's constructor.\r\n     */\r\n    symbol: StaticSymbol;\r\n}\r\n/**\r\n * A sequence of pipe information.\r\n *\r\n * @experimental\r\n */\r\nexport declare type Pipes = PipeInfo[] | undefined;\r\n/**\r\n * Describes the language context in which an Angular expression is evaluated.\r\n *\r\n * @experimental\r\n */\r\nexport interface SymbolQuery {\r\n    /**\r\n     * Return the built-in type this symbol represents or Other if it is not a built-in type.\r\n     */\r\n    getTypeKind(symbol: Symbol): BuiltinType;\r\n    /**\r\n     * Return a symbol representing the given built-in type.\r\n     */\r\n    getBuiltinType(kind: BuiltinType): Symbol;\r\n    /**\r\n     * Return the symbol for a type that represents the union of all the types given. Any value\r\n     * of one of the types given should be assignable to the returned type. If no one type can\r\n     * be constructed then this should be the Any type.\r\n     */\r\n    getTypeUnion(...types: Symbol[]): Symbol;\r\n    /**\r\n     * Return a symbol for an array type that has the `type` as its element type.\r\n     */\r\n    getArrayType(type: Symbol): Symbol;\r\n    /**\r\n     * Return element type symbol for an array type if the `type` is an array type. Otherwise return\r\n     * undefined.\r\n     */\r\n    getElementType(type: Symbol): Symbol | undefined;\r\n    /**\r\n     * Return a type that is the non-nullable version of the given type. If `type` is already\r\n     * non-nullable, return `type`.\r\n     */\r\n    getNonNullableType(type: Symbol): Symbol;\r\n    /**\r\n     * Return a symbol table for the pipes that are in scope.\r\n     */\r\n    getPipes(): SymbolTable;\r\n    /**\r\n     * Return the type symbol for the given static symbol.\r\n     */\r\n    getTypeSymbol(type: StaticSymbol): Symbol | undefined;\r\n    /**\r\n     * Return the members that are in the context of a type's template reference.\r\n     */\r\n    getTemplateContext(type: StaticSymbol): SymbolTable | undefined;\r\n    /**\r\n     * Produce a symbol table with the given symbols. Used to produce a symbol table\r\n     * for use with mergeSymbolTables().\r\n     */\r\n    createSymbolTable(symbols: SymbolDeclaration[]): SymbolTable;\r\n    /**\r\n     * Produce a merged symbol table. If the symbol tables contain duplicate entries\r\n     * the entries of the latter symbol tables will obscure the entries in the prior\r\n     * symbol tables.\r\n     *\r\n     * The symbol tables passed to this routine MUST be produces by the same instance\r\n     * of SymbolQuery that is being called.\r\n     */\r\n    mergeSymbolTable(symbolTables: SymbolTable[]): SymbolTable;\r\n    /**\r\n     * Return the span of the narrowest non-token node at the given location.\r\n     */\r\n    getSpanAt(line: number, column: number): Span | undefined;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/diagnostics/translate_diagnostics.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ParseSourceSpan } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { Diagnostic } from '../transformers/api';\r\nexport interface TypeCheckHost {\r\n    parseSourceSpanOf(fileName: string, line: number, character: number): ParseSourceSpan | null;\r\n}\r\nexport declare function translateDiagnostics(host: TypeCheckHost, untranslatedDiagnostics: ReadonlyArray<ts.Diagnostic>): {\r\n    ts: ts.Diagnostic[];\r\n    ng: Diagnostic[];\r\n};\r\n",
  "/node_modules/@angular/compiler-cli/src/diagnostics/typescript_symbols.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CompilePipeSummary, StaticSymbol } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { SymbolQuery, SymbolTable } from './symbols';\r\nexport declare function getSymbolQuery(program: ts.Program, checker: ts.TypeChecker, source: ts.SourceFile, fetchPipes: () => SymbolTable): SymbolQuery;\r\nexport declare function getClassMembers(program: ts.Program, checker: ts.TypeChecker, staticSymbol: StaticSymbol): SymbolTable | undefined;\r\nexport declare function getClassMembersFromDeclaration(program: ts.Program, checker: ts.TypeChecker, source: ts.SourceFile, declaration: ts.ClassDeclaration): SymbolTable;\r\nexport declare function getClassFromStaticSymbol(program: ts.Program, type: StaticSymbol): ts.ClassDeclaration | undefined;\r\nexport declare function getPipesTable(source: ts.SourceFile, program: ts.Program, checker: ts.TypeChecker, pipes: CompilePipeSummary[]): SymbolTable;\r\nexport declare const toSymbolTableFactory: (tsVersion: string) => (symbols: ts.Symbol[]) => ts.UnderscoreEscapedMap<ts.Symbol>;\r\n",
  "/node_modules/@angular/compiler-cli/src/diagnostics/typescript_version.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Converts a `string` version into an array of numbers\r\n * @example\r\n * toNumbers('2.0.1'); // returns [2, 0, 1]\r\n */\r\nexport declare function toNumbers(value: string): number[];\r\n/**\r\n * Compares two arrays of positive numbers with lexicographical order in mind.\r\n *\r\n * However - unlike lexicographical order - for arrays of different length we consider:\r\n * [1, 2, 3] = [1, 2, 3, 0] instead of [1, 2, 3] < [1, 2, 3, 0]\r\n *\r\n * @param a The 'left hand' array in the comparison test\r\n * @param b The 'right hand' in the comparison test\r\n * @returns {-1|0|1} The comparison result: 1 if a is greater, -1 if b is greater, 0 is the two\r\n * arrays are equals\r\n */\r\nexport declare function compareNumbers(a: number[], b: number[]): -1 | 0 | 1;\r\n/**\r\n * Checks if a TypeScript version is:\r\n * - greater or equal than the provided `low` version,\r\n * - lower or equal than an optional `high` version.\r\n *\r\n * @param version The TypeScript version\r\n * @param low The minimum version\r\n * @param high The maximum version\r\n */\r\nexport declare function isVersionBetween(version: string, low: string, high?: string): boolean;\r\n/**\r\n * Compares two versions\r\n *\r\n * @param v1 The 'left hand' version in the comparison test\r\n * @param v2 The 'right hand' version in the comparison test\r\n * @returns {-1|0|1} The comparison result: 1 if v1 is greater, -1 if v2 is greater, 0 is the two\r\n * versions are equals\r\n */\r\nexport declare function compareVersions(v1: string, v2: string): -1 | 0 | 1;\r\n",
  "/node_modules/@angular/compiler-cli/src/metadata/bundler.d.ts": "import * as ts from 'typescript';\r\nimport { MetadataCache } from '../transformers/metadata_cache';\r\nimport { MetadataEntry, ModuleMetadata } from './schema';\r\nexport interface BundleEntries {\r\n    [name: string]: MetadataEntry;\r\n}\r\nexport interface BundlePrivateEntry {\r\n    privateName: string;\r\n    name: string;\r\n    module: string;\r\n}\r\nexport interface BundledModule {\r\n    metadata: ModuleMetadata;\r\n    privates: BundlePrivateEntry[];\r\n}\r\nexport interface MetadataBundlerHost {\r\n    getMetadataFor(moduleName: string, containingFile: string): ModuleMetadata | undefined;\r\n}\r\nexport declare class MetadataBundler {\r\n    private root;\r\n    private importAs;\r\n    private host;\r\n    private symbolMap;\r\n    private metadataCache;\r\n    private exports;\r\n    private rootModule;\r\n    private privateSymbolPrefix;\r\n    private exported;\r\n    constructor(root: string, importAs: string | undefined, host: MetadataBundlerHost, privateSymbolPrefix?: string);\r\n    getMetadataBundle(): BundledModule;\r\n    static resolveModule(importName: string, from: string): string;\r\n    private getMetadata;\r\n    private exportAll;\r\n    /**\r\n     * Fill in the canonicalSymbol which is the symbol that should be imported by factories.\r\n     * The canonical symbol is the one exported by the index file for the bundle or definition\r\n     * symbol for private symbols that are not exported by bundle index.\r\n     */\r\n    private canonicalizeSymbols;\r\n    private canonicalizeSymbol;\r\n    private getEntries;\r\n    private getReExports;\r\n    private convertSymbol;\r\n    private convertEntry;\r\n    private convertClass;\r\n    private convertMembers;\r\n    private convertMember;\r\n    private convertStatics;\r\n    private convertFunction;\r\n    private convertValue;\r\n    private convertExpression;\r\n    private convertError;\r\n    private convertReference;\r\n    private convertExpressionNode;\r\n    private symbolOf;\r\n    private canonicalSymbolOf;\r\n}\r\nexport declare class CompilerHostAdapter implements MetadataBundlerHost {\r\n    private host;\r\n    private cache;\r\n    private options;\r\n    private collector;\r\n    constructor(host: ts.CompilerHost, cache: MetadataCache | null, options: ts.CompilerOptions);\r\n    getMetadataFor(fileName: string, containingFile: string): ModuleMetadata | undefined;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/metadata/bundle_index_host.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nimport { CompilerOptions } from '../transformers/api';\r\nimport { MetadataCache } from '../transformers/metadata_cache';\r\nexport declare function createBundleIndexHost<H extends ts.CompilerHost>(ngOptions: CompilerOptions, rootFiles: ReadonlyArray<string>, host: H, getMetadataCache: () => MetadataCache): {\r\n    host: H;\r\n    indexName?: string;\r\n    errors?: ts.Diagnostic[];\r\n};\r\n",
  "/node_modules/@angular/compiler-cli/src/metadata/collector.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nimport { MetadataValue, ModuleMetadata } from './schema';\r\n/**\r\n * A set of collector options to use when collecting metadata.\r\n */\r\nexport interface CollectorOptions {\r\n    /**\r\n     * Version of the metadata to collect.\r\n     */\r\n    version?: number;\r\n    /**\r\n     * Collect a hidden field \"$quoted$\" in objects literals that record when the key was quoted in\r\n     * the source.\r\n     */\r\n    quotedNames?: boolean;\r\n    /**\r\n     * Do not simplify invalid expressions.\r\n     */\r\n    verboseInvalidExpression?: boolean;\r\n    /**\r\n     * An expression substitution callback.\r\n     */\r\n    substituteExpression?: (value: MetadataValue, node: ts.Node) => MetadataValue;\r\n}\r\n/**\r\n * Collect decorator metadata from a TypeScript module.\r\n */\r\nexport declare class MetadataCollector {\r\n    private options;\r\n    constructor(options?: CollectorOptions);\r\n    /**\r\n     * Returns a JSON.stringify friendly form describing the decorators of the exported classes from\r\n     * the source file that is expected to correspond to a module.\r\n     */\r\n    getMetadata(sourceFile: ts.SourceFile, strict?: boolean, substituteExpression?: (value: MetadataValue, node: ts.Node) => MetadataValue): ModuleMetadata | undefined;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/metadata/evaluator.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nimport { CollectorOptions } from './collector';\r\nimport { ClassMetadata, FunctionMetadata, InterfaceMetadata, MetadataEntry, MetadataError, MetadataSourceLocationInfo, MetadataValue } from './schema';\r\nimport { Symbols } from './symbols';\r\nexport declare function recordMapEntry<T extends MetadataEntry>(entry: T, node: ts.Node, nodeMap: Map<MetadataValue | ClassMetadata | InterfaceMetadata | FunctionMetadata, ts.Node>, sourceFile?: ts.SourceFile): T;\r\nexport declare function isPrimitive(value: any): boolean;\r\nexport interface ImportSpecifierMetadata {\r\n    name: string;\r\n    propertyName?: string;\r\n}\r\nexport interface ImportMetadata {\r\n    defaultName?: string;\r\n    namespace?: string;\r\n    namedImports?: ImportSpecifierMetadata[];\r\n    from: string;\r\n}\r\nexport declare function sourceInfo(node: ts.Node | undefined, sourceFile: ts.SourceFile | undefined): MetadataSourceLocationInfo;\r\nexport declare function errorSymbol(message: string, node?: ts.Node, context?: {\r\n    [name: string]: string;\r\n}, sourceFile?: ts.SourceFile): MetadataError;\r\n/**\r\n * Produce a symbolic representation of an expression folding values into their final value when\r\n * possible.\r\n */\r\nexport declare class Evaluator {\r\n    private symbols;\r\n    private nodeMap;\r\n    private options;\r\n    private recordExport?;\r\n    constructor(symbols: Symbols, nodeMap: Map<MetadataEntry, ts.Node>, options?: CollectorOptions, recordExport?: (name: string, value: MetadataValue) => void);\r\n    nameOf(node: ts.Node | undefined): string | MetadataError;\r\n    /**\r\n     * Returns true if the expression represented by `node` can be folded into a literal expression.\r\n     *\r\n     * For example, a literal is always foldable. This means that literal expressions such as `1.2`\r\n     * `\"Some value\"` `true` `false` are foldable.\r\n     *\r\n     * - An object literal is foldable if all the properties in the literal are foldable.\r\n     * - An array literal is foldable if all the elements are foldable.\r\n     * - A call is foldable if it is a call to a Array.prototype.concat or a call to CONST_EXPR.\r\n     * - A property access is foldable if the object is foldable.\r\n     * - A array index is foldable if index expression is foldable and the array is foldable.\r\n     * - Binary operator expressions are foldable if the left and right expressions are foldable and\r\n     *   it is one of '+', '-', '*', '/', '%', '||', and '&&'.\r\n     * - An identifier is foldable if a value can be found for its symbol in the evaluator symbol\r\n     *   table.\r\n     */\r\n    isFoldable(node: ts.Node): boolean;\r\n    private isFoldableWorker;\r\n    /**\r\n     * Produce a JSON serialiable object representing `node`. The foldable values in the expression\r\n     * tree are folded. For example, a node representing `1 + 2` is folded into `3`.\r\n     */\r\n    evaluateNode(node: ts.Node, preferReference?: boolean): MetadataValue;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/metadata/index.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport * from './collector';\r\nexport * from './schema';\r\nexport * from './bundle_index_host';\r\n",
  "/node_modules/@angular/compiler-cli/src/metadata/index_writer.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { BundlePrivateEntry } from './bundler';\r\nexport declare function privateEntriesToIndex(index: string, privates: BundlePrivateEntry[]): string;\r\n",
  "/node_modules/@angular/compiler-cli/src/metadata/schema.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare const METADATA_VERSION = 4;\r\nexport declare type MetadataEntry = ClassMetadata | InterfaceMetadata | FunctionMetadata | MetadataValue;\r\nexport interface ModuleMetadata {\r\n    __symbolic: 'module';\r\n    version: number;\r\n    exports?: ModuleExportMetadata[];\r\n    importAs?: string;\r\n    metadata: {\r\n        [name: string]: MetadataEntry;\r\n    };\r\n    origins?: {\r\n        [name: string]: string;\r\n    };\r\n}\r\nexport declare function isModuleMetadata(value: any): value is ModuleMetadata;\r\nexport interface ModuleExportMetadata {\r\n    export?: (string | {\r\n        name: string;\r\n        as: string;\r\n    })[];\r\n    from: string;\r\n}\r\nexport interface ClassMetadata {\r\n    __symbolic: 'class';\r\n    extends?: MetadataSymbolicExpression | MetadataError;\r\n    arity?: number;\r\n    decorators?: (MetadataSymbolicExpression | MetadataError)[];\r\n    members?: MetadataMap;\r\n    statics?: {\r\n        [name: string]: MetadataValue | FunctionMetadata;\r\n    };\r\n}\r\nexport declare function isClassMetadata(value: any): value is ClassMetadata;\r\nexport interface InterfaceMetadata {\r\n    __symbolic: 'interface';\r\n}\r\nexport declare function isInterfaceMetadata(value: any): value is InterfaceMetadata;\r\nexport interface MetadataMap {\r\n    [name: string]: MemberMetadata[];\r\n}\r\nexport interface MemberMetadata {\r\n    __symbolic: 'constructor' | 'method' | 'property';\r\n    decorators?: (MetadataSymbolicExpression | MetadataError)[];\r\n}\r\nexport declare function isMemberMetadata(value: any): value is MemberMetadata;\r\nexport interface MethodMetadata extends MemberMetadata {\r\n    __symbolic: 'constructor' | 'method';\r\n    parameterDecorators?: ((MetadataSymbolicExpression | MetadataError)[] | undefined)[];\r\n}\r\nexport declare function isMethodMetadata(value: any): value is MethodMetadata;\r\nexport interface ConstructorMetadata extends MethodMetadata {\r\n    __symbolic: 'constructor';\r\n    parameters?: (MetadataSymbolicExpression | MetadataError | null | undefined)[];\r\n}\r\nexport declare function isConstructorMetadata(value: any): value is ConstructorMetadata;\r\nexport interface FunctionMetadata {\r\n    __symbolic: 'function';\r\n    parameters: string[];\r\n    defaults?: MetadataValue[];\r\n    value: MetadataValue;\r\n}\r\nexport declare function isFunctionMetadata(value: any): value is FunctionMetadata;\r\nexport declare type MetadataValue = string | number | boolean | undefined | null | MetadataObject | MetadataArray | MetadataSymbolicExpression | MetadataSymbolicReferenceExpression | MetadataSymbolicBinaryExpression | MetadataSymbolicIndexExpression | MetadataSymbolicCallExpression | MetadataSymbolicPrefixExpression | MetadataSymbolicIfExpression | MetadataSymbolicSpreadExpression | MetadataSymbolicSelectExpression | MetadataError;\r\nexport interface MetadataObject {\r\n    [name: string]: MetadataValue;\r\n}\r\nexport interface MetadataArray {\r\n    [name: number]: MetadataValue;\r\n}\r\nexport declare type MetadataSymbolicExpression = MetadataSymbolicBinaryExpression | MetadataSymbolicIndexExpression | MetadataSymbolicIndexExpression | MetadataSymbolicCallExpression | MetadataSymbolicCallExpression | MetadataSymbolicPrefixExpression | MetadataSymbolicIfExpression | MetadataGlobalReferenceExpression | MetadataModuleReferenceExpression | MetadataImportedSymbolReferenceExpression | MetadataImportedDefaultReferenceExpression | MetadataSymbolicSelectExpression | MetadataSymbolicSpreadExpression;\r\nexport declare function isMetadataSymbolicExpression(value: any): value is MetadataSymbolicExpression;\r\nexport interface MetadataSymbolicBinaryExpression {\r\n    __symbolic: 'binary';\r\n    operator: '&&' | '||' | '|' | '^' | '&' | '==' | '!=' | '===' | '!==' | '<' | '>' | '<=' | '>=' | 'instanceof' | 'in' | 'as' | '<<' | '>>' | '>>>' | '+' | '-' | '*' | '/' | '%' | '**';\r\n    left: MetadataValue;\r\n    right: MetadataValue;\r\n}\r\nexport declare function isMetadataSymbolicBinaryExpression(value: any): value is MetadataSymbolicBinaryExpression;\r\nexport interface MetadataSymbolicIndexExpression {\r\n    __symbolic: 'index';\r\n    expression: MetadataValue;\r\n    index: MetadataValue;\r\n}\r\nexport declare function isMetadataSymbolicIndexExpression(value: any): value is MetadataSymbolicIndexExpression;\r\nexport interface MetadataSymbolicCallExpression {\r\n    __symbolic: 'call' | 'new';\r\n    expression: MetadataValue;\r\n    arguments?: MetadataValue[];\r\n}\r\nexport declare function isMetadataSymbolicCallExpression(value: any): value is MetadataSymbolicCallExpression;\r\nexport interface MetadataSymbolicPrefixExpression {\r\n    __symbolic: 'pre';\r\n    operator: '+' | '-' | '~' | '!';\r\n    operand: MetadataValue;\r\n}\r\nexport declare function isMetadataSymbolicPrefixExpression(value: any): value is MetadataSymbolicPrefixExpression;\r\nexport interface MetadataSymbolicIfExpression {\r\n    __symbolic: 'if';\r\n    condition: MetadataValue;\r\n    thenExpression: MetadataValue;\r\n    elseExpression: MetadataValue;\r\n}\r\nexport declare function isMetadataSymbolicIfExpression(value: any): value is MetadataSymbolicIfExpression;\r\nexport interface MetadataSourceLocationInfo {\r\n    /**\r\n     * The line number of the error in the .ts file the metadata was created for.\r\n     */\r\n    line?: number;\r\n    /**\r\n     * The number of utf8 code-units from the beginning of the file of the error.\r\n     */\r\n    character?: number;\r\n}\r\nexport interface MetadataGlobalReferenceExpression extends MetadataSourceLocationInfo {\r\n    __symbolic: 'reference';\r\n    name: string;\r\n    arguments?: MetadataValue[];\r\n}\r\nexport declare function isMetadataGlobalReferenceExpression(value: any): value is MetadataGlobalReferenceExpression;\r\nexport interface MetadataModuleReferenceExpression extends MetadataSourceLocationInfo {\r\n    __symbolic: 'reference';\r\n    module: string;\r\n}\r\nexport declare function isMetadataModuleReferenceExpression(value: any): value is MetadataModuleReferenceExpression;\r\nexport interface MetadataImportedSymbolReferenceExpression extends MetadataSourceLocationInfo {\r\n    __symbolic: 'reference';\r\n    module: string;\r\n    name: string;\r\n    arguments?: MetadataValue[];\r\n}\r\nexport declare function isMetadataImportedSymbolReferenceExpression(value: any): value is MetadataImportedSymbolReferenceExpression;\r\nexport interface MetadataImportedDefaultReferenceExpression extends MetadataSourceLocationInfo {\r\n    __symbolic: 'reference';\r\n    module: string;\r\n    default: boolean;\r\n    arguments?: MetadataValue[];\r\n}\r\nexport declare function isMetadataImportDefaultReference(value: any): value is MetadataImportedDefaultReferenceExpression;\r\nexport declare type MetadataSymbolicReferenceExpression = MetadataGlobalReferenceExpression | MetadataModuleReferenceExpression | MetadataImportedSymbolReferenceExpression | MetadataImportedDefaultReferenceExpression;\r\nexport declare function isMetadataSymbolicReferenceExpression(value: any): value is MetadataSymbolicReferenceExpression;\r\nexport interface MetadataSymbolicSelectExpression {\r\n    __symbolic: 'select';\r\n    expression: MetadataValue;\r\n    member: string;\r\n}\r\nexport declare function isMetadataSymbolicSelectExpression(value: any): value is MetadataSymbolicSelectExpression;\r\nexport interface MetadataSymbolicSpreadExpression {\r\n    __symbolic: 'spread';\r\n    expression: MetadataValue;\r\n}\r\nexport declare function isMetadataSymbolicSpreadExpression(value: any): value is MetadataSymbolicSpreadExpression;\r\nexport interface MetadataError extends MetadataSourceLocationInfo {\r\n    __symbolic: 'error';\r\n    /**\r\n     * This message should be short and relatively discriptive and should be fixed once it is created.\r\n     * If the reader doesn't recognize the message, it will display the message unmodified. If the\r\n     * reader recognizes the error message is it free to use substitute message the is more\r\n     * descriptive and/or localized.\r\n     */\r\n    message: string;\r\n    /**\r\n     * The module of the error (only used in bundled metadata)\r\n     */\r\n    module?: string;\r\n    /**\r\n     * Context information that can be used to generate a more descriptive error message. The content\r\n     * of the context is dependent on the error message.\r\n     */\r\n    context?: {\r\n        [name: string]: string;\r\n    };\r\n}\r\nexport declare function isMetadataError(value: any): value is MetadataError;\r\n",
  "/node_modules/@angular/compiler-cli/src/metadata/symbols.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nimport { MetadataSymbolicReferenceExpression, MetadataValue } from './schema';\r\nexport declare class Symbols {\r\n    private sourceFile;\r\n    private _symbols;\r\n    private references;\r\n    constructor(sourceFile: ts.SourceFile);\r\n    resolve(name: string, preferReference?: boolean): MetadataValue | undefined;\r\n    define(name: string, value: MetadataValue): void;\r\n    defineReference(name: string, value: MetadataSymbolicReferenceExpression): void;\r\n    has(name: string): boolean;\r\n    private readonly symbols;\r\n    private buildImports;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/annotations/index.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { ResourceLoader } from './src/api';\r\nexport { BaseDefDecoratorHandler } from './src/base_def';\r\nexport { ComponentDecoratorHandler } from './src/component';\r\nexport { DirectiveDecoratorHandler } from './src/directive';\r\nexport { InjectableDecoratorHandler } from './src/injectable';\r\nexport { NgModuleDecoratorHandler } from './src/ng_module';\r\nexport { PipeDecoratorHandler } from './src/pipe';\r\nexport { CompilationScope, SelectorScopeRegistry } from './src/selector_scope';\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/annotations/src/api.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport interface ResourceLoader {\r\n    preload?(url: string): Promise<void> | undefined;\r\n    load(url: string): string;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/annotations/src/base_def.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { R3BaseRefMetaData } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { ClassMember, Decorator, ReflectionHost } from '../../host';\r\nimport { AnalysisOutput, CompileResult, DecoratorHandler } from '../../transform';\r\nexport declare class BaseDefDecoratorHandler implements DecoratorHandler<R3BaseRefMetaData, R3BaseRefDecoratorDetection> {\r\n    private checker;\r\n    private reflector;\r\n    constructor(checker: ts.TypeChecker, reflector: ReflectionHost);\r\n    detect(node: ts.ClassDeclaration, decorators: Decorator[] | null): R3BaseRefDecoratorDetection | undefined;\r\n    analyze(node: ts.ClassDeclaration, metadata: R3BaseRefDecoratorDetection): AnalysisOutput<R3BaseRefMetaData>;\r\n    compile(node: ts.Declaration, analysis: R3BaseRefMetaData): CompileResult[] | CompileResult;\r\n}\r\nexport interface R3BaseRefDecoratorDetection {\r\n    inputs?: Array<{\r\n        property: ClassMember;\r\n        decorator: Decorator;\r\n    }>;\r\n    outputs?: Array<{\r\n        property: ClassMember;\r\n        decorator: Decorator;\r\n    }>;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/annotations/src/component.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ConstantPool, R3ComponentMetadata } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { Decorator, ReflectionHost } from '../../host';\r\nimport { AnalysisOutput, CompileResult, DecoratorHandler } from '../../transform';\r\nimport { ResourceLoader } from './api';\r\nimport { SelectorScopeRegistry } from './selector_scope';\r\n/**\r\n * `DecoratorHandler` which handles the `@Component` annotation.\r\n */\r\nexport declare class ComponentDecoratorHandler implements DecoratorHandler<R3ComponentMetadata, Decorator> {\r\n    private checker;\r\n    private reflector;\r\n    private scopeRegistry;\r\n    private isCore;\r\n    private resourceLoader;\r\n    private rootDirs;\r\n    constructor(checker: ts.TypeChecker, reflector: ReflectionHost, scopeRegistry: SelectorScopeRegistry, isCore: boolean, resourceLoader: ResourceLoader, rootDirs: string[]);\r\n    private literalCache;\r\n    detect(node: ts.Declaration, decorators: Decorator[] | null): Decorator | undefined;\r\n    preanalyze(node: ts.ClassDeclaration, decorator: Decorator): Promise<void> | undefined;\r\n    analyze(node: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<R3ComponentMetadata>;\r\n    compile(node: ts.ClassDeclaration, analysis: R3ComponentMetadata, pool: ConstantPool): CompileResult;\r\n    private _resolveLiteral;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/annotations/src/directive.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ConstantPool, R3DirectiveMetadata, R3QueryMetadata } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { ClassMember, Decorator, ReflectionHost } from '../../host';\r\nimport { AnalysisOutput, CompileResult, DecoratorHandler } from '../../transform';\r\nimport { SelectorScopeRegistry } from './selector_scope';\r\nexport declare class DirectiveDecoratorHandler implements DecoratorHandler<R3DirectiveMetadata, Decorator> {\r\n    private checker;\r\n    private reflector;\r\n    private scopeRegistry;\r\n    private isCore;\r\n    constructor(checker: ts.TypeChecker, reflector: ReflectionHost, scopeRegistry: SelectorScopeRegistry, isCore: boolean);\r\n    detect(node: ts.Declaration, decorators: Decorator[] | null): Decorator | undefined;\r\n    analyze(node: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<R3DirectiveMetadata>;\r\n    compile(node: ts.ClassDeclaration, analysis: R3DirectiveMetadata, pool: ConstantPool): CompileResult;\r\n}\r\n/**\r\n * Helper function to extract metadata from a `Directive` or `Component`.\r\n */\r\nexport declare function extractDirectiveMetadata(clazz: ts.ClassDeclaration, decorator: Decorator, checker: ts.TypeChecker, reflector: ReflectionHost, isCore: boolean): {\r\n    decorator: Map<string, ts.Expression>;\r\n    metadata: R3DirectiveMetadata;\r\n    decoratedElements: ClassMember[];\r\n} | undefined;\r\nexport declare function extractQueryMetadata(exprNode: ts.Node, name: string, args: ReadonlyArray<ts.Expression>, propertyName: string, reflector: ReflectionHost, checker: ts.TypeChecker): R3QueryMetadata;\r\nexport declare function extractQueriesFromDecorator(queryData: ts.Expression, reflector: ReflectionHost, checker: ts.TypeChecker, isCore: boolean): {\r\n    content: R3QueryMetadata[];\r\n    view: R3QueryMetadata[];\r\n};\r\nexport declare function parseFieldArrayValue(directive: Map<string, ts.Expression>, field: string, reflector: ReflectionHost, checker: ts.TypeChecker): null | string[];\r\nexport declare function queriesFromFields(fields: {\r\n    member: ClassMember;\r\n    decorators: Decorator[];\r\n}[], reflector: ReflectionHost, checker: ts.TypeChecker): R3QueryMetadata[];\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/annotations/src/injectable.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { R3InjectableMetadata } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { Decorator, ReflectionHost } from '../../host';\r\nimport { AnalysisOutput, CompileResult, DecoratorHandler } from '../../transform';\r\n/**\r\n * Adapts the `compileIvyInjectable` compiler for `@Injectable` decorators to the Ivy compiler.\r\n */\r\nexport declare class InjectableDecoratorHandler implements DecoratorHandler<R3InjectableMetadata, Decorator> {\r\n    private reflector;\r\n    private isCore;\r\n    constructor(reflector: ReflectionHost, isCore: boolean);\r\n    detect(node: ts.Declaration, decorators: Decorator[] | null): Decorator | undefined;\r\n    analyze(node: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<R3InjectableMetadata>;\r\n    compile(node: ts.ClassDeclaration, analysis: R3InjectableMetadata): CompileResult;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/annotations/src/ng_module.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { R3InjectorMetadata, R3NgModuleMetadata } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { Decorator, ReflectionHost } from '../../host';\r\nimport { AnalysisOutput, CompileResult, DecoratorHandler } from '../../transform';\r\nimport { SelectorScopeRegistry } from './selector_scope';\r\nexport interface NgModuleAnalysis {\r\n    ngModuleDef: R3NgModuleMetadata;\r\n    ngInjectorDef: R3InjectorMetadata;\r\n}\r\n/**\r\n * Compiles @NgModule annotations to ngModuleDef fields.\r\n *\r\n * TODO(alxhub): handle injector side of things as well.\r\n */\r\nexport declare class NgModuleDecoratorHandler implements DecoratorHandler<NgModuleAnalysis, Decorator> {\r\n    private checker;\r\n    private reflector;\r\n    private scopeRegistry;\r\n    private isCore;\r\n    constructor(checker: ts.TypeChecker, reflector: ReflectionHost, scopeRegistry: SelectorScopeRegistry, isCore: boolean);\r\n    detect(node: ts.Declaration, decorators: Decorator[] | null): Decorator | undefined;\r\n    analyze(node: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<NgModuleAnalysis>;\r\n    compile(node: ts.ClassDeclaration, analysis: NgModuleAnalysis): CompileResult[];\r\n    /**\r\n     * Given a `FunctionDeclaration` or `MethodDeclaration`, check if it is typed as a\r\n     * `ModuleWithProviders` and return an expression referencing the module if available.\r\n     */\r\n    private _extractModuleFromModuleWithProvidersFn;\r\n    /**\r\n     * Compute a list of `Reference`s from a resolved metadata value.\r\n     */\r\n    private resolveTypeList;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/annotations/src/pipe.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { R3PipeMetadata } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { Decorator, ReflectionHost } from '../../host';\r\nimport { AnalysisOutput, CompileResult, DecoratorHandler } from '../../transform';\r\nimport { SelectorScopeRegistry } from './selector_scope';\r\nexport declare class PipeDecoratorHandler implements DecoratorHandler<R3PipeMetadata, Decorator> {\r\n    private checker;\r\n    private reflector;\r\n    private scopeRegistry;\r\n    private isCore;\r\n    constructor(checker: ts.TypeChecker, reflector: ReflectionHost, scopeRegistry: SelectorScopeRegistry, isCore: boolean);\r\n    detect(node: ts.Declaration, decorators: Decorator[] | null): Decorator | undefined;\r\n    analyze(clazz: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<R3PipeMetadata>;\r\n    compile(node: ts.ClassDeclaration, analysis: R3PipeMetadata): CompileResult;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/annotations/src/selector_scope.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Expression } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { ReflectionHost } from '../../host';\r\nimport { Reference } from '../../metadata';\r\n/**\r\n * Metadata extracted for a given NgModule that can be used to compute selector scopes.\r\n */\r\nexport interface ModuleData {\r\n    declarations: Reference[];\r\n    imports: Reference[];\r\n    exports: Reference[];\r\n}\r\n/**\r\n * Transitively expanded maps of directives and pipes visible to a component being compiled in the\r\n * context of some module.\r\n */\r\nexport interface CompilationScope<T> {\r\n    directives: Map<string, T>;\r\n    pipes: Map<string, T>;\r\n    containsForwardDecls?: boolean;\r\n}\r\n/**\r\n * Registry which records and correlates static analysis information of Angular types.\r\n *\r\n * Once a compilation unit's information is fed into the SelectorScopeRegistry, it can be asked to\r\n * produce transitive `CompilationScope`s for components.\r\n */\r\nexport declare class SelectorScopeRegistry {\r\n    private checker;\r\n    private reflector;\r\n    /**\r\n     *  Map of modules declared in the current compilation unit to their (local) metadata.\r\n     */\r\n    private _moduleToData;\r\n    /**\r\n     * Map of modules to their cached `CompilationScope`s.\r\n     */\r\n    private _compilationScopeCache;\r\n    /**\r\n     * Map of components/directives to their selector.\r\n     */\r\n    private _directiveToSelector;\r\n    /**\r\n     * Map of pipes to their name.\r\n     */\r\n    private _pipeToName;\r\n    /**\r\n     * Map of components/directives/pipes to their module.\r\n     */\r\n    private _declararedTypeToModule;\r\n    constructor(checker: ts.TypeChecker, reflector: ReflectionHost);\r\n    /**\r\n     * Register a module's metadata with the registry.\r\n     */\r\n    registerModule(node: ts.Declaration, data: ModuleData): void;\r\n    /**\r\n     * Register the selector of a component or directive with the registry.\r\n     */\r\n    registerSelector(node: ts.Declaration, selector: string): void;\r\n    /**\r\n     * Register the name of a pipe with the registry.\r\n     */\r\n    registerPipe(node: ts.Declaration, name: string): void;\r\n    /**\r\n     * Produce the compilation scope of a component, which is determined by the module that declares\r\n     * it.\r\n     */\r\n    lookupCompilationScope(node: ts.Declaration): CompilationScope<Expression> | null;\r\n    private lookupScopesOrDie;\r\n    /**\r\n     * Lookup `SelectorScopes` for a given module.\r\n     *\r\n     * This function assumes that if the given module was imported from an absolute path\r\n     * (`ngModuleImportedFrom`) then all of its declarations are exported at that same path, as well\r\n     * as imports and exports from other modules that are relatively imported.\r\n     */\r\n    private lookupScopes;\r\n    /**\r\n     * Lookup the selector of a component or directive class.\r\n     *\r\n     * Potentially this class is declared in a .d.ts file or otherwise has a manually created\r\n     * ngComponentDef/ngDirectiveDef. In this case, the type metadata of that definition is read\r\n     * to determine the selector.\r\n     */\r\n    private lookupDirectiveSelector;\r\n    private lookupPipeName;\r\n    /**\r\n     * Read the metadata from a class that has already been compiled somehow (either it's in a .d.ts\r\n     * file, or in a .ts file with a handwritten definition).\r\n     *\r\n     * @param clazz the class of interest\r\n     * @param ngModuleImportedFrom module specifier of the import path to assume for all declarations\r\n     * stemming from this module.\r\n     */\r\n    private _readMetadataFromCompiledClass;\r\n    /**\r\n     * Get the selector from type metadata for a class with a precompiled ngComponentDef or\r\n     * ngDirectiveDef.\r\n     */\r\n    private _readSelectorFromCompiledClass;\r\n    /**\r\n     * Get the selector from type metadata for a class with a precompiled ngComponentDef or\r\n     * ngDirectiveDef.\r\n     */\r\n    private _readNameFromCompiledClass;\r\n    /**\r\n     * Process a `TypeNode` which is a tuple of references to other types, and return `Reference`s to\r\n     * them.\r\n     *\r\n     * This operation assumes that these types should be imported from `ngModuleImportedFrom` unless\r\n     * they themselves were imported from another absolute path.\r\n     */\r\n    private _extractReferencesFromType;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/annotations/src/util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { R3DependencyMetadata, R3Reference } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { Decorator, ReflectionHost } from '../../host';\r\nimport { Reference } from '../../metadata';\r\nexport declare function getConstructorDependencies(clazz: ts.ClassDeclaration, reflector: ReflectionHost, isCore: boolean): R3DependencyMetadata[] | null;\r\nexport declare function toR3Reference(ref: Reference, context: ts.SourceFile): R3Reference;\r\nexport declare function isAngularCore(decorator: Decorator): boolean;\r\n/**\r\n * Unwrap a `ts.Expression`, removing outer type-casts or parentheses until the expression is in its\r\n * lowest level form.\r\n *\r\n * For example, the expression \"(foo as Type)\" unwraps to \"foo\".\r\n */\r\nexport declare function unwrapExpression(node: ts.Expression): ts.Expression;\r\n/**\r\n * Possibly resolve a forwardRef() expression into the inner value.\r\n *\r\n * @param node the forwardRef() expression to resolve\r\n * @param reflector a ReflectionHost\r\n * @returns the resolved expression, if the original expression was a forwardRef(), or the original\r\n * expression otherwise\r\n */\r\nexport declare function unwrapForwardRef(node: ts.Expression, reflector: ReflectionHost): ts.Expression;\r\n/**\r\n * A foreign function resolver for `staticallyResolve` which unwraps forwardRef() expressions.\r\n *\r\n * @param ref a Reference to the declaration of the function being called (which might be\r\n * forwardRef)\r\n * @param args the arguments to the invocation of the forwardRef expression\r\n * @returns an unwrapped argument if `ref` pointed to forwardRef, or null otherwise\r\n */\r\nexport declare function forwardRefResolver(ref: Reference<ts.FunctionDeclaration | ts.MethodDeclaration>, args: ts.Expression[]): ts.Expression | null;\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/diagnostics/index.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { ErrorCode } from './src/code';\r\nexport { FatalDiagnosticError, isFatalDiagnosticError } from './src/error';\r\nexport { replaceTsWithNgInErrors } from './src/util';\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/diagnostics/src/code.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare enum ErrorCode {\r\n    DECORATOR_ARG_NOT_LITERAL = 1001,\r\n    DECORATOR_ARITY_WRONG = 1002,\r\n    DECORATOR_NOT_CALLED = 1003,\r\n    DECORATOR_ON_ANONYMOUS_CLASS = 1004,\r\n    DECORATOR_UNEXPECTED = 1005,\r\n    VALUE_HAS_WRONG_TYPE = 1010,\r\n    VALUE_NOT_LITERAL = 1011,\r\n    COMPONENT_MISSING_TEMPLATE = 2001,\r\n    PIPE_MISSING_NAME = 2002,\r\n    PARAM_MISSING_TOKEN = 2003\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/diagnostics/src/error.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nimport { ErrorCode } from './code';\r\nexport declare class FatalDiagnosticError {\r\n    readonly code: ErrorCode;\r\n    readonly node: ts.Node;\r\n    readonly message: string;\r\n    constructor(code: ErrorCode, node: ts.Node, message: string);\r\n    /**\r\n     * @internal\r\n     */\r\n    _isFatalDiagnosticError: boolean;\r\n    toDiagnostic(): ts.DiagnosticWithLocation;\r\n}\r\nexport declare function isFatalDiagnosticError(err: any): err is FatalDiagnosticError;\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/diagnostics/src/util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare function replaceTsWithNgInErrors(errors: string): string;\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/factories/index.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { FactoryGenerator } from './src/generator';\r\nexport { GeneratedFactoryHostWrapper } from './src/host';\r\nexport { FactoryInfo, generatedFactoryTransform } from './src/transform';\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/factories/src/generator.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\n/**\r\n * Generates ts.SourceFiles which contain variable declarations for NgFactories for every exported\r\n * class of an input ts.SourceFile.\r\n */\r\nexport declare class FactoryGenerator {\r\n    factoryFor(original: ts.SourceFile, genFilePath: string): ts.SourceFile;\r\n    computeFactoryFileMap(files: ReadonlyArray<string>): Map<string, string>;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/factories/src/host.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nimport { FactoryGenerator } from './generator';\r\n/**\r\n * A wrapper around a `ts.CompilerHost` which supports generated files.\r\n */\r\nexport declare class GeneratedFactoryHostWrapper implements ts.CompilerHost {\r\n    private delegate;\r\n    private generator;\r\n    private factoryToSourceMap;\r\n    constructor(delegate: ts.CompilerHost, generator: FactoryGenerator, factoryToSourceMap: Map<string, string>);\r\n    resolveTypeReferenceDirectives?: (names: string[], containingFile: string) => ts.ResolvedTypeReferenceDirective[];\r\n    getSourceFile(fileName: string, languageVersion: ts.ScriptTarget, onError?: ((message: string) => void) | undefined, shouldCreateNewSourceFile?: boolean | undefined): ts.SourceFile | undefined;\r\n    getDefaultLibFileName(options: ts.CompilerOptions): string;\r\n    writeFile(fileName: string, data: string, writeByteOrderMark: boolean, onError: ((message: string) => void) | undefined, sourceFiles: ReadonlyArray<ts.SourceFile>): void;\r\n    getCurrentDirectory(): string;\r\n    getDirectories(path: string): string[];\r\n    getCanonicalFileName(fileName: string): string;\r\n    useCaseSensitiveFileNames(): boolean;\r\n    getNewLine(): string;\r\n    fileExists(fileName: string): boolean;\r\n    readFile(fileName: string): string | undefined;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/factories/src/transform.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nexport interface FactoryInfo {\r\n    sourceFilePath: string;\r\n    moduleSymbolNames: Set<string>;\r\n}\r\nexport declare function generatedFactoryTransform(factoryMap: Map<string, FactoryInfo>, coreImportsFrom: ts.SourceFile | null): ts.TransformerFactory<ts.SourceFile>;\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/host/index.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport * from './src/reflection';\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/host/src/reflection.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\n/**\r\n * Metadata extracted from an instance of a decorator on another declaration.\r\n */\r\nexport interface Decorator {\r\n    /**\r\n     * Name by which the decorator was invoked in the user's code.\r\n     *\r\n     * This is distinct from the name by which the decorator was imported (though in practice they\r\n     * will usually be the same).\r\n     */\r\n    name: string;\r\n    /**\r\n     * `Import` by which the decorator was brought into the module in which it was invoked, or `null`\r\n     * if the decorator was declared in the same module and not imported.\r\n     */\r\n    import: Import | null;\r\n    /**\r\n     * TypeScript reference to the decorator itself.\r\n     */\r\n    node: ts.Node;\r\n    /**\r\n     * Arguments of the invocation of the decorator, if the decorator is invoked, or `null` otherwise.\r\n     */\r\n    args: ts.Expression[] | null;\r\n}\r\n/**\r\n * An enumeration of possible kinds of class members.\r\n */\r\nexport declare enum ClassMemberKind {\r\n    Constructor = 0,\r\n    Getter = 1,\r\n    Setter = 2,\r\n    Property = 3,\r\n    Method = 4\r\n}\r\n/**\r\n * A member of a class, such as a property, method, or constructor.\r\n */\r\nexport interface ClassMember {\r\n    /**\r\n     * TypeScript reference to the class member itself, or null if it is not applicable.\r\n     */\r\n    node: ts.Node | null;\r\n    /**\r\n     * Indication of which type of member this is (property, method, etc).\r\n     */\r\n    kind: ClassMemberKind;\r\n    /**\r\n     * TypeScript `ts.TypeNode` representing the type of the member, or `null` if not present or\r\n     * applicable.\r\n     */\r\n    type: ts.TypeNode | null;\r\n    /**\r\n     * Name of the class member.\r\n     */\r\n    name: string;\r\n    /**\r\n     * TypeScript `ts.Identifier` representing the name of the member, or `null` if no such node\r\n     * is present.\r\n     *\r\n     * The `nameNode` is useful in writing references to this member that will be correctly source-\r\n     * mapped back to the original file.\r\n     */\r\n    nameNode: ts.Identifier | null;\r\n    /**\r\n     * TypeScript `ts.Expression` which represents the value of the member.\r\n     *\r\n     * If the member is a property, this will be the property initializer if there is one, or null\r\n     * otherwise.\r\n     */\r\n    value: ts.Expression | null;\r\n    /**\r\n     * TypeScript `ts.Declaration` which represents the implementation of the member.\r\n     *\r\n     * In TypeScript code this is identical to the node, but in downleveled code this should always be\r\n     * the Declaration which actually represents the member's runtime value.\r\n     *\r\n     * For example, the TS code:\r\n     *\r\n     * ```\r\n     * class Clazz {\r\n     *   static get property(): string {\r\n     *     return 'value';\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * Downlevels to:\r\n     *\r\n     * ```\r\n     * var Clazz = (function () {\r\n     *   function Clazz() {\r\n     *   }\r\n     *   Object.defineProperty(Clazz, \"property\", {\r\n     *       get: function () {\r\n     *           return 'value';\r\n     *       },\r\n     *       enumerable: true,\r\n     *       configurable: true\r\n     *   });\r\n     *   return Clazz;\r\n     * }());\r\n     * ```\r\n     *\r\n     * In this example, for the property \"property\", the node would be the entire\r\n     * Object.defineProperty ExpressionStatement, but the implementation would be this\r\n     * FunctionDeclaration:\r\n     *\r\n     * ```\r\n     * function () {\r\n     *   return 'value';\r\n     * },\r\n     * ```\r\n     */\r\n    implementation: ts.Declaration | null;\r\n    /**\r\n     * Whether the member is static or not.\r\n     */\r\n    isStatic: boolean;\r\n    /**\r\n     * Any `Decorator`s which are present on the member, or `null` if none are present.\r\n     */\r\n    decorators: Decorator[] | null;\r\n}\r\n/**\r\n * A parameter to a constructor.\r\n */\r\nexport interface CtorParameter {\r\n    /**\r\n     * Name of the parameter, if available.\r\n     *\r\n     * Some parameters don't have a simple string name (for example, parameters which are destructured\r\n     * into multiple variables). In these cases, `name` can be `null`.\r\n     */\r\n    name: string | null;\r\n    /**\r\n     * TypeScript `ts.BindingName` representing the name of the parameter.\r\n     *\r\n     * The `nameNode` is useful in writing references to this member that will be correctly source-\r\n     * mapped back to the original file.\r\n     */\r\n    nameNode: ts.BindingName;\r\n    /**\r\n     * TypeScript `ts.Expression` representing the type of the parameter, if the type is a simple\r\n     * expression type.\r\n     *\r\n     * If the type is not present or cannot be represented as an expression, `type` is `null`.\r\n     */\r\n    type: ts.Expression | null;\r\n    /**\r\n     * Any `Decorator`s which are present on the parameter, or `null` if none are present.\r\n     */\r\n    decorators: Decorator[] | null;\r\n}\r\n/**\r\n * Definition of a function or method, including its body if present and any parameters.\r\n *\r\n * In TypeScript code this metadata will be a simple reflection of the declarations in the node\r\n * itself. In ES5 code this can be more complicated, as the default values for parameters may\r\n * be extracted from certain body statements.\r\n */\r\nexport interface FunctionDefinition<T extends ts.MethodDeclaration | ts.FunctionDeclaration | ts.FunctionExpression> {\r\n    /**\r\n     * A reference to the node which declares the function.\r\n     */\r\n    node: T;\r\n    /**\r\n     * Statements of the function body, if a body is present, or null if no body is present.\r\n     *\r\n     * This list may have been filtered to exclude statements which perform parameter default value\r\n     * initialization.\r\n     */\r\n    body: ts.Statement[] | null;\r\n    /**\r\n     * Metadata regarding the function's parameters, including possible default value expressions.\r\n     */\r\n    parameters: Parameter[];\r\n}\r\n/**\r\n * A parameter to a function or method.\r\n */\r\nexport interface Parameter {\r\n    /**\r\n     * Name of the parameter, if available.\r\n     */\r\n    name: string | null;\r\n    /**\r\n     * Declaration which created this parameter.\r\n     */\r\n    node: ts.ParameterDeclaration;\r\n    /**\r\n     * Expression which represents the default value of the parameter, if any.\r\n     */\r\n    initializer: ts.Expression | null;\r\n}\r\n/**\r\n * The source of an imported symbol, including the original symbol name and the module from which it\r\n * was imported.\r\n */\r\nexport interface Import {\r\n    /**\r\n     * The name of the imported symbol under which it was exported (not imported).\r\n     */\r\n    name: string;\r\n    /**\r\n     * The module from which the symbol was imported.\r\n     *\r\n     * This could either be an absolute module name (@angular/core for example) or a relative path.\r\n     */\r\n    from: string;\r\n}\r\n/**\r\n * The declaration of a symbol, along with information about how it was imported into the\r\n * application.\r\n */\r\nexport interface Declaration {\r\n    /**\r\n     * TypeScript reference to the declaration itself.\r\n     */\r\n    node: ts.Declaration;\r\n    /**\r\n     * The absolute module path from which the symbol was imported into the application, if the symbol\r\n     * was imported via an absolute module (even through a chain of re-exports). If the symbol is part\r\n     * of the application and was not imported from an absolute path, this will be `null`.\r\n     */\r\n    viaModule: string | null;\r\n}\r\n/**\r\n * Abstracts reflection operations on a TypeScript AST.\r\n *\r\n * Depending on the format of the code being interpreted, different concepts are represented with\r\n * different syntactical structures. The `ReflectionHost` abstracts over those differences and\r\n * presents a single API by which the compiler can query specific information about the AST.\r\n *\r\n * All operations on the `ReflectionHost` require the use of TypeScript `ts.Node`s with binding\r\n * information already available (that is, nodes that come from a `ts.Program` that has been\r\n * type-checked, and are not synthetically created).\r\n */\r\nexport interface ReflectionHost {\r\n    /**\r\n     * Examine a declaration (for example, of a class or function) and return metadata about any\r\n     * decorators present on the declaration.\r\n     *\r\n     * @param declaration a TypeScript `ts.Declaration` node representing the class or function over\r\n     * which to reflect. For example, if the intent is to reflect the decorators of a class and the\r\n     * source is in ES6 format, this will be a `ts.ClassDeclaration` node. If the source is in ES5\r\n     * format, this might be a `ts.VariableDeclaration` as classes in ES5 are represented as the\r\n     * result of an IIFE execution.\r\n     *\r\n     * @returns an array of `Decorator` metadata if decorators are present on the declaration, or\r\n     * `null` if either no decorators were present or if the declaration is not of a decorable type.\r\n     */\r\n    getDecoratorsOfDeclaration(declaration: ts.Declaration): Decorator[] | null;\r\n    /**\r\n     * Examine a declaration which should be of a class, and return metadata about the members of the\r\n     * class.\r\n     *\r\n     * @param declaration a TypeScript `ts.Declaration` node representing the class over which to\r\n     * reflect. If the source is in ES6 format, this will be a `ts.ClassDeclaration` node. If the\r\n     * source is in ES5 format, this might be a `ts.VariableDeclaration` as classes in ES5 are\r\n     * represented as the result of an IIFE execution.\r\n     *\r\n     * @returns an array of `ClassMember` metadata representing the members of the class.\r\n     *\r\n     * @throws if `declaration` does not resolve to a class declaration.\r\n     */\r\n    getMembersOfClass(clazz: ts.Declaration): ClassMember[];\r\n    /**\r\n     * Reflect over the constructor of a class and return metadata about its parameters.\r\n     *\r\n     * This method only looks at the constructor of a class directly and not at any inherited\r\n     * constructors.\r\n     *\r\n     * @param declaration a TypeScript `ts.Declaration` node representing the class over which to\r\n     * reflect. If the source is in ES6 format, this will be a `ts.ClassDeclaration` node. If the\r\n     * source is in ES5 format, this might be a `ts.VariableDeclaration` as classes in ES5 are\r\n     * represented as the result of an IIFE execution.\r\n     *\r\n     * @returns an array of `Parameter` metadata representing the parameters of the constructor, if\r\n     * a constructor exists. If the constructor exists and has 0 parameters, this array will be empty.\r\n     * If the class has no constructor, this method returns `null`.\r\n     */\r\n    getConstructorParameters(declaration: ts.Declaration): CtorParameter[] | null;\r\n    /**\r\n     * Reflect over a function and return metadata about its parameters and body.\r\n     *\r\n     * Functions in TypeScript and ES5 code have different AST representations, in particular around\r\n     * default values for parameters. A TypeScript function has its default value as the initializer\r\n     * on the parameter declaration, whereas an ES5 function has its default value set in a statement\r\n     * of the form:\r\n     *\r\n     * if (param === void 0) { param = 3; }\r\n     *\r\n     * This method abstracts over these details, and interprets the function declaration and body to\r\n     * extract parameter default values and the \"real\" body.\r\n     *\r\n     * A current limitation is that this metadata has no representation for shorthand assignment of\r\n     * parameter objects in the function signature.\r\n     *\r\n     * @param fn a TypeScript `ts.Declaration` node representing the function over which to reflect.\r\n     *\r\n     * @returns a `FunctionDefinition` giving metadata about the function definition.\r\n     */\r\n    getDefinitionOfFunction<T extends ts.MethodDeclaration | ts.FunctionDeclaration | ts.FunctionExpression>(fn: T): FunctionDefinition<T>;\r\n    /**\r\n     * Determine if an identifier was imported from another module and return `Import` metadata\r\n     * describing its origin.\r\n     *\r\n     * @param id a TypeScript `ts.Identifer` to reflect.\r\n     *\r\n     * @returns metadata about the `Import` if the identifier was imported from another module, or\r\n     * `null` if the identifier doesn't resolve to an import but instead is locally defined.\r\n     */\r\n    getImportOfIdentifier(id: ts.Identifier): Import | null;\r\n    /**\r\n     * Trace an identifier to its declaration, if possible.\r\n     *\r\n     * This method attempts to resolve the declaration of the given identifier, tracing back through\r\n     * imports and re-exports until the original declaration statement is found. A `Declaration`\r\n     * object is returned if the original declaration is found, or `null` is returned otherwise.\r\n     *\r\n     * If the declaration is in a different module, and that module is imported via an absolute path,\r\n     * this method also returns the absolute path of the imported module. For example, if the code is:\r\n     *\r\n     * ```\r\n     * import {RouterModule} from '@angular/core';\r\n     *\r\n     * export const ROUTES = RouterModule.forRoot([...]);\r\n     * ```\r\n     *\r\n     * and if `getDeclarationOfIdentifier` is called on `RouterModule` in the `ROUTES` expression,\r\n     * then it would trace `RouterModule` via its import from `@angular/core`, and note that the\r\n     * definition was imported from `@angular/core` into the application where it was referenced.\r\n     *\r\n     * If the definition is re-exported several times from different absolute module names, only\r\n     * the first one (the one by which the application refers to the module) is returned.\r\n     *\r\n     * This module name is returned in the `viaModule` field of the `Declaration`. If The declaration\r\n     * is relative to the application itself and there was no import through an absolute path, then\r\n     * `viaModule` is `null`.\r\n     *\r\n     * @param id a TypeScript `ts.Identifier` to trace back to a declaration.\r\n     *\r\n     * @returns metadata about the `Declaration` if the original declaration is found, or `null`\r\n     * otherwise.\r\n     */\r\n    getDeclarationOfIdentifier(id: ts.Identifier): Declaration | null;\r\n    /**\r\n     * Collect the declarations exported from a module by name.\r\n     *\r\n     * Iterates over the exports of a module (including re-exports) and returns a map of export\r\n     * name to its `Declaration`. If an exported value is itself re-exported from another module,\r\n     * the `Declaration`'s `viaModule` will reflect that.\r\n     *\r\n     * @param node a TypeScript `ts.Node` representing the module (for example a `ts.SourceFile`) for\r\n     * which to collect exports.\r\n     *\r\n     * @returns a map of `Declaration`s for the module's exports, by name.\r\n     */\r\n    getExportsOfModule(module: ts.Node): Map<string, Declaration> | null;\r\n    /**\r\n     * Check whether the given node actually represents a class.\r\n     */\r\n    isClass(node: ts.Node): boolean;\r\n    hasBaseClass(node: ts.Declaration): boolean;\r\n    /**\r\n     * Get the number of generic type parameters of a given class.\r\n     *\r\n     * @returns the number of type parameters of the class, if known, or `null` if the declaration\r\n     * is not a class or has an unknown number of type parameters.\r\n     */\r\n    getGenericArityOfClass(clazz: ts.Declaration): number | null;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/metadata/index.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { TypeScriptReflectionHost, filterToMembersWithDecorator, findMember, reflectObjectLiteral, reflectTypeEntityToDeclaration } from './src/reflector';\r\nexport { AbsoluteReference, EnumValue, ImportMode, Reference, ResolvedReference, ResolvedValue, isDynamicValue, staticallyResolve } from './src/resolver';\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/metadata/src/reflector.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nimport { ClassMember, CtorParameter, Declaration, Decorator, FunctionDefinition, Import, ReflectionHost } from '../../host';\r\n/**\r\n * reflector.ts implements static reflection of declarations using the TypeScript `ts.TypeChecker`.\r\n */\r\nexport declare class TypeScriptReflectionHost implements ReflectionHost {\r\n    protected checker: ts.TypeChecker;\r\n    constructor(checker: ts.TypeChecker);\r\n    getDecoratorsOfDeclaration(declaration: ts.Declaration): Decorator[] | null;\r\n    getMembersOfClass(declaration: ts.Declaration): ClassMember[];\r\n    getConstructorParameters(declaration: ts.Declaration): CtorParameter[] | null;\r\n    getImportOfIdentifier(id: ts.Identifier): Import | null;\r\n    getExportsOfModule(node: ts.Node): Map<string, Declaration> | null;\r\n    isClass(node: ts.Node): boolean;\r\n    hasBaseClass(node: ts.Declaration): boolean;\r\n    getDeclarationOfIdentifier(id: ts.Identifier): Declaration | null;\r\n    getDefinitionOfFunction<T extends ts.FunctionDeclaration | ts.MethodDeclaration | ts.FunctionExpression>(node: T): FunctionDefinition<T>;\r\n    getGenericArityOfClass(clazz: ts.Declaration): number | null;\r\n    /**\r\n     * Resolve a `ts.Symbol` to its declaration, keeping track of the `viaModule` along the way.\r\n     *\r\n     * @internal\r\n     */\r\n    protected getDeclarationOfSymbol(symbol: ts.Symbol): Declaration | null;\r\n    private _reflectDecorator;\r\n    private _reflectMember;\r\n}\r\nexport declare function reflectNameOfDeclaration(decl: ts.Declaration): string | null;\r\nexport declare function reflectIdentifierOfDeclaration(decl: ts.Declaration): ts.Identifier | null;\r\nexport declare function reflectTypeEntityToDeclaration(type: ts.EntityName, checker: ts.TypeChecker): {\r\n    node: ts.Declaration;\r\n    from: string | null;\r\n};\r\nexport declare function filterToMembersWithDecorator(members: ClassMember[], name: string, module?: string): {\r\n    member: ClassMember;\r\n    decorators: Decorator[];\r\n}[];\r\nexport declare function findMember(members: ClassMember[], name: string, isStatic?: boolean): ClassMember | null;\r\nexport declare function reflectObjectLiteral(node: ts.ObjectLiteralExpression): Map<string, ts.Expression>;\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/metadata/src/resolver.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * resolver.ts implements partial computation of expressions, resolving expressions to static\r\n * values where possible and returning a `DynamicValue` signal when not.\r\n */\r\nimport { Expression } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { ReflectionHost } from '../../host';\r\n/**\r\n * Represents a value which cannot be determined statically.\r\n *\r\n * Use `isDynamicValue` to determine whether a `ResolvedValue` is a `DynamicValue`.\r\n */\r\nexport declare class DynamicValue {\r\n    /**\r\n     * This is needed so the \"is DynamicValue\" assertion of `isDynamicValue` actually has meaning.\r\n     *\r\n     * Otherwise, \"is DynamicValue\" is akin to \"is {}\" which doesn't trigger narrowing.\r\n     */\r\n    private _isDynamic;\r\n}\r\n/**\r\n * Used to test whether a `ResolvedValue` is a `DynamicValue`.\r\n */\r\nexport declare function isDynamicValue(value: any): value is DynamicValue;\r\n/**\r\n * A value resulting from static resolution.\r\n *\r\n * This could be a primitive, collection type, reference to a `ts.Node` that declares a\r\n * non-primitive value, or a special `DynamicValue` type which indicates the value was not\r\n * available statically.\r\n */\r\nexport declare type ResolvedValue = number | boolean | string | null | undefined | Reference | EnumValue | ResolvedValueArray | ResolvedValueMap | DynamicValue;\r\n/**\r\n * An array of `ResolvedValue`s.\r\n *\r\n * This is a reified type to allow the circular reference of `ResolvedValue` -> `ResolvedValueArray`\r\n * ->\r\n * `ResolvedValue`.\r\n */\r\nexport interface ResolvedValueArray extends Array<ResolvedValue> {\r\n}\r\n/**\r\n * A map of strings to `ResolvedValue`s.\r\n *\r\n * This is a reified type to allow the circular reference of `ResolvedValue` -> `ResolvedValueMap` ->\r\n * `ResolvedValue`.\r\n */ export interface ResolvedValueMap extends Map<string, ResolvedValue> {\r\n}\r\n/**\r\n * A value member of an enumeration.\r\n *\r\n * Contains a `Reference` to the enumeration itself, and the name of the referenced member.\r\n */\r\nexport declare class EnumValue {\r\n    readonly enumRef: Reference<ts.EnumDeclaration>;\r\n    readonly name: string;\r\n    constructor(enumRef: Reference<ts.EnumDeclaration>, name: string);\r\n}\r\nexport declare enum ImportMode {\r\n    UseExistingImport = 0,\r\n    ForceNewImport = 1\r\n}\r\n/**\r\n * A reference to a `ts.Node`.\r\n *\r\n * For example, if an expression evaluates to a function or class definition, it will be returned\r\n * as a `Reference` (assuming references are allowed in evaluation).\r\n */\r\nexport declare abstract class Reference<T extends ts.Node = ts.Node> {\r\n    readonly node: T;\r\n    constructor(node: T);\r\n    /**\r\n     * Whether an `Expression` can be generated which references the node.\r\n     */\r\n    readonly expressable: boolean;\r\n    /**\r\n     * Generate an `Expression` representing this type, in the context of the given SourceFile.\r\n     *\r\n     * This could be a local variable reference, if the symbol is imported, or it could be a new\r\n     * import if needed.\r\n     */\r\n    abstract toExpression(context: ts.SourceFile, importMode?: ImportMode): Expression | null;\r\n    abstract addIdentifier(identifier: ts.Identifier): void;\r\n}\r\n/**\r\n * A reference to a node only, without any ability to get an `Expression` representing that node.\r\n *\r\n * This is used for returning references to things like method declarations, which are not directly\r\n * referenceable.\r\n */\r\nexport declare class NodeReference<T extends ts.Node = ts.Node> extends Reference<T> {\r\n    readonly moduleName: string | null;\r\n    constructor(node: T, moduleName: string | null);\r\n    toExpression(context: ts.SourceFile): null;\r\n    addIdentifier(identifier: ts.Identifier): void;\r\n}\r\n/**\r\n * A reference to a node which has a `ts.Identifier` and can be resolved to an `Expression`.\r\n *\r\n * Imports generated by `ResolvedReference`s are always relative.\r\n */\r\nexport declare class ResolvedReference<T extends ts.Node = ts.Node> extends Reference<T> {\r\n    protected primaryIdentifier: ts.Identifier;\r\n    protected identifiers: ts.Identifier[];\r\n    constructor(node: T, primaryIdentifier: ts.Identifier);\r\n    readonly expressable: boolean;\r\n    toExpression(context: ts.SourceFile, importMode?: ImportMode): Expression;\r\n    addIdentifier(identifier: ts.Identifier): void;\r\n}\r\n/**\r\n * A reference to a node which has a `ts.Identifer` and an expected absolute module name.\r\n *\r\n * An `AbsoluteReference` can be resolved to an `Expression`, and if that expression is an import\r\n * the module specifier will be an absolute module name, not a relative path.\r\n */\r\nexport declare class AbsoluteReference extends Reference {\r\n    private primaryIdentifier;\r\n    readonly moduleName: string;\r\n    readonly symbolName: string;\r\n    private identifiers;\r\n    constructor(node: ts.Node, primaryIdentifier: ts.Identifier, moduleName: string, symbolName: string);\r\n    readonly expressable: boolean;\r\n    toExpression(context: ts.SourceFile, importMode?: ImportMode): Expression;\r\n    addIdentifier(identifier: ts.Identifier): void;\r\n}\r\n/**\r\n * Statically resolve the given `ts.Expression` into a `ResolvedValue`.\r\n *\r\n * @param node the expression to statically resolve if possible\r\n * @param checker a `ts.TypeChecker` used to understand the expression\r\n * @param foreignFunctionResolver a function which will be used whenever a \"foreign function\" is\r\n * encountered. A foreign function is a function which has no body - usually the result of calling\r\n * a function declared in another library's .d.ts file. In these cases, the foreignFunctionResolver\r\n * will be called with the function's declaration, and can optionally return a `ts.Expression`\r\n * (possibly extracted from the foreign function's type signature) which will be used as the result\r\n * of the call.\r\n * @returns a `ResolvedValue` representing the resolved value\r\n */\r\nexport declare function staticallyResolve(node: ts.Expression, host: ReflectionHost, checker: ts.TypeChecker, foreignFunctionResolver?: (node: Reference<ts.FunctionDeclaration | ts.MethodDeclaration>, args: ts.Expression[]) => ts.Expression | null): ResolvedValue;\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/program.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { GeneratedFile } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport * as api from '../transformers/api';\r\nexport declare class NgtscProgram implements api.Program {\r\n    private options;\r\n    private tsProgram;\r\n    private resourceLoader;\r\n    private compilation;\r\n    private factoryToSourceInfo;\r\n    private sourceToFactorySymbols;\r\n    private host;\r\n    private _coreImportsFrom;\r\n    private _reflector;\r\n    private _isCore;\r\n    private rootDirs;\r\n    private closureCompilerEnabled;\r\n    constructor(rootNames: ReadonlyArray<string>, options: api.CompilerOptions, host: api.CompilerHost, oldProgram?: api.Program);\r\n    getTsProgram(): ts.Program;\r\n    getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<ts.Diagnostic>;\r\n    getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<api.Diagnostic>;\r\n    getTsSyntacticDiagnostics(sourceFile?: ts.SourceFile | undefined, cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<ts.Diagnostic>;\r\n    getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<api.Diagnostic>;\r\n    getTsSemanticDiagnostics(sourceFile?: ts.SourceFile | undefined, cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<ts.Diagnostic>;\r\n    getNgSemanticDiagnostics(fileName?: string | undefined, cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<ts.Diagnostic | api.Diagnostic>;\r\n    loadNgStructureAsync(): Promise<void>;\r\n    listLazyRoutes(entryRoute?: string | undefined): api.LazyRoute[];\r\n    getLibrarySummaries(): Map<string, api.LibrarySummary>;\r\n    getEmittedGeneratedFiles(): Map<string, GeneratedFile>;\r\n    getEmittedSourceFiles(): Map<string, ts.SourceFile>;\r\n    private ensureAnalyzed;\r\n    emit(opts?: {\r\n        emitFlags?: api.EmitFlags;\r\n        cancellationToken?: ts.CancellationToken;\r\n        customTransformers?: api.CustomTransformers;\r\n        emitCallback?: api.TsEmitCallback;\r\n        mergeEmitResultsCallback?: api.TsMergeEmitResultsCallback;\r\n    }): ts.EmitResult;\r\n    private makeCompilation;\r\n    private readonly reflector;\r\n    private readonly coreImportsFrom;\r\n    private readonly isCore;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/resource_loader.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ResourceLoader } from './annotations';\r\n/**\r\n * `ResourceLoader` which delegates to a `CompilerHost` resource loading method.\r\n */\r\nexport declare class HostResourceLoader implements ResourceLoader {\r\n    private host;\r\n    private cache;\r\n    private fetching;\r\n    constructor(host: (url: string) => string | Promise<string>);\r\n    preload(url: string): Promise<void> | undefined;\r\n    load(url: string): string;\r\n}\r\n/**\r\n * `ResourceLoader` which directly uses the filesystem to resolve resources synchronously.\r\n */\r\nexport declare class FileResourceLoader implements ResourceLoader {\r\n    load(url: string): string;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/testing/in_memory_typescript.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nexport declare function makeProgram(files: {\r\n    name: string;\r\n    contents: string;\r\n}[], options?: ts.CompilerOptions): {\r\n    program: ts.Program;\r\n    host: ts.CompilerHost;\r\n};\r\nexport declare class InMemoryHost implements ts.CompilerHost {\r\n    private fileSystem;\r\n    getSourceFile(fileName: string, languageVersion: ts.ScriptTarget, onError?: ((message: string) => void) | undefined, shouldCreateNewSourceFile?: boolean | undefined): ts.SourceFile | undefined;\r\n    getDefaultLibFileName(options: ts.CompilerOptions): string;\r\n    writeFile(fileName: string, data: string, writeByteOrderMark?: boolean, onError?: ((message: string) => void) | undefined, sourceFiles?: ReadonlyArray<ts.SourceFile>): void;\r\n    getCurrentDirectory(): string;\r\n    getDirectories(dir: string): string[];\r\n    getCanonicalFileName(fileName: string): string;\r\n    useCaseSensitiveFileNames(): boolean;\r\n    getNewLine(): string;\r\n    fileExists(fileName: string): boolean;\r\n    readFile(fileName: string): string | undefined;\r\n}\r\nexport declare function getDeclaration<T extends ts.Declaration>(program: ts.Program, fileName: string, name: string, assert: (value: any) => value is T): T;\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/transform/index.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport * from './src/api';\r\nexport { IvyCompilation } from './src/compilation';\r\nexport { DtsFileTransformer } from './src/declaration';\r\nexport { ivyTransformFactory } from './src/transform';\r\nexport { ImportManager, translateStatement } from './src/translator';\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/transform/src/api.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ConstantPool, Expression, Statement, Type } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { Decorator } from '../../host';\r\n/**\r\n * Provides the interface between a decorator compiler from @angular/compiler and the Typescript\r\n * compiler/transform.\r\n *\r\n * The decorator compilers in @angular/compiler do not depend on Typescript. The handler is\r\n * responsible for extracting the information required to perform compilation from the decorators\r\n * and Typescript source, invoking the decorator compiler, and returning the result.\r\n */\r\nexport interface DecoratorHandler<A, M> {\r\n    /**\r\n     * Scan a set of reflected decorators and determine if this handler is responsible for compilation\r\n     * of one of them.\r\n     */\r\n    detect(node: ts.Declaration, decorators: Decorator[] | null): M | undefined;\r\n    /**\r\n     * Asynchronously perform pre-analysis on the decorator/class combination.\r\n     *\r\n     * `preAnalyze` is optional and is not guaranteed to be called through all compilation flows. It\r\n     * will only be called if asynchronicity is supported in the CompilerHost.\r\n     */\r\n    preanalyze?(node: ts.Declaration, metadata: M): Promise<void> | undefined;\r\n    /**\r\n     * Perform analysis on the decorator/class combination, producing instructions for compilation\r\n     * if successful, or an array of diagnostic messages if the analysis fails or the decorator\r\n     * isn't valid.\r\n     */\r\n    analyze(node: ts.Declaration, metadata: M): AnalysisOutput<A>;\r\n    /**\r\n     * Generate a description of the field which should be added to the class, including any\r\n     * initialization code to be generated.\r\n     */\r\n    compile(node: ts.Declaration, analysis: A, constantPool: ConstantPool): CompileResult | CompileResult[];\r\n}\r\n/**\r\n * The output of an analysis operation, consisting of possibly an arbitrary analysis object (used as\r\n * the input to code generation) and potentially diagnostics if there were errors uncovered during\r\n * analysis.\r\n */\r\nexport interface AnalysisOutput<A> {\r\n    analysis?: A;\r\n    diagnostics?: ts.Diagnostic[];\r\n    factorySymbolName?: string;\r\n}\r\n/**\r\n * A description of the static field to add to a class, including an initialization expression\r\n * and a type for the .d.ts file.\r\n */\r\nexport interface CompileResult {\r\n    name: string;\r\n    initializer: Expression;\r\n    statements: Statement[];\r\n    type: Type;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/transform/src/compilation.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ConstantPool } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { Decorator, ReflectionHost } from '../../host';\r\nimport { CompileResult, DecoratorHandler } from './api';\r\n/**\r\n * Manages a compilation of Ivy decorators into static fields across an entire ts.Program.\r\n *\r\n * The compilation is stateful - source files are analyzed and records of the operations that need\r\n * to be performed during the transform/emit process are maintained internally.\r\n */\r\nexport declare class IvyCompilation {\r\n    private handlers;\r\n    private checker;\r\n    private reflector;\r\n    private coreImportsFrom;\r\n    private sourceToFactorySymbols;\r\n    /**\r\n     * Tracks classes which have been analyzed and found to have an Ivy decorator, and the\r\n     * information recorded about them for later compilation.\r\n     */\r\n    private analysis;\r\n    /**\r\n     * Tracks factory information which needs to be generated.\r\n     */\r\n    /**\r\n     * Tracks the `DtsFileTransformer`s for each TS file that needs .d.ts transformations.\r\n     */\r\n    private dtsMap;\r\n    private _diagnostics;\r\n    /**\r\n     * @param handlers array of `DecoratorHandler`s which will be executed against each class in the\r\n     * program\r\n     * @param checker TypeScript `TypeChecker` instance for the program\r\n     * @param reflector `ReflectionHost` through which all reflection operations will be performed\r\n     * @param coreImportsFrom a TypeScript `SourceFile` which exports symbols needed for Ivy imports\r\n     * when compiling @angular/core, or `null` if the current program is not @angular/core. This is\r\n     * `null` in most cases.\r\n     */\r\n    constructor(handlers: DecoratorHandler<any, any>[], checker: ts.TypeChecker, reflector: ReflectionHost, coreImportsFrom: ts.SourceFile | null, sourceToFactorySymbols: Map<string, Set<string>> | null);\r\n    analyzeSync(sf: ts.SourceFile): void;\r\n    analyzeAsync(sf: ts.SourceFile): Promise<void> | undefined;\r\n    /**\r\n     * Analyze a source file and produce diagnostics for it (if any).\r\n     */\r\n    private analyze;\r\n    /**\r\n     * Perform a compilation operation on the given class declaration and return instructions to an\r\n     * AST transformer if any are available.\r\n     */\r\n    compileIvyFieldFor(node: ts.Declaration, constantPool: ConstantPool): CompileResult[] | undefined;\r\n    /**\r\n     * Lookup the `ts.Decorator` which triggered transformation of a particular class declaration.\r\n     */\r\n    ivyDecoratorFor(node: ts.Declaration): Decorator | undefined;\r\n    /**\r\n     * Process a .d.ts source string and return a transformed version that incorporates the changes\r\n     * made to the source file.\r\n     */\r\n    transformedDtsFor(tsFileName: string, dtsOriginalSource: string): string;\r\n    readonly diagnostics: ReadonlyArray<ts.Diagnostic>;\r\n    private getDtsTransformer;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/transform/src/declaration.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nimport { CompileResult } from './api';\r\n/**\r\n * Processes .d.ts file text and adds static field declarations, with types.\r\n */\r\nexport declare class DtsFileTransformer {\r\n    private coreImportsFrom;\r\n    private ivyFields;\r\n    private imports;\r\n    constructor(coreImportsFrom: ts.SourceFile | null, importPrefix?: string);\r\n    /**\r\n     * Track that a static field was added to the code for a class.\r\n     */\r\n    recordStaticField(name: string, decls: CompileResult[]): void;\r\n    /**\r\n     * Process the .d.ts text for a file and add any declarations which were recorded.\r\n     */\r\n    transform(dts: string, tsPath: string): string;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/transform/src/transform.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nimport { ReflectionHost } from '../../host';\r\nimport { IvyCompilation } from './compilation';\r\nexport declare function ivyTransformFactory(compilation: IvyCompilation, reflector: ReflectionHost, coreImportsFrom: ts.SourceFile | null): ts.TransformerFactory<ts.SourceFile>;\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/transform/src/translator.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ArrayType, AssertNotNull, BinaryOperatorExpr, BuiltinType, CastExpr, CommaExpr, ConditionalExpr, Expression, ExpressionType, ExpressionVisitor, ExternalExpr, FunctionExpr, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, ReadKeyExpr, ReadPropExpr, ReadVarExpr, Statement, Type, TypeVisitor, TypeofExpr, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nexport declare class Context {\r\n    readonly isStatement: boolean;\r\n    constructor(isStatement: boolean);\r\n    readonly withExpressionMode: Context;\r\n    readonly withStatementMode: Context;\r\n}\r\nexport declare class ImportManager {\r\n    private isCore;\r\n    private prefix;\r\n    private moduleToIndex;\r\n    private nextIndex;\r\n    constructor(isCore: boolean, prefix?: string);\r\n    generateNamedImport(moduleName: string, symbol: string): string;\r\n    getAllImports(contextPath: string, rewriteCoreImportsTo: ts.SourceFile | null): {\r\n        name: string;\r\n        as: string;\r\n    }[];\r\n}\r\nexport declare function translateExpression(expression: Expression, imports: ImportManager): ts.Expression;\r\nexport declare function translateStatement(statement: Statement, imports: ImportManager): ts.Statement;\r\nexport declare function translateType(type: Type, imports: ImportManager): string;\r\nexport declare class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\r\n    private imports;\r\n    constructor(imports: ImportManager);\r\n    visitBuiltinType(type: BuiltinType, context: Context): string;\r\n    visitExpressionType(type: ExpressionType, context: Context): string;\r\n    visitArrayType(type: ArrayType, context: Context): string;\r\n    visitMapType(type: MapType, context: Context): string;\r\n    visitReadVarExpr(ast: ReadVarExpr, context: Context): string;\r\n    visitWriteVarExpr(expr: WriteVarExpr, context: Context): never;\r\n    visitWriteKeyExpr(expr: WriteKeyExpr, context: Context): never;\r\n    visitWritePropExpr(expr: WritePropExpr, context: Context): never;\r\n    visitInvokeMethodExpr(ast: InvokeMethodExpr, context: Context): never;\r\n    visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: Context): never;\r\n    visitInstantiateExpr(ast: InstantiateExpr, context: Context): never;\r\n    visitLiteralExpr(ast: LiteralExpr, context: Context): string;\r\n    visitExternalExpr(ast: ExternalExpr, context: Context): string;\r\n    visitConditionalExpr(ast: ConditionalExpr, context: Context): void;\r\n    visitNotExpr(ast: NotExpr, context: Context): void;\r\n    visitAssertNotNullExpr(ast: AssertNotNull, context: Context): void;\r\n    visitCastExpr(ast: CastExpr, context: Context): void;\r\n    visitFunctionExpr(ast: FunctionExpr, context: Context): void;\r\n    visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: Context): void;\r\n    visitReadPropExpr(ast: ReadPropExpr, context: Context): void;\r\n    visitReadKeyExpr(ast: ReadKeyExpr, context: Context): void;\r\n    visitLiteralArrayExpr(ast: LiteralArrayExpr, context: Context): string;\r\n    visitLiteralMapExpr(ast: LiteralMapExpr, context: Context): void;\r\n    visitCommaExpr(ast: CommaExpr, context: Context): void;\r\n    visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: Context): string;\r\n    visitTypeofExpr(ast: TypeofExpr, context: Context): string;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/util/src/path.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare function relativePathBetween(from: string, to: string): string | null;\r\n",
  "/node_modules/@angular/compiler-cli/src/ngtsc/util/src/visitor.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\n/**\r\n * Result type of visiting a node that's typically an entry in a list, which allows specifying that\r\n * nodes should be added before the visited node in the output.\r\n */\r\nexport declare type VisitListEntryResult<B extends ts.Node, T extends B> = {\r\n    node: T;\r\n    before?: B[];\r\n    after?: B[];\r\n};\r\n/**\r\n * Visit a node with the given visitor and return a transformed copy.\r\n */\r\nexport declare function visit<T extends ts.Node>(node: T, visitor: Visitor, context: ts.TransformationContext): T;\r\n/**\r\n * Abstract base class for visitors, which processes certain nodes specially to allow insertion\r\n * of other nodes before them.\r\n */\r\nexport declare abstract class Visitor {\r\n    /**\r\n     * Maps statements to an array of statements that should be inserted before them.\r\n     */\r\n    private _before;\r\n    /**\r\n     * Maps statements to an array of statements that should be inserted after them.\r\n     */\r\n    private _after;\r\n    /**\r\n     * Visit a class declaration, returning at least the transformed declaration and optionally other\r\n     * nodes to insert before the declaration.\r\n     */\r\n    visitClassDeclaration(node: ts.ClassDeclaration): VisitListEntryResult<ts.Statement, ts.ClassDeclaration>;\r\n    private _visitListEntryNode;\r\n    /**\r\n     * Visit types of nodes which don't have their own explicit visitor.\r\n     */\r\n    visitOtherNode<T extends ts.Node>(node: T): T;\r\n    /**\r\n     * @internal\r\n     */\r\n    _visit<T extends ts.Node>(node: T, context: ts.TransformationContext): T;\r\n    private _maybeProcessStatements;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/perform_compile.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Position } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport * as api from './transformers/api';\r\nexport declare type Diagnostics = ReadonlyArray<ts.Diagnostic | api.Diagnostic>;\r\nexport declare function filterErrorsAndWarnings(diagnostics: Diagnostics): Diagnostics;\r\nexport declare function formatDiagnosticPosition(position: Position, host?: ts.FormatDiagnosticsHost): string;\r\nexport declare function flattenDiagnosticMessageChain(chain: api.DiagnosticMessageChain, host?: ts.FormatDiagnosticsHost): string;\r\nexport declare function formatDiagnostic(diagnostic: api.Diagnostic, host?: ts.FormatDiagnosticsHost): string;\r\nexport declare function formatDiagnostics(diags: Diagnostics, host?: ts.FormatDiagnosticsHost): string;\r\nexport interface ParsedConfiguration {\r\n    project: string;\r\n    options: api.CompilerOptions;\r\n    rootNames: string[];\r\n    emitFlags: api.EmitFlags;\r\n    errors: Diagnostics;\r\n}\r\nexport declare function calcProjectFileAndBasePath(project: string): {\r\n    projectFile: string;\r\n    basePath: string;\r\n};\r\nexport declare function createNgCompilerOptions(basePath: string, config: any, tsOptions: ts.CompilerOptions): api.CompilerOptions;\r\nexport declare function readConfiguration(project: string, existingOptions?: ts.CompilerOptions): ParsedConfiguration;\r\nexport interface PerformCompilationResult {\r\n    diagnostics: Diagnostics;\r\n    program?: api.Program;\r\n    emitResult?: ts.EmitResult;\r\n}\r\nexport declare function exitCodeFromResult(diags: Diagnostics | undefined): number;\r\nexport declare function performCompilation({ rootNames, options, host, oldProgram, emitCallback, mergeEmitResultsCallback, gatherDiagnostics, customTransformers, emitFlags }: {\r\n    rootNames: string[];\r\n    options: api.CompilerOptions;\r\n    host?: api.CompilerHost;\r\n    oldProgram?: api.Program;\r\n    emitCallback?: api.TsEmitCallback;\r\n    mergeEmitResultsCallback?: api.TsMergeEmitResultsCallback;\r\n    gatherDiagnostics?: (program: api.Program) => Diagnostics;\r\n    customTransformers?: api.CustomTransformers;\r\n    emitFlags?: api.EmitFlags;\r\n}): PerformCompilationResult;\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/api.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { GeneratedFile, ParseSourceSpan, Position } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nexport declare const DEFAULT_ERROR_CODE = 100;\r\nexport declare const UNKNOWN_ERROR_CODE = 500;\r\nexport declare const SOURCE: \"angular\";\r\nexport interface DiagnosticMessageChain {\r\n    messageText: string;\r\n    position?: Position;\r\n    next?: DiagnosticMessageChain;\r\n}\r\nexport interface Diagnostic {\r\n    messageText: string;\r\n    span?: ParseSourceSpan;\r\n    position?: Position;\r\n    chain?: DiagnosticMessageChain;\r\n    category: ts.DiagnosticCategory;\r\n    code: number;\r\n    source: 'angular';\r\n}\r\nexport declare function isTsDiagnostic(diagnostic: any): diagnostic is ts.Diagnostic;\r\nexport declare function isNgDiagnostic(diagnostic: any): diagnostic is Diagnostic;\r\nexport interface CompilerOptions extends ts.CompilerOptions {\r\n    diagnostics?: boolean;\r\n    genDir?: string;\r\n    basePath?: string;\r\n    skipMetadataEmit?: boolean;\r\n    strictMetadataEmit?: boolean;\r\n    skipTemplateCodegen?: boolean;\r\n    strictInjectionParameters?: boolean;\r\n    flatModuleOutFile?: string;\r\n    flatModuleId?: string;\r\n    flatModulePrivateSymbolPrefix?: string;\r\n    generateCodeForLibraries?: boolean;\r\n    fullTemplateTypeCheck?: boolean;\r\n    annotateForClosureCompiler?: boolean;\r\n    annotationsAs?: 'decorators' | 'static fields';\r\n    trace?: boolean;\r\n    disableExpressionLowering?: boolean;\r\n    disableTypeScriptVersionCheck?: boolean;\r\n    i18nOutLocale?: string;\r\n    i18nOutFormat?: string;\r\n    i18nOutFile?: string;\r\n    i18nInFormat?: string;\r\n    i18nInLocale?: string;\r\n    i18nInFile?: string;\r\n    i18nInMissingTranslations?: 'error' | 'warning' | 'ignore';\r\n    preserveWhitespaces?: boolean;\r\n    /** generate all possible generated files  */\r\n    allowEmptyCodegenFiles?: boolean;\r\n    /**\r\n     * Whether to generate .ngsummary.ts files that allow to use AOTed artifacts\r\n     * in JIT mode. This is off by default.\r\n     */\r\n    enableSummariesForJit?: boolean;\r\n    /**\r\n     * Whether to replace the `templateUrl` and `styleUrls` property in all\r\n     * @Component decorators with inlined contents in `template` and `styles`\r\n     * properties.\r\n     * When enabled, the .js output of ngc will have no lazy-loaded `templateUrl`\r\n     * or `styleUrl`s. Note that this requires that resources be available to\r\n     * load statically at compile-time.\r\n     */\r\n    enableResourceInlining?: boolean;\r\n    /**\r\n     * Tells the compiler to generate definitions using the Render3 style code generation.\r\n     * This option defaults to `false`.\r\n     *\r\n     * Not all features are supported with this option enabled. It is only supported\r\n     * for experimentation and testing of Render3 style code generation.\r\n     *\r\n     * Acceptable values are as follows:\r\n     *\r\n     * `false` - run ngc normally\r\n     * `true` - run ngc with its usual global analysis, but compile decorators to Ivy fields instead\r\n     *  of running the View Engine compilers\r\n     * `ngtsc` - run the ngtsc compiler instead of the normal ngc compiler\r\n     * `tsc` - behave like plain tsc as much as possible (used for testing JIT code)\r\n     *\r\n     * @experimental\r\n     */\r\n    enableIvy?: boolean | 'ngtsc' | 'tsc';\r\n    /** @internal */\r\n    collectAllErrors?: boolean;\r\n}\r\nexport interface CompilerHost extends ts.CompilerHost {\r\n    /**\r\n     * Converts a module name that is used in an `import` to a file path.\r\n     * I.e. `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\r\n     */\r\n    moduleNameToFileName?(moduleName: string, containingFile: string): string | null;\r\n    /**\r\n     * Converts a file path to a module name that can be used as an `import ...`\r\n     * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.\r\n     */\r\n    fileNameToModuleName?(importedFilePath: string, containingFilePath: string): string;\r\n    /**\r\n     * Converts a file path for a resource that is used in a source file or another resource\r\n     * into a filepath.\r\n     */\r\n    resourceNameToFileName?(resourceName: string, containingFilePath: string): string | null;\r\n    /**\r\n     * Converts a file name into a representation that should be stored in a summary file.\r\n     * This has to include changing the suffix as well.\r\n     * E.g.\r\n     * `some_file.ts` -> `some_file.d.ts`\r\n     *\r\n     * @param referringSrcFileName the soure file that refers to fileName\r\n     */\r\n    toSummaryFileName?(fileName: string, referringSrcFileName: string): string;\r\n    /**\r\n     * Converts a fileName that was processed by `toSummaryFileName` back into a real fileName\r\n     * given the fileName of the library that is referrig to it.\r\n     */\r\n    fromSummaryFileName?(fileName: string, referringLibFileName: string): string;\r\n    /**\r\n     * Load a referenced resource either statically or asynchronously. If the host returns a\r\n     * `Promise<string>` it is assumed the user of the corresponding `Program` will call\r\n     * `loadNgStructureAsync()`. Returning  `Promise<string>` outside `loadNgStructureAsync()` will\r\n     * cause a diagnostics diagnostic error or an exception to be thrown.\r\n     */\r\n    readResource?(fileName: string): Promise<string> | string;\r\n    /**\r\n     * Produce an AMD module name for the source file. Used in Bazel.\r\n     *\r\n     * An AMD module can have an arbitrary name, so that it is require'd by name\r\n     * rather than by path. See http://requirejs.org/docs/whyamd.html#namedmodules\r\n     */\r\n    amdModuleName?(sf: ts.SourceFile): string | undefined;\r\n}\r\nexport declare enum EmitFlags {\r\n    DTS = 1,\r\n    JS = 2,\r\n    Metadata = 4,\r\n    I18nBundle = 8,\r\n    Codegen = 16,\r\n    Default = 19,\r\n    All = 31\r\n}\r\nexport interface CustomTransformers {\r\n    beforeTs?: ts.TransformerFactory<ts.SourceFile>[];\r\n    afterTs?: ts.TransformerFactory<ts.SourceFile>[];\r\n}\r\nexport interface TsEmitArguments {\r\n    program: ts.Program;\r\n    host: CompilerHost;\r\n    options: CompilerOptions;\r\n    targetSourceFile?: ts.SourceFile;\r\n    writeFile?: ts.WriteFileCallback;\r\n    cancellationToken?: ts.CancellationToken;\r\n    emitOnlyDtsFiles?: boolean;\r\n    customTransformers?: ts.CustomTransformers;\r\n}\r\nexport interface TsEmitCallback {\r\n    (args: TsEmitArguments): ts.EmitResult;\r\n}\r\nexport interface TsMergeEmitResultsCallback {\r\n    (results: ts.EmitResult[]): ts.EmitResult;\r\n}\r\nexport interface LibrarySummary {\r\n    fileName: string;\r\n    text: string;\r\n    sourceFile?: ts.SourceFile;\r\n}\r\nexport interface LazyRoute {\r\n    route: string;\r\n    module: {\r\n        name: string;\r\n        filePath: string;\r\n    };\r\n    referencedModule: {\r\n        name: string;\r\n        filePath: string;\r\n    };\r\n}\r\nexport interface Program {\r\n    /**\r\n     * Retrieve the TypeScript program used to produce semantic diagnostics and emit the sources.\r\n     *\r\n     * Angular structural information is required to produce the program.\r\n     */\r\n    getTsProgram(): ts.Program;\r\n    /**\r\n     * Retrieve options diagnostics for the TypeScript options used to create the program. This is\r\n     * faster than calling `getTsProgram().getOptionsDiagnostics()` since it does not need to\r\n     * collect Angular structural information to produce the errors.\r\n     */\r\n    getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<ts.Diagnostic>;\r\n    /**\r\n     * Retrieve options diagnostics for the Angular options used to create the program.\r\n     */\r\n    getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<Diagnostic>;\r\n    /**\r\n     * Retrieve the syntax diagnostics from TypeScript. This is faster than calling\r\n     * `getTsProgram().getSyntacticDiagnostics()` since it does not need to collect Angular structural\r\n     * information to produce the errors.\r\n     */\r\n    getTsSyntacticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken): ReadonlyArray<ts.Diagnostic>;\r\n    /**\r\n     * Retrieve the diagnostics for the structure of an Angular application is correctly formed.\r\n     * This includes validating Angular annotations and the syntax of referenced and imbedded HTML\r\n     * and CSS.\r\n     *\r\n     * Note it is important to displaying TypeScript semantic diagnostics along with Angular\r\n     * structural diagnostics as an error in the program structure might cause errors detected in\r\n     * semantic analysis and a semantic error might cause errors in specifying the program structure.\r\n     *\r\n     * Angular structural information is required to produce these diagnostics.\r\n     */\r\n    getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<Diagnostic>;\r\n    /**\r\n     * Retrieve the semantic diagnostics from TypeScript. This is equivalent to calling\r\n     * `getTsProgram().getSemanticDiagnostics()` directly and is included for completeness.\r\n     */\r\n    getTsSemanticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken): ReadonlyArray<ts.Diagnostic>;\r\n    /**\r\n     * Retrieve the Angular semantic diagnostics.\r\n     *\r\n     * Angular structural information is required to produce these diagnostics.\r\n     */\r\n    getNgSemanticDiagnostics(fileName?: string, cancellationToken?: ts.CancellationToken): ReadonlyArray<ts.Diagnostic | Diagnostic>;\r\n    /**\r\n     * Load Angular structural information asynchronously. If this method is not called then the\r\n     * Angular structural information, including referenced HTML and CSS files, are loaded\r\n     * synchronously. If the supplied Angular compiler host returns a promise from `loadResource()`\r\n     * will produce a diagnostic error message or, `getTsProgram()` or `emit` to throw.\r\n     */\r\n    loadNgStructureAsync(): Promise<void>;\r\n    /**\r\n     * Returns the lazy routes in the program.\r\n     * @param entryRoute A reference to an NgModule like `someModule#name`. If given,\r\n     *              will recursively analyze routes starting from this symbol only.\r\n     *              Otherwise will list all routes for all NgModules in the program/\r\n     */\r\n    listLazyRoutes(entryRoute?: string): LazyRoute[];\r\n    /**\r\n     * Emit the files requested by emitFlags implied by the program.\r\n     *\r\n     * Angular structural information is required to emit files.\r\n     */\r\n    emit({ emitFlags, cancellationToken, customTransformers, emitCallback, mergeEmitResultsCallback }?: {\r\n        emitFlags?: EmitFlags;\r\n        cancellationToken?: ts.CancellationToken;\r\n        customTransformers?: CustomTransformers;\r\n        emitCallback?: TsEmitCallback;\r\n        mergeEmitResultsCallback?: TsMergeEmitResultsCallback;\r\n    }): ts.EmitResult;\r\n    /**\r\n     * Returns the .d.ts / .ngsummary.json / .ngfactory.d.ts files of libraries that have been emitted\r\n     * in this program or previous programs with paths that emulate the fact that these libraries\r\n     * have been compiled before with no outDir.\r\n     */\r\n    getLibrarySummaries(): Map<string, LibrarySummary>;\r\n    /**\r\n     * @internal\r\n     */\r\n    getEmittedGeneratedFiles(): Map<string, GeneratedFile>;\r\n    /**\r\n     * @internal\r\n     */\r\n    getEmittedSourceFiles(): Map<string, ts.SourceFile>;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/compiler_host.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { AotCompilerHost, GeneratedFile, ParseSourceSpan } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { TypeCheckHost } from '../diagnostics/translate_diagnostics';\r\nimport { ModuleMetadata } from '../metadata/index';\r\nimport { CompilerHost, CompilerOptions, LibrarySummary } from './api';\r\nexport declare function createCompilerHost({ options, tsHost }: {\r\n    options: CompilerOptions;\r\n    tsHost?: ts.CompilerHost;\r\n}): CompilerHost;\r\nexport interface MetadataProvider {\r\n    getMetadata(sourceFile: ts.SourceFile): ModuleMetadata | undefined;\r\n}\r\nexport interface CodeGenerator {\r\n    generateFile(genFileName: string, baseFileName?: string): GeneratedFile;\r\n    findGeneratedFileNames(fileName: string): string[];\r\n}\r\n/**\r\n * Implements the following hosts based on an api.CompilerHost:\r\n * - ts.CompilerHost to be consumed by a ts.Program\r\n * - AotCompilerHost for @angular/compiler\r\n * - TypeCheckHost for mapping ts errors to ng errors (via translateDiagnostics)\r\n */\r\nexport declare class TsCompilerAotCompilerTypeCheckHostAdapter implements ts.CompilerHost, AotCompilerHost, TypeCheckHost {\r\n    private rootFiles;\r\n    private options;\r\n    private context;\r\n    private metadataProvider;\r\n    private codeGenerator;\r\n    private librarySummaries;\r\n    private metadataReaderCache;\r\n    private fileNameToModuleNameCache;\r\n    private flatModuleIndexCache;\r\n    private flatModuleIndexNames;\r\n    private flatModuleIndexRedirectNames;\r\n    private rootDirs;\r\n    private moduleResolutionCache;\r\n    private originalSourceFiles;\r\n    private originalFileExistsCache;\r\n    private generatedSourceFiles;\r\n    private generatedCodeFor;\r\n    private emitter;\r\n    private metadataReaderHost;\r\n    getCancellationToken: () => ts.CancellationToken;\r\n    getDefaultLibLocation: () => string;\r\n    trace: (s: string) => void;\r\n    getDirectories: (path: string) => string[];\r\n    resolveTypeReferenceDirectives?: (names: string[], containingFile: string) => ts.ResolvedTypeReferenceDirective[];\r\n    directoryExists?: (directoryName: string) => boolean;\r\n    constructor(rootFiles: ReadonlyArray<string>, options: CompilerOptions, context: CompilerHost, metadataProvider: MetadataProvider, codeGenerator: CodeGenerator, librarySummaries?: Map<string, LibrarySummary>);\r\n    private resolveModuleName;\r\n    resolveModuleNames(moduleNames: string[], containingFile: string): ts.ResolvedModule[];\r\n    moduleNameToFileName(m: string, containingFile?: string): string | null;\r\n    /**\r\n     * We want a moduleId that will appear in import statements in the generated code\r\n     * which will be written to `containingFile`.\r\n     *\r\n     * Note that we also generate files for files in node_modules, as libraries\r\n     * only ship .metadata.json files but not the generated code.\r\n     *\r\n     * Logic:\r\n     * 1. if the importedFile and the containingFile are from the project sources\r\n     *    or from the same node_modules package, use a relative path\r\n     * 2. if the importedFile is in a node_modules package,\r\n     *    use a path that starts with the package name.\r\n     * 3. Error if the containingFile is in the node_modules package\r\n     *    and the importedFile is in the project soures,\r\n     *    as that is a violation of the principle that node_modules packages cannot\r\n     *    import project sources.\r\n     */\r\n    fileNameToModuleName(importedFile: string, containingFile: string): string;\r\n    resourceNameToFileName(resourceName: string, containingFile: string): string | null;\r\n    toSummaryFileName(fileName: string, referringSrcFileName: string): string;\r\n    fromSummaryFileName(fileName: string, referringLibFileName: string): string;\r\n    parseSourceSpanOf(fileName: string, line: number, character: number): ParseSourceSpan | null;\r\n    private getOriginalSourceFile;\r\n    updateGeneratedFile(genFile: GeneratedFile): ts.SourceFile;\r\n    private addGeneratedFile;\r\n    shouldGenerateFile(fileName: string): {\r\n        generate: boolean;\r\n        baseFileName?: string;\r\n    };\r\n    shouldGenerateFilesFor(fileName: string): string | boolean;\r\n    getSourceFile(fileName: string, languageVersion: ts.ScriptTarget, onError?: ((message: string) => void) | undefined): ts.SourceFile;\r\n    private getGeneratedFile;\r\n    private originalFileExists;\r\n    fileExists(fileName: string): boolean;\r\n    loadSummary(filePath: string): string | null;\r\n    isSourceFile(filePath: string): boolean;\r\n    readFile(fileName: string): string;\r\n    getMetadataFor(filePath: string): ModuleMetadata[] | undefined;\r\n    loadResource(filePath: string): Promise<string> | string;\r\n    getOutputName(filePath: string): string;\r\n    private hasBundleIndex;\r\n    getDefaultLibFileName: (options: ts.CompilerOptions) => string;\r\n    getCurrentDirectory: () => string;\r\n    getCanonicalFileName: (fileName: string) => string;\r\n    useCaseSensitiveFileNames: () => boolean;\r\n    getNewLine: () => string;\r\n    realpath: (p: string) => string;\r\n    writeFile: any;\r\n}\r\nexport declare function getOriginalReferences(sourceFile: ts.SourceFile): ts.FileReference[] | undefined;\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/entry_points.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { createCompilerHost } from './compiler_host';\r\nexport { createProgram } from './program';\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/inline_resources.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nimport { MetadataObject, MetadataValue } from '../metadata/index';\r\nimport { MetadataTransformer, ValueTransform } from './metadata_cache';\r\n/** A subset of members from AotCompilerHost */\r\nexport declare type ResourcesHost = {\r\n    resourceNameToFileName(resourceName: string, containingFileName: string): string | null;\r\n    loadResource(path: string): Promise<string> | string;\r\n};\r\nexport declare type StaticResourceLoader = {\r\n    get(url: string | MetadataValue): string;\r\n};\r\nexport declare class InlineResourcesMetadataTransformer implements MetadataTransformer {\r\n    private host;\r\n    constructor(host: ResourcesHost);\r\n    start(sourceFile: ts.SourceFile): ValueTransform | undefined;\r\n    updateDecoratorMetadata(loader: StaticResourceLoader, arg: MetadataObject): MetadataObject;\r\n}\r\nexport declare function getInlineResourcesTransformFactory(program: ts.Program, host: ResourcesHost): ts.TransformerFactory<ts.SourceFile>;\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/lower_expressions.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nimport { MetadataCache, MetadataTransformer, ValueTransform } from './metadata_cache';\r\nexport interface LoweringRequest {\r\n    kind: ts.SyntaxKind;\r\n    location: number;\r\n    end: number;\r\n    name: string;\r\n}\r\nexport declare type RequestLocationMap = Map<number, LoweringRequest>;\r\nexport declare function getExpressionLoweringTransformFactory(requestsMap: RequestsMap, program: ts.Program): (context: ts.TransformationContext) => (sourceFile: ts.SourceFile) => ts.SourceFile;\r\nexport interface RequestsMap {\r\n    getRequests(sourceFile: ts.SourceFile): RequestLocationMap;\r\n}\r\nexport declare class LowerMetadataTransform implements RequestsMap, MetadataTransformer {\r\n    private cache;\r\n    private requests;\r\n    private lowerableFieldNames;\r\n    constructor(lowerableFieldNames: string[]);\r\n    getRequests(sourceFile: ts.SourceFile): RequestLocationMap;\r\n    connect(cache: MetadataCache): void;\r\n    start(sourceFile: ts.SourceFile): ValueTransform | undefined;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/metadata_cache.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nimport { MetadataCollector, MetadataValue, ModuleMetadata } from '../metadata/index';\r\nimport { MetadataProvider } from './compiler_host';\r\nexport declare type ValueTransform = (value: MetadataValue, node: ts.Node) => MetadataValue;\r\nexport interface MetadataTransformer {\r\n    connect?(cache: MetadataCache): void;\r\n    start(sourceFile: ts.SourceFile): ValueTransform | undefined;\r\n}\r\n/**\r\n * Cache, and potentially transform, metadata as it is being collected.\r\n */\r\nexport declare class MetadataCache implements MetadataProvider {\r\n    private collector;\r\n    private readonly strict;\r\n    private transformers;\r\n    private metadataCache;\r\n    constructor(collector: MetadataCollector, strict: boolean, transformers: MetadataTransformer[]);\r\n    getMetadata(sourceFile: ts.SourceFile): ModuleMetadata | undefined;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/metadata_reader.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ModuleMetadata } from '../metadata';\r\nexport interface MetadataReaderHost {\r\n    getSourceFileMetadata(filePath: string): ModuleMetadata | undefined;\r\n    cacheMetadata?(fileName: string): boolean;\r\n    fileExists(filePath: string): boolean;\r\n    readFile(filePath: string): string;\r\n}\r\nexport interface MetadataReaderCache {\r\n    /**\r\n     * @internal\r\n     */\r\n    data: Map<string, ModuleMetadata[] | undefined>;\r\n}\r\nexport declare function createMetadataReaderCache(): MetadataReaderCache;\r\nexport declare function readMetadata(filePath: string, host: MetadataReaderHost, cache?: MetadataReaderCache): ModuleMetadata[] | undefined;\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/nocollapse_hack.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare function nocollapseHack(contents: string): string;\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/node_emitter.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { AssertNotNull, BinaryOperatorExpr, CastExpr, ClassStmt, CommaExpr, CommentStmt, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, ExpressionStatement, ExpressionVisitor, ExternalExpr, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, JSDocCommentStmt, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, NotExpr, ParseSourceSpan, PartialModule, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, ThrowStmt, TryCatchStmt, TypeofExpr, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nexport interface Node {\r\n    sourceSpan: ParseSourceSpan | null;\r\n}\r\nexport declare class TypeScriptNodeEmitter {\r\n    updateSourceFile(sourceFile: ts.SourceFile, stmts: Statement[], preamble?: string): [ts.SourceFile, Map<ts.Node, Node>];\r\n    /** Creates a not emitted statement containing the given comment. */\r\n    createCommentStatement(sourceFile: ts.SourceFile, comment: string): ts.Statement;\r\n}\r\n/**\r\n * Update the given source file to include the changes specified in module.\r\n *\r\n * The module parameter is treated as a partial module meaning that the statements are added to\r\n * the module instead of replacing the module. Also, any classes are treated as partial classes\r\n * and the included members are added to the class with the same name instead of a new class\r\n * being created.\r\n */\r\nexport declare function updateSourceFile(sourceFile: ts.SourceFile, module: PartialModule, context: ts.TransformationContext): [ts.SourceFile, Map<ts.Node, Node>];\r\nexport declare type RecordedNode<T extends ts.Node = ts.Node> = (T & {\r\n    __recorded: any;\r\n}) | null;\r\n/**\r\n * Visits an output ast and produces the corresponding TypeScript synthetic nodes.\r\n */\r\nexport declare class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\r\n    private _nodeMap;\r\n    private _importsWithPrefixes;\r\n    private _reexports;\r\n    private _templateSources;\r\n    private _exportedVariableIdentifiers;\r\n    /**\r\n     * Process the source file and collect exported identifiers that refer to variables.\r\n     *\r\n     * Only variables are collected because exported classes still exist in the module scope in\r\n     * CommonJS, whereas variables have their declarations moved onto the `exports` object, and all\r\n     * references are updated accordingly.\r\n     */\r\n    loadExportedVariableIdentifiers(sourceFile: ts.SourceFile): void;\r\n    getReexports(): ts.Statement[];\r\n    getImports(): ts.Statement[];\r\n    getNodeMap(): Map<ts.Node, Node>;\r\n    updateSourceMap(statements: ts.Statement[]): void;\r\n    private record;\r\n    private sourceRangeOf;\r\n    private getModifiers;\r\n    visitDeclareVarStmt(stmt: DeclareVarStmt): (ts.VariableStatement & {\r\n        __recorded: any;\r\n    }) | ((ts.VariableStatement & {\r\n        __recorded: any;\r\n    }) | (ts.ExportDeclaration & {\r\n        __recorded: any;\r\n    }))[];\r\n    visitDeclareFunctionStmt(stmt: DeclareFunctionStmt): ts.FunctionDeclaration & {\r\n        __recorded: any;\r\n    };\r\n    visitExpressionStmt(stmt: ExpressionStatement): ts.ExpressionStatement & {\r\n        __recorded: any;\r\n    };\r\n    visitReturnStmt(stmt: ReturnStatement): ts.ReturnStatement & {\r\n        __recorded: any;\r\n    };\r\n    visitDeclareClassStmt(stmt: ClassStmt): ts.ClassDeclaration & {\r\n        __recorded: any;\r\n    };\r\n    visitIfStmt(stmt: IfStmt): ts.IfStatement & {\r\n        __recorded: any;\r\n    };\r\n    visitTryCatchStmt(stmt: TryCatchStmt): RecordedNode<ts.TryStatement>;\r\n    visitThrowStmt(stmt: ThrowStmt): ts.ThrowStatement & {\r\n        __recorded: any;\r\n    };\r\n    visitCommentStmt(stmt: CommentStmt, sourceFile: ts.SourceFile): ts.NotEmittedStatement;\r\n    visitJSDocCommentStmt(stmt: JSDocCommentStmt, sourceFile: ts.SourceFile): ts.NotEmittedStatement;\r\n    private createCommentStmt;\r\n    visitWrappedNodeExpr(expr: WrappedNodeExpr<any>): any;\r\n    visitTypeofExpr(expr: TypeofExpr): ts.TypeOfExpression & {\r\n        __recorded: any;\r\n    };\r\n    visitReadVarExpr(expr: ReadVarExpr): (ts.Identifier & {\r\n        __recorded: any;\r\n    }) | (ts.SuperExpression & {\r\n        __recorded: any;\r\n    });\r\n    visitWriteVarExpr(expr: WriteVarExpr): RecordedNode<ts.BinaryExpression>;\r\n    visitWriteKeyExpr(expr: WriteKeyExpr): RecordedNode<ts.BinaryExpression>;\r\n    visitWritePropExpr(expr: WritePropExpr): RecordedNode<ts.BinaryExpression>;\r\n    visitInvokeMethodExpr(expr: InvokeMethodExpr): RecordedNode<ts.CallExpression>;\r\n    visitInvokeFunctionExpr(expr: InvokeFunctionExpr): RecordedNode<ts.CallExpression>;\r\n    visitInstantiateExpr(expr: InstantiateExpr): RecordedNode<ts.NewExpression>;\r\n    visitLiteralExpr(expr: LiteralExpr): (ts.Identifier & {\r\n        __recorded: any;\r\n    }) | (ts.StringLiteral & {\r\n        __recorded: any;\r\n    }) | (ts.NullLiteral & ts.Token<ts.SyntaxKind.NullKeyword> & {\r\n        __recorded: any;\r\n    });\r\n    visitExternalExpr(expr: ExternalExpr): ts.Expression & {\r\n        __recorded: any;\r\n    };\r\n    visitConditionalExpr(expr: ConditionalExpr): RecordedNode<ts.ParenthesizedExpression>;\r\n    visitNotExpr(expr: NotExpr): RecordedNode<ts.PrefixUnaryExpression>;\r\n    visitAssertNotNullExpr(expr: AssertNotNull): RecordedNode<ts.Expression>;\r\n    visitCastExpr(expr: CastExpr): RecordedNode<ts.Expression>;\r\n    visitFunctionExpr(expr: FunctionExpr): ts.FunctionExpression & {\r\n        __recorded: any;\r\n    };\r\n    visitBinaryOperatorExpr(expr: BinaryOperatorExpr): RecordedNode<ts.BinaryExpression | ts.ParenthesizedExpression>;\r\n    visitReadPropExpr(expr: ReadPropExpr): RecordedNode<ts.PropertyAccessExpression>;\r\n    visitReadKeyExpr(expr: ReadKeyExpr): RecordedNode<ts.ElementAccessExpression>;\r\n    visitLiteralArrayExpr(expr: LiteralArrayExpr): RecordedNode<ts.ArrayLiteralExpression>;\r\n    visitLiteralMapExpr(expr: LiteralMapExpr): RecordedNode<ts.ObjectLiteralExpression>;\r\n    visitCommaExpr(expr: CommaExpr): RecordedNode<ts.Expression>;\r\n    private _visitStatements;\r\n    private _visitStatementsPrefix;\r\n    private _visitIdentifier;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/node_emitter_transform.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { GeneratedFile } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\n/**\r\n * Returns a transformer that does two things for generated files (ngfactory etc):\r\n * - adds a fileoverview JSDoc comment containing Closure Compiler specific \"suppress\"ions in JSDoc.\r\n *   The new comment will contain any fileoverview comment text from the original source file this\r\n *   file was generated from.\r\n * - updates generated files that are not in the given map of generatedFiles to have an empty\r\n *   list of statements as their body.\r\n */\r\nexport declare function getAngularEmitterTransformFactory(generatedFiles: Map<string, GeneratedFile>, program: ts.Program): () => (sourceFile: ts.SourceFile) => ts.SourceFile;\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/program.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { MessageBundle } from '@angular/compiler';\r\nimport * as path from 'path';\r\nimport * as ts from 'typescript';\r\nimport { CompilerHost, CompilerOptions, Program } from './api';\r\n/**\r\n * Checks whether a given version  [minVersion, maxVersion[\r\n * An error will be thrown if the following statements are simultaneously true:\r\n * - the given version  [minVersion, maxVersion[,\r\n * - the result of the version check is not meant to be bypassed (the parameter disableVersionCheck\r\n * is false)\r\n *\r\n * @param version The version on which the check will be performed\r\n * @param minVersion The lower bound version. A valid version needs to be greater than minVersion\r\n * @param maxVersion The upper bound version. A valid version needs to be strictly less than\r\n * maxVersion\r\n * @param disableVersionCheck Indicates whether version check should be bypassed\r\n *\r\n * @throws Will throw an error if the following statements are simultaneously true:\r\n * - the given version  [minVersion, maxVersion[,\r\n * - the result of the version check is not meant to be bypassed (the parameter disableVersionCheck\r\n * is false)\r\n */\r\nexport declare function checkVersion(version: string, minVersion: string, maxVersion: string, disableVersionCheck: boolean | undefined): void;\r\nexport declare function createProgram({ rootNames, options, host, oldProgram }: {\r\n    rootNames: ReadonlyArray<string>;\r\n    options: CompilerOptions;\r\n    host: CompilerHost;\r\n    oldProgram?: Program;\r\n}): Program;\r\n/**\r\n * Returns a function that can adjust a path from source path to out path,\r\n * based on an existing mapping from source to out path.\r\n *\r\n * TODO(tbosch): talk to the TypeScript team to expose their logic for calculating the `rootDir`\r\n * if none was specified.\r\n *\r\n * Note: This function works on normalized paths from typescript.\r\n *\r\n * @param outDir\r\n * @param outSrcMappings\r\n */\r\nexport declare function createSrcToOutPathMapper(outDir: string | undefined, sampleSrcFileName: string | undefined, sampleOutFileName: string | undefined, host?: {\r\n    dirname: typeof path.dirname;\r\n    resolve: typeof path.resolve;\r\n    relative: typeof path.relative;\r\n}): (srcFileName: string) => string;\r\nexport declare function i18nExtract(formatName: string | null, outFile: string | null, host: ts.CompilerHost, options: CompilerOptions, bundle: MessageBundle): string[];\r\nexport declare function i18nSerialize(bundle: MessageBundle, formatName: string, options: CompilerOptions): string;\r\nexport declare function i18nGetExtension(formatName: string): string;\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/r3_metadata_transform.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { PartialModule } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { MetadataTransformer, ValueTransform } from './metadata_cache';\r\nexport declare class PartialModuleMetadataTransformer implements MetadataTransformer {\r\n    private moduleMap;\r\n    constructor(modules: PartialModule[]);\r\n    start(sourceFile: ts.SourceFile): ValueTransform | undefined;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/r3_strip_decorators.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { StaticReflector, StaticSymbol } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport { MetadataTransformer, ValueTransform } from './metadata_cache';\r\nexport declare type Transformer = (sourceFile: ts.SourceFile) => ts.SourceFile;\r\nexport declare type TransformerFactory = (context: ts.TransformationContext) => Transformer;\r\nexport declare function getDecoratorStripTransformerFactory(coreDecorators: Set<StaticSymbol>, reflector: StaticReflector, checker: ts.TypeChecker): TransformerFactory;\r\nexport declare class StripDecoratorsMetadataTransformer implements MetadataTransformer {\r\n    private coreDecorators;\r\n    private reflector;\r\n    constructor(coreDecorators: Set<StaticSymbol>, reflector: StaticReflector);\r\n    start(sourceFile: ts.SourceFile): ValueTransform | undefined;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/r3_transform.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { PartialModule } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nexport declare type Transformer = (sourceFile: ts.SourceFile) => ts.SourceFile;\r\nexport declare type TransformerFactory = (context: ts.TransformationContext) => Transformer;\r\n/**\r\n * Returns a transformer that adds the requested static methods specified by modules.\r\n */\r\nexport declare function getAngularClassTransformerFactory(modules: PartialModule[]): TransformerFactory;\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/tsc_pass_through.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { GeneratedFile } from '@angular/compiler';\r\nimport * as ts from 'typescript';\r\nimport * as api from '../transformers/api';\r\n/**\r\n * An implementation of the `Program` API which behaves like plain `tsc` and does not include any\r\n * Angular-specific behavior whatsoever.\r\n *\r\n * This allows `ngc` to behave like `tsc` in cases where JIT code needs to be tested.\r\n */\r\nexport declare class TscPassThroughProgram implements api.Program {\r\n    private options;\r\n    private host;\r\n    private tsProgram;\r\n    constructor(rootNames: ReadonlyArray<string>, options: api.CompilerOptions, host: api.CompilerHost, oldProgram?: api.Program);\r\n    getTsProgram(): ts.Program;\r\n    getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<ts.Diagnostic>;\r\n    getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<api.Diagnostic>;\r\n    getTsSyntacticDiagnostics(sourceFile?: ts.SourceFile | undefined, cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<ts.Diagnostic>;\r\n    getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<api.Diagnostic>;\r\n    getTsSemanticDiagnostics(sourceFile?: ts.SourceFile | undefined, cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<ts.Diagnostic>;\r\n    getNgSemanticDiagnostics(fileName?: string | undefined, cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<api.Diagnostic>;\r\n    loadNgStructureAsync(): Promise<void>;\r\n    listLazyRoutes(entryRoute?: string | undefined): api.LazyRoute[];\r\n    getLibrarySummaries(): Map<string, api.LibrarySummary>;\r\n    getEmittedGeneratedFiles(): Map<string, GeneratedFile>;\r\n    getEmittedSourceFiles(): Map<string, ts.SourceFile>;\r\n    emit(opts?: {\r\n        emitFlags?: api.EmitFlags;\r\n        cancellationToken?: ts.CancellationToken;\r\n        customTransformers?: api.CustomTransformers;\r\n        emitCallback?: api.TsEmitCallback;\r\n        mergeEmitResultsCallback?: api.TsMergeEmitResultsCallback;\r\n    }): ts.EmitResult;\r\n}\r\n",
  "/node_modules/@angular/compiler-cli/src/transformers/util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ts from 'typescript';\r\nimport { CompilerOptions, Diagnostic } from './api';\r\nexport declare const GENERATED_FILES: RegExp;\r\nexport declare const DTS: RegExp;\r\nexport declare const TS: RegExp;\r\nexport declare const enum StructureIsReused {\r\n    Not = 0,\r\n    SafeModules = 1,\r\n    Completely = 2\r\n}\r\nexport declare function tsStructureIsReused(program: ts.Program): StructureIsReused;\r\nexport declare function error(msg: string): never;\r\nexport declare function userError(msg: string): never;\r\nexport declare function createMessageDiagnostic(messageText: string): ts.Diagnostic & Diagnostic;\r\nexport declare function isInRootDir(fileName: string, options: CompilerOptions): string | true;\r\nexport declare function relativeToRootDirs(filePath: string, rootDirs: string[]): string;\r\n/**\r\n * Converts a ng.Diagnostic into a ts.Diagnostic.\r\n * This looses some information, and also uses an incomplete object as `file`.\r\n *\r\n * I.e. only use this where the API allows only a ts.Diagnostic.\r\n */\r\nexport declare function ngToTsDiagnostic(ng: Diagnostic): ts.Diagnostic;\r\n",
  "/node_modules/@angular/compiler-cli/src/version.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @module\r\n * @description\r\n * Entry point for all public APIs of the common package.\r\n */\r\nimport { Version } from '@angular/compiler';\r\nexport declare const VERSION: Version;\r\n",
  "/node_modules/@angular/core/index.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport * from './public_api';\r\n",
  "/node_modules/@angular/core/public_api.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @module\r\n * @description\r\n * Entry point for all public APIs of this package.\r\n */\r\nexport * from './src/core';\r\n",
  "/node_modules/@angular/core/src/application_init.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { InjectionToken } from './di';\r\n/**\r\n * A function that will be executed when an application is initialized.\r\n */\r\nexport declare const APP_INITIALIZER: InjectionToken<(() => void)[]>;\r\n/**\r\n * A class that reflects the state of running {@link APP_INITIALIZER}s.\r\n */\r\nexport declare class ApplicationInitStatus {\r\n    private appInits;\r\n    private resolve;\r\n    private reject;\r\n    private initialized;\r\n    readonly donePromise: Promise<any>;\r\n    readonly done: boolean;\r\n    constructor(appInits: (() => any)[]);\r\n    /** @internal */\r\n    runInitializers(): void;\r\n}\r\n",
  "/node_modules/@angular/core/src/application_module.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ApplicationRef } from './application_ref';\r\nimport { IterableDiffers, KeyValueDiffers } from './change_detection/change_detection';\r\nimport { StaticProvider } from './di';\r\nexport declare function _iterableDiffersFactory(): IterableDiffers;\r\nexport declare function _keyValueDiffersFactory(): KeyValueDiffers;\r\nexport declare function _localeFactory(locale?: string): string;\r\nexport declare const APPLICATION_MODULE_PROVIDERS: StaticProvider[];\r\n/**\r\n * This module includes the providers of @angular/core that are needed\r\n * to bootstrap components via `ApplicationRef`.\r\n *\r\n * @experimental\r\n */\r\nexport declare class ApplicationModule {\r\n    constructor(appRef: ApplicationRef);\r\n}\r\n",
  "/node_modules/@angular/core/src/application_ref.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Observable } from 'rxjs';\r\nimport { ApplicationInitStatus } from './application_init';\r\nimport { Console } from './console';\r\nimport { InjectionToken, Injector, StaticProvider } from './di';\r\nimport { ErrorHandler } from './error_handler';\r\nimport { CompilerOptions } from './linker/compiler';\r\nimport { ComponentFactory, ComponentRef } from './linker/component_factory';\r\nimport { ComponentFactoryResolver } from './linker/component_factory_resolver';\r\nimport { NgModuleFactory, NgModuleRef } from './linker/ng_module_factory';\r\nimport { ViewRef } from './linker/view_ref';\r\nimport { WtfScopeFn } from './profile/profile';\r\nimport { Type } from './type';\r\nimport { NgZone } from './zone/ng_zone';\r\nexport declare const ALLOW_MULTIPLE_PLATFORMS: InjectionToken<boolean>;\r\n/**\r\n * A token for third-party components that can register themselves with NgProbe.\r\n *\r\n * @experimental\r\n */\r\nexport declare class NgProbeToken {\r\n    name: string;\r\n    token: any;\r\n    constructor(name: string, token: any);\r\n}\r\n/**\r\n * Creates a platform.\r\n * Platforms have to be eagerly created via this function.\r\n *\r\n * @experimental APIs related to application bootstrap are currently under review.\r\n */\r\nexport declare function createPlatform(injector: Injector): PlatformRef;\r\n/**\r\n * Creates a factory for a platform\r\n *\r\n * @experimental APIs related to application bootstrap are currently under review.\r\n */\r\nexport declare function createPlatformFactory(parentPlatformFactory: ((extraProviders?: StaticProvider[]) => PlatformRef) | null, name: string, providers?: StaticProvider[]): (extraProviders?: StaticProvider[]) => PlatformRef;\r\n/**\r\n * Checks that there currently is a platform which contains the given token as a provider.\r\n *\r\n * @experimental APIs related to application bootstrap are currently under review.\r\n */\r\nexport declare function assertPlatform(requiredToken: any): PlatformRef;\r\n/**\r\n * Destroy the existing platform.\r\n *\r\n * @experimental APIs related to application bootstrap are currently under review.\r\n */\r\nexport declare function destroyPlatform(): void;\r\n/**\r\n * Returns the current platform.\r\n *\r\n * @experimental APIs related to application bootstrap are currently under review.\r\n */\r\nexport declare function getPlatform(): PlatformRef | null;\r\n/**\r\n * Provides additional options to the bootstraping process.\r\n *\r\n *\r\n */\r\nexport interface BootstrapOptions {\r\n    /**\r\n     * Optionally specify which `NgZone` should be used.\r\n     *\r\n     * - Provide your own `NgZone` instance.\r\n     * - `zone.js` - Use default `NgZone` which requires `Zone.js`.\r\n     * - `noop` - Use `NoopNgZone` which does nothing.\r\n     */\r\n    ngZone?: NgZone | 'zone.js' | 'noop';\r\n}\r\n/**\r\n * The Angular platform is the entry point for Angular on a web page. Each page\r\n * has exactly one platform, and services (such as reflection) which are common\r\n * to every Angular application running on the page are bound in its scope.\r\n *\r\n * A page's platform is initialized implicitly when a platform is created via a platform factory\r\n * (e.g. {@link platformBrowser}), or explicitly by calling the {@link createPlatform} function.\r\n */\r\nexport declare class PlatformRef {\r\n    private _injector;\r\n    private _modules;\r\n    private _destroyListeners;\r\n    private _destroyed;\r\n    /** @internal */\r\n    constructor(_injector: Injector);\r\n    /**\r\n     * Creates an instance of an `@NgModule` for the given platform\r\n     * for offline compilation.\r\n     *\r\n     * @usageNotes\r\n     * ### Simple Example\r\n     *\r\n     * ```typescript\r\n     * my_module.ts:\r\n     *\r\n     * @NgModule({\r\n     *   imports: [BrowserModule]\r\n     * })\r\n     * class MyModule {}\r\n     *\r\n     * main.ts:\r\n     * import {MyModuleNgFactory} from './my_module.ngfactory';\r\n     * import {platformBrowser} from '@angular/platform-browser';\r\n     *\r\n     * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);\r\n     * ```\r\n     *\r\n     * @experimental APIs related to application bootstrap are currently under review.\r\n     */\r\n    bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>, options?: BootstrapOptions): Promise<NgModuleRef<M>>;\r\n    /**\r\n     * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.\r\n     *\r\n     * @usageNotes\r\n     * ### Simple Example\r\n     *\r\n     * ```typescript\r\n     * @NgModule({\r\n     *   imports: [BrowserModule]\r\n     * })\r\n     * class MyModule {}\r\n     *\r\n     * let moduleRef = platformBrowser().bootstrapModule(MyModule);\r\n     * ```\r\n     *\r\n     */\r\n    bootstrapModule<M>(moduleType: Type<M>, compilerOptions?: (CompilerOptions & BootstrapOptions) | Array<CompilerOptions & BootstrapOptions>): Promise<NgModuleRef<M>>;\r\n    private _moduleDoBootstrap;\r\n    /**\r\n     * Register a listener to be called when the platform is disposed.\r\n     */\r\n    onDestroy(callback: () => void): void;\r\n    /**\r\n     * Retrieve the platform {@link Injector}, which is the parent injector for\r\n     * every Angular application on the page and provides singleton providers.\r\n     */\r\n    readonly injector: Injector;\r\n    /**\r\n     * Destroy the Angular platform and all Angular applications on the page.\r\n     */\r\n    destroy(): void;\r\n    readonly destroyed: boolean;\r\n}\r\n/**\r\n * A reference to an Angular application running on a page.\r\n */\r\nexport declare class ApplicationRef {\r\n    private _zone;\r\n    private _console;\r\n    private _injector;\r\n    private _exceptionHandler;\r\n    private _componentFactoryResolver;\r\n    private _initStatus;\r\n    /** @internal */\r\n    static _tickScope: WtfScopeFn;\r\n    private _bootstrapListeners;\r\n    private _views;\r\n    private _runningTick;\r\n    private _enforceNoNewChanges;\r\n    private _stable;\r\n    /**\r\n     * Get a list of component types registered to this application.\r\n     * This list is populated even before the component is created.\r\n     */\r\n    readonly componentTypes: Type<any>[];\r\n    /**\r\n     * Get a list of components registered to this application.\r\n     */\r\n    readonly components: ComponentRef<any>[];\r\n    /**\r\n     * Returns an Observable that indicates when the application is stable or unstable.\r\n     */\r\n    readonly isStable: Observable<boolean>;\r\n    /** @internal */\r\n    constructor(_zone: NgZone, _console: Console, _injector: Injector, _exceptionHandler: ErrorHandler, _componentFactoryResolver: ComponentFactoryResolver, _initStatus: ApplicationInitStatus);\r\n    /**\r\n     * Bootstrap a new component at the root level of the application.\r\n     *\r\n     * @usageNotes\r\n     * ### Bootstrap process\r\n     *\r\n     * When bootstrapping a new root component into an application, Angular mounts the\r\n     * specified application component onto DOM elements identified by the componentType's\r\n     * selector and kicks off automatic change detection to finish initializing the component.\r\n     *\r\n     * Optionally, a component can be mounted onto a DOM element that does not match the\r\n     * componentType's selector.\r\n     *\r\n     * ### Example\r\n     * {@example core/ts/platform/platform.ts region='longform'}\r\n     */\r\n    bootstrap<C>(componentOrFactory: ComponentFactory<C> | Type<C>, rootSelectorOrNode?: string | any): ComponentRef<C>;\r\n    /**\r\n     * Invoke this method to explicitly process change detection and its side-effects.\r\n     *\r\n     * In development mode, `tick()` also performs a second change detection cycle to ensure that no\r\n     * further changes are detected. If additional changes are picked up during this second cycle,\r\n     * bindings in the app have side-effects that cannot be resolved in a single change detection\r\n     * pass.\r\n     * In this case, Angular throws an error, since an Angular application can only have one change\r\n     * detection pass during which all change detection must complete.\r\n     */\r\n    tick(): void;\r\n    /**\r\n     * Attaches a view so that it will be dirty checked.\r\n     * The view will be automatically detached when it is destroyed.\r\n     * This will throw if the view is already attached to a ViewContainer.\r\n     */\r\n    attachView(viewRef: ViewRef): void;\r\n    /**\r\n     * Detaches a view from dirty checking again.\r\n     */\r\n    detachView(viewRef: ViewRef): void;\r\n    private _loadComponent;\r\n    private _unloadComponent;\r\n    /** @internal */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * Returns the number of attached views.\r\n     */\r\n    readonly viewCount: number;\r\n}\r\n",
  "/node_modules/@angular/core/src/application_tokens.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { InjectionToken } from './di';\r\nimport { ComponentRef } from './linker/component_factory';\r\n/**\r\n * A DI Token representing a unique string id assigned to the application by Angular and used\r\n * primarily for prefixing application attributes and CSS styles when\r\n * {@link ViewEncapsulation#Emulated ViewEncapsulation.Emulated} is being used.\r\n *\r\n * If you need to avoid randomly generated value to be used as an application id, you can provide\r\n * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}\r\n * using this token.\r\n * @experimental\r\n */\r\nexport declare const APP_ID: InjectionToken<string>;\r\nexport declare function _appIdRandomProviderFactory(): string;\r\n/**\r\n * Providers that will generate a random APP_ID_TOKEN.\r\n * @experimental\r\n */\r\nexport declare const APP_ID_RANDOM_PROVIDER: {\r\n    provide: InjectionToken<string>;\r\n    useFactory: typeof _appIdRandomProviderFactory;\r\n    deps: any[];\r\n};\r\n/**\r\n * A function that will be executed when a platform is initialized.\r\n * @experimental\r\n */\r\nexport declare const PLATFORM_INITIALIZER: InjectionToken<(() => void)[]>;\r\n/**\r\n * A token that indicates an opaque platform id.\r\n * @experimental\r\n */\r\nexport declare const PLATFORM_ID: InjectionToken<Object>;\r\n/**\r\n * All callbacks provided via this token will be called for every component that is bootstrapped.\r\n * Signature of the callback:\r\n *\r\n * `(componentRef: ComponentRef) => void`.\r\n *\r\n * @experimental\r\n */\r\nexport declare const APP_BOOTSTRAP_LISTENER: InjectionToken<((compRef: ComponentRef<any>) => void)[]>;\r\n/**\r\n * A token which indicates the root directory of the application\r\n * @experimental\r\n */\r\nexport declare const PACKAGE_ROOT_URL: InjectionToken<string>;\r\n",
  "/node_modules/@angular/core/src/change_detection/change_detection.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { IterableDiffers } from './differs/iterable_differs';\r\nimport { KeyValueDiffers } from './differs/keyvalue_differs';\r\nexport { SimpleChanges } from '../metadata/lifecycle_hooks';\r\nexport { SimpleChange, WrappedValue, devModeEqual } from './change_detection_util';\r\nexport { ChangeDetectorRef } from './change_detector_ref';\r\nexport { ChangeDetectionStrategy, ChangeDetectorStatus, isDefaultChangeDetectionStrategy } from './constants';\r\nexport { DefaultIterableDifferFactory } from './differs/default_iterable_differ';\r\nexport { DefaultIterableDiffer } from './differs/default_iterable_differ';\r\nexport { DefaultKeyValueDifferFactory } from './differs/default_keyvalue_differ';\r\nexport { CollectionChangeRecord, IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, IterableDiffers, NgIterable, TrackByFunction } from './differs/iterable_differs';\r\nexport { KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers } from './differs/keyvalue_differs';\r\nexport { PipeTransform } from './pipe_transform';\r\nexport declare const defaultIterableDiffers: IterableDiffers;\r\nexport declare const defaultKeyValueDiffers: KeyValueDiffers;\r\n",
  "/node_modules/@angular/core/src/change_detection/change_detection_util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare function devModeEqual(a: any, b: any): boolean;\r\n/**\r\n * Indicates that the result of a {@link Pipe} transformation has changed even though the\r\n * reference has not changed.\r\n *\r\n * Wrapped values are unwrapped automatically during the change detection, and the unwrapped value\r\n * is stored.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * if (this._latestValue === this._latestReturnedValue) {\r\n *    return this._latestReturnedValue;\r\n *  } else {\r\n *    this._latestReturnedValue = this._latestValue;\r\n *    return WrappedValue.wrap(this._latestValue); // this will force update\r\n *  }\r\n * ```\r\n *\r\n */\r\nexport declare class WrappedValue {\r\n    /** @deprecated from 5.3, use `unwrap()` instead - will switch to protected */\r\n    wrapped: any;\r\n    constructor(value: any);\r\n    /** Creates a wrapped value. */\r\n    static wrap(value: any): WrappedValue;\r\n    /**\r\n     * Returns the underlying value of a wrapped value.\r\n     * Returns the given `value` when it is not wrapped.\r\n     **/\r\n    static unwrap(value: any): any;\r\n    /** Returns true if `value` is a wrapped value. */\r\n    static isWrapped(value: any): value is WrappedValue;\r\n}\r\n/**\r\n * Represents a basic change from a previous to a new value.\r\n *\r\n */\r\nexport declare class SimpleChange {\r\n    previousValue: any;\r\n    currentValue: any;\r\n    firstChange: boolean;\r\n    constructor(previousValue: any, currentValue: any, firstChange: boolean);\r\n    /**\r\n     * Check whether the new value is the first value assigned.\r\n     */\r\n    isFirstChange(): boolean;\r\n}\r\nexport declare function isListLikeIterable(obj: any): boolean;\r\nexport declare function areIterablesEqual(a: any, b: any, comparator: (a: any, b: any) => boolean): boolean;\r\nexport declare function iterateListLike(obj: any, fn: (p: any) => any): void;\r\nexport declare function isJsObject(o: any): boolean;\r\n",
  "/node_modules/@angular/core/src/change_detection/change_detector_ref.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Base class for Angular Views, provides change detection functionality.\r\n * A change-detection tree collects all views that are to be checked for changes.\r\n * Use the methods to add and remove views from the tree, initiate change-detection,\r\n * and explicitly mark views as _dirty_, meaning that they have changed and need to be rerendered.\r\n *\r\n * @usageNotes\r\n *\r\n * The following examples demonstrate how to modify default change-detection behavior\r\n * to perform explicit detection when needed.\r\n *\r\n * ### Use `markForCheck()` with `CheckOnce` strategy\r\n *\r\n * The following example sets the `OnPush` change-detection strategy for a component\r\n * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check\r\n * after an interval. See [live demo](http://plnkr.co/edit/GC512b?p=preview).\r\n *\r\n * <code-example path=\"core/ts/change_detect/change-detection.ts\"\r\n * region=\"mark-for-check\"></code-example>\r\n *\r\n * ### Detach change detector to limit how often check occurs\r\n *\r\n * The following example defines a component with a large list of read-only data\r\n * that is expected to change constantly, many times per second.\r\n * To improve performance, we want to check and update the list\r\n * less often than the changes actually occur. To do that, we detach\r\n * the component's change detector and perform an explicit local check every five seconds.\r\n *\r\n * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"detach\"></code-example>\r\n *\r\n *\r\n * ### Reattaching a detached component\r\n *\r\n * The following example creates a component displaying live data.\r\n * The component detaches its change detector from the main change detector tree\r\n * when the `live` property is set to false, and reattaches it when the property\r\n * becomes true.\r\n *\r\n * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"detach\"></code-example>\r\n *\r\n */\r\nexport declare abstract class ChangeDetectorRef {\r\n    /**\r\n     * When a view uses the {@link ChangeDetectionStrategy#OnPush OnPush} (checkOnce)\r\n     * change detection strategy, explicitly marks the view as changed so that\r\n     * it can be checked again.\r\n     *\r\n     * Components are normally marked as dirty (in need of rerendering) when inputs\r\n     * have changed or events have fired in the view. Call this method to ensure that\r\n     * a component is checked even if these triggers have not occured.\r\n     *\r\n     * <!-- TODO: Add a link to a chapter on OnPush components -->\r\n     *\r\n     */\r\n    abstract markForCheck(): void;\r\n    /**\r\n     * Detaches this view from the change-detection tree.\r\n     * A detached view is  not checked until it is reattached.\r\n     * Use in combination with `detectChanges()` to implement local change detection checks.\r\n     *\r\n     * Detached views are not checked during change detection runs until they are\r\n     * re-attached, even if they are marked as dirty.\r\n     *\r\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\r\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\r\n     *\r\n     */\r\n    abstract detach(): void;\r\n    /**\r\n     * Checks this view and its children. Use in combination with {@link ChangeDetectorRef#detach\r\n     * detach}\r\n     * to implement local change detection checks.\r\n     *\r\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\r\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\r\n     *\r\n     */\r\n    abstract detectChanges(): void;\r\n    /**\r\n     * Checks the change detector and its children, and throws if any changes are detected.\r\n     *\r\n     * Use in development mode to verify that running change detection doesn't introduce\r\n     * other changes.\r\n     */\r\n    abstract checkNoChanges(): void;\r\n    /**\r\n     * Re-attaches the previously detached view to the change detection tree.\r\n     * Views are attached to the tree by default.\r\n     *\r\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\r\n     *\r\n     */\r\n    abstract reattach(): void;\r\n}\r\n",
  "/node_modules/@angular/core/src/change_detection/constants.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * The strategy that the default change detector uses to detect changes.\r\n * When set, takes effect the next time change detection is triggered.\r\n *\r\n */\r\nexport declare enum ChangeDetectionStrategy {\r\n    /**\r\n     * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\r\n     * until reactivated by setting the strategy to `Default` (`CheckAlways`).\r\n     * Change detection can still be explictly invoked.\r\n     */\r\n    OnPush = 0,\r\n    /**\r\n     * Use the default `CheckAlways` strategy, in which change detection is automatic until\r\n     * explicitly deactivated.\r\n     */\r\n    Default = 1\r\n}\r\n/**\r\n * Defines the possible states of the default change detector.\r\n * @see `ChangeDetectorRef`\r\n */\r\nexport declare enum ChangeDetectorStatus {\r\n    /**\r\n     * A state in which, after calling `detectChanges()`, the change detector\r\n     * state becomes `Checked`, and must be explicitly invoked or reactivated.\r\n     */\r\n    CheckOnce = 0,\r\n    /**\r\n     * A state in which change detection is skipped until the change detector mode\r\n     * becomes `CheckOnce`.\r\n     */\r\n    Checked = 1,\r\n    /**\r\n     * A state in which change detection continues automatically until explictly\r\n     * deactivated.\r\n     */\r\n    CheckAlways = 2,\r\n    /**\r\n     * A state in which a change detector sub tree is not a part of the main tree and\r\n     * should be skipped.\r\n     */\r\n    Detached = 3,\r\n    /**\r\n     * Indicates that the change detector encountered an error checking a binding\r\n     * or calling a directive lifecycle method and is now in an inconsistent state. Change\r\n     * detectors in this state do not detect changes.\r\n     */\r\n    Errored = 4,\r\n    /**\r\n     * Indicates that the change detector has been destroyed.\r\n     */\r\n    Destroyed = 5\r\n}\r\n/**\r\n * Reports whether a given strategy is currently the default for change detection.\r\n * @param changeDetectionStrategy The strategy to check.\r\n * @returns True if the given strategy is the current default, false otherwise.\r\n * @see `ChangeDetectorStatus`\r\n * @see `ChangeDetectorRef`\r\n */\r\nexport declare function isDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy): boolean;\r\n",
  "/node_modules/@angular/core/src/change_detection/differs/default_iterable_differ.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, NgIterable, TrackByFunction } from './iterable_differs';\r\nexport declare class DefaultIterableDifferFactory implements IterableDifferFactory {\r\n    constructor();\r\n    supports(obj: Object | null | undefined): boolean;\r\n    create<V>(trackByFn?: TrackByFunction<V>): DefaultIterableDiffer<V>;\r\n}\r\n/**\r\n * @deprecated v4.0.0 - Should not be part of public API.\r\n */\r\nexport declare class DefaultIterableDiffer<V> implements IterableDiffer<V>, IterableChanges<V> {\r\n    readonly length: number;\r\n    readonly collection: V[] | Iterable<V> | null;\r\n    private _linkedRecords;\r\n    private _unlinkedRecords;\r\n    private _previousItHead;\r\n    private _itHead;\r\n    private _itTail;\r\n    private _additionsHead;\r\n    private _additionsTail;\r\n    private _movesHead;\r\n    private _movesTail;\r\n    private _removalsHead;\r\n    private _removalsTail;\r\n    private _identityChangesHead;\r\n    private _identityChangesTail;\r\n    private _trackByFn;\r\n    constructor(trackByFn?: TrackByFunction<V>);\r\n    forEachItem(fn: (record: IterableChangeRecord_<V>) => void): void;\r\n    forEachOperation(fn: (item: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;\r\n    forEachPreviousItem(fn: (record: IterableChangeRecord_<V>) => void): void;\r\n    forEachAddedItem(fn: (record: IterableChangeRecord_<V>) => void): void;\r\n    forEachMovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;\r\n    forEachRemovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;\r\n    forEachIdentityChange(fn: (record: IterableChangeRecord_<V>) => void): void;\r\n    diff(collection: NgIterable<V>): DefaultIterableDiffer<V> | null;\r\n    onDestroy(): void;\r\n    check(collection: NgIterable<V>): boolean;\r\n    readonly isDirty: boolean;\r\n    /**\r\n     * Reset the state of the change objects to show no changes. This means set previousKey to\r\n     * currentKey, and clear all of the queues (additions, moves, removals).\r\n     * Set the previousIndexes of moved and added items to their currentIndexes\r\n     * Reset the list of additions, moves and removals\r\n     *\r\n     * @internal\r\n     */\r\n    _reset(): void;\r\n    /**\r\n     * This is the core function which handles differences between collections.\r\n     *\r\n     * - `record` is the record which we saw at this position last time. If null then it is a new\r\n     *   item.\r\n     * - `item` is the current item in the collection\r\n     * - `index` is the position of the item in the collection\r\n     *\r\n     * @internal\r\n     */\r\n    _mismatch(record: IterableChangeRecord_<V> | null, item: V, itemTrackBy: any, index: number): IterableChangeRecord_<V>;\r\n    /**\r\n     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)\r\n     *\r\n     * Use case: `[a, a]` => `[b, a, a]`\r\n     *\r\n     * If we did not have this check then the insertion of `b` would:\r\n     *   1) evict first `a`\r\n     *   2) insert `b` at `0` index.\r\n     *   3) leave `a` at index `1` as is. <-- this is wrong!\r\n     *   3) reinsert `a` at index 2. <-- this is wrong!\r\n     *\r\n     * The correct behavior is:\r\n     *   1) evict first `a`\r\n     *   2) insert `b` at `0` index.\r\n     *   3) reinsert `a` at index 1.\r\n     *   3) move `a` at from `1` to `2`.\r\n     *\r\n     *\r\n     * Double check that we have not evicted a duplicate item. We need to check if the item type may\r\n     * have already been removed:\r\n     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted\r\n     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a\r\n     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'\r\n     * at the end.\r\n     *\r\n     * @internal\r\n     */\r\n    _verifyReinsertion(record: IterableChangeRecord_<V>, item: V, itemTrackBy: any, index: number): IterableChangeRecord_<V>;\r\n    /**\r\n     * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection\r\n     *\r\n     * - `record` The first excess {@link IterableChangeRecord_}.\r\n     *\r\n     * @internal\r\n     */\r\n    _truncate(record: IterableChangeRecord_<V> | null): void;\r\n    /** @internal */\r\n    _reinsertAfter(record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V> | null, index: number): IterableChangeRecord_<V>;\r\n    /** @internal */\r\n    _moveAfter(record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V> | null, index: number): IterableChangeRecord_<V>;\r\n    /** @internal */\r\n    _addAfter(record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V> | null, index: number): IterableChangeRecord_<V>;\r\n    /** @internal */\r\n    _insertAfter(record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V> | null, index: number): IterableChangeRecord_<V>;\r\n    /** @internal */\r\n    _remove(record: IterableChangeRecord_<V>): IterableChangeRecord_<V>;\r\n    /** @internal */\r\n    _unlink(record: IterableChangeRecord_<V>): IterableChangeRecord_<V>;\r\n    /** @internal */\r\n    _addToMoves(record: IterableChangeRecord_<V>, toIndex: number): IterableChangeRecord_<V>;\r\n    private _addToRemovals;\r\n    /** @internal */\r\n    _addIdentityChange(record: IterableChangeRecord_<V>, item: V): IterableChangeRecord_<V>;\r\n}\r\nexport declare class IterableChangeRecord_<V> implements IterableChangeRecord<V> {\r\n    item: V;\r\n    trackById: any;\r\n    currentIndex: number | null;\r\n    previousIndex: number | null;\r\n    /** @internal */\r\n    _nextPrevious: IterableChangeRecord_<V> | null;\r\n    /** @internal */\r\n    _prev: IterableChangeRecord_<V> | null;\r\n    /** @internal */\r\n    _next: IterableChangeRecord_<V> | null;\r\n    /** @internal */\r\n    _prevDup: IterableChangeRecord_<V> | null;\r\n    /** @internal */\r\n    _nextDup: IterableChangeRecord_<V> | null;\r\n    /** @internal */\r\n    _prevRemoved: IterableChangeRecord_<V> | null;\r\n    /** @internal */\r\n    _nextRemoved: IterableChangeRecord_<V> | null;\r\n    /** @internal */\r\n    _nextAdded: IterableChangeRecord_<V> | null;\r\n    /** @internal */\r\n    _nextMoved: IterableChangeRecord_<V> | null;\r\n    /** @internal */\r\n    _nextIdentityChange: IterableChangeRecord_<V> | null;\r\n    constructor(item: V, trackById: any);\r\n}\r\n",
  "/node_modules/@angular/core/src/change_detection/differs/default_keyvalue_differ.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory } from './keyvalue_differs';\r\nexport declare class DefaultKeyValueDifferFactory<K, V> implements KeyValueDifferFactory {\r\n    constructor();\r\n    supports(obj: any): boolean;\r\n    create<K, V>(): KeyValueDiffer<K, V>;\r\n}\r\nexport declare class DefaultKeyValueDiffer<K, V> implements KeyValueDiffer<K, V>, KeyValueChanges<K, V> {\r\n    private _records;\r\n    private _mapHead;\r\n    private _appendAfter;\r\n    private _previousMapHead;\r\n    private _changesHead;\r\n    private _changesTail;\r\n    private _additionsHead;\r\n    private _additionsTail;\r\n    private _removalsHead;\r\n    private _removalsTail;\r\n    readonly isDirty: boolean;\r\n    forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\r\n    forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\r\n    forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\r\n    forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\r\n    forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\r\n    diff(map?: Map<any, any> | {\r\n        [k: string]: any;\r\n    } | null): any;\r\n    onDestroy(): void;\r\n    /**\r\n     * Check the current state of the map vs the previous.\r\n     * The algorithm is optimised for when the keys do no change.\r\n     */\r\n    check(map: Map<any, any> | {\r\n        [k: string]: any;\r\n    }): boolean;\r\n    /**\r\n     * Inserts a record before `before` or append at the end of the list when `before` is null.\r\n     *\r\n     * Notes:\r\n     * - This method appends at `this._appendAfter`,\r\n     * - This method updates `this._appendAfter`,\r\n     * - The return value is the new value for the insertion pointer.\r\n     */\r\n    private _insertBeforeOrAppend;\r\n    private _getOrCreateRecordForKey;\r\n    /** @internal */\r\n    _reset(): void;\r\n    private _maybeAddToChanges;\r\n    private _addToAdditions;\r\n    private _addToChanges;\r\n    /** @internal */\r\n    private _forEach;\r\n}\r\n",
  "/node_modules/@angular/core/src/change_detection/differs/iterable_differs.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { StaticProvider } from '../../di/provider';\r\n/**\r\n * A type describing supported iterable types.\r\n *\r\n *\r\n */\r\nexport declare type NgIterable<T> = Array<T> | Iterable<T>;\r\n/**\r\n * A strategy for tracking changes over time to an iterable. Used by {@link NgForOf} to\r\n * respond to changes in an iterable by effecting equivalent changes in the DOM.\r\n *\r\n *\r\n */\r\nexport interface IterableDiffer<V> {\r\n    /**\r\n     * Compute a difference between the previous state and the new `object` state.\r\n     *\r\n     * @param object containing the new value.\r\n     * @returns an object describing the difference. The return value is only valid until the next\r\n     * `diff()` invocation.\r\n     */\r\n    diff(object: NgIterable<V>): IterableChanges<V> | null;\r\n}\r\n/**\r\n * An object describing the changes in the `Iterable` collection since last time\r\n * `IterableDiffer#diff()` was invoked.\r\n *\r\n *\r\n */\r\nexport interface IterableChanges<V> {\r\n    /**\r\n     * Iterate over all changes. `IterableChangeRecord` will contain information about changes\r\n     * to each item.\r\n     */\r\n    forEachItem(fn: (record: IterableChangeRecord<V>) => void): void;\r\n    /**\r\n     * Iterate over a set of operations which when applied to the original `Iterable` will produce the\r\n     * new `Iterable`.\r\n     *\r\n     * NOTE: These are not necessarily the actual operations which were applied to the original\r\n     * `Iterable`, rather these are a set of computed operations which may not be the same as the\r\n     * ones applied.\r\n     *\r\n     * @param record A change which needs to be applied\r\n     * @param previousIndex The `IterableChangeRecord#previousIndex` of the `record` refers to the\r\n     *        original `Iterable` location, where as `previousIndex` refers to the transient location\r\n     *        of the item, after applying the operations up to this point.\r\n     * @param currentIndex The `IterableChangeRecord#currentIndex` of the `record` refers to the\r\n     *        original `Iterable` location, where as `currentIndex` refers to the transient location\r\n     *        of the item, after applying the operations up to this point.\r\n     */\r\n    forEachOperation(fn: (record: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;\r\n    /**\r\n     * Iterate over changes in the order of original `Iterable` showing where the original items\r\n     * have moved.\r\n     */\r\n    forEachPreviousItem(fn: (record: IterableChangeRecord<V>) => void): void;\r\n    /** Iterate over all added items. */\r\n    forEachAddedItem(fn: (record: IterableChangeRecord<V>) => void): void;\r\n    /** Iterate over all moved items. */\r\n    forEachMovedItem(fn: (record: IterableChangeRecord<V>) => void): void;\r\n    /** Iterate over all removed items. */\r\n    forEachRemovedItem(fn: (record: IterableChangeRecord<V>) => void): void;\r\n    /** Iterate over all items which had their identity (as computed by the `TrackByFunction`)\r\n     * changed. */\r\n    forEachIdentityChange(fn: (record: IterableChangeRecord<V>) => void): void;\r\n}\r\n/**\r\n * Record representing the item change information.\r\n *\r\n *\r\n */\r\nexport interface IterableChangeRecord<V> {\r\n    /** Current index of the item in `Iterable` or null if removed. */\r\n    readonly currentIndex: number | null;\r\n    /** Previous index of the item in `Iterable` or null if added. */\r\n    readonly previousIndex: number | null;\r\n    /** The item. */\r\n    readonly item: V;\r\n    /** Track by identity as computed by the `TrackByFunction`. */\r\n    readonly trackById: any;\r\n}\r\n/**\r\n * @deprecated v4.0.0 - Use IterableChangeRecord instead.\r\n */\r\nexport interface CollectionChangeRecord<V> extends IterableChangeRecord<V> {\r\n}\r\n/**\r\n * An optional function passed into {@link NgForOf} that defines how to track\r\n * items in an iterable (e.g. fby index or id)\r\n *\r\n *\r\n */\r\nexport interface TrackByFunction<T> {\r\n    (index: number, item: T): any;\r\n}\r\n/**\r\n * Provides a factory for {@link IterableDiffer}.\r\n *\r\n *\r\n */\r\nexport interface IterableDifferFactory {\r\n    supports(objects: any): boolean;\r\n    create<V>(trackByFn?: TrackByFunction<V>): IterableDiffer<V>;\r\n}\r\n/**\r\n * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.\r\n *\r\n */\r\nexport declare class IterableDiffers {\r\n    static ngInjectableDef: never;\r\n    /**\r\n     * @deprecated v4.0.0 - Should be private\r\n     */\r\n    factories: IterableDifferFactory[];\r\n    constructor(factories: IterableDifferFactory[]);\r\n    static create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers;\r\n    /**\r\n     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the\r\n     * inherited {@link IterableDiffers} instance with the provided factories and return a new\r\n     * {@link IterableDiffers} instance.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * The following example shows how to extend an existing list of factories,\r\n     * which will only be applied to the injector for this component and its children.\r\n     * This step is all that's required to make a new {@link IterableDiffer} available.\r\n     *\r\n     * ```\r\n     * @Component({\r\n     *   viewProviders: [\r\n     *     IterableDiffers.extend([new ImmutableListDiffer()])\r\n     *   ]\r\n     * })\r\n     * ```\r\n     */\r\n    static extend(factories: IterableDifferFactory[]): StaticProvider;\r\n    find(iterable: any): IterableDifferFactory;\r\n}\r\nexport declare function getTypeNameForDebugging(type: any): string;\r\n",
  "/node_modules/@angular/core/src/change_detection/differs/keyvalue_differs.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { StaticProvider } from '../../di';\r\n/**\r\n * A differ that tracks changes made to an object over time.\r\n *\r\n *\r\n */\r\nexport interface KeyValueDiffer<K, V> {\r\n    /**\r\n     * Compute a difference between the previous state and the new `object` state.\r\n     *\r\n     * @param object containing the new value.\r\n     * @returns an object describing the difference. The return value is only valid until the next\r\n     * `diff()` invocation.\r\n     */\r\n    diff(object: Map<K, V>): KeyValueChanges<K, V> | null;\r\n    /**\r\n     * Compute a difference between the previous state and the new `object` state.\r\n     *\r\n     * @param object containing the new value.\r\n     * @returns an object describing the difference. The return value is only valid until the next\r\n     * `diff()` invocation.\r\n     */\r\n    diff(object: {\r\n        [key: string]: V;\r\n    }): KeyValueChanges<string, V> | null;\r\n}\r\n/**\r\n * An object describing the changes in the `Map` or `{[k:string]: string}` since last time\r\n * `KeyValueDiffer#diff()` was invoked.\r\n *\r\n *\r\n */\r\nexport interface KeyValueChanges<K, V> {\r\n    /**\r\n     * Iterate over all changes. `KeyValueChangeRecord` will contain information about changes\r\n     * to each item.\r\n     */\r\n    forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\r\n    /**\r\n     * Iterate over changes in the order of original Map showing where the original items\r\n     * have moved.\r\n     */\r\n    forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\r\n    /**\r\n     * Iterate over all keys for which values have changed.\r\n     */\r\n    forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\r\n    /**\r\n     * Iterate over all added items.\r\n     */\r\n    forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\r\n    /**\r\n     * Iterate over all removed items.\r\n     */\r\n    forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\r\n}\r\n/**\r\n * Record representing the item change information.\r\n *\r\n *\r\n */\r\nexport interface KeyValueChangeRecord<K, V> {\r\n    /**\r\n     * Current key in the Map.\r\n     */\r\n    readonly key: K;\r\n    /**\r\n     * Current value for the key or `null` if removed.\r\n     */\r\n    readonly currentValue: V | null;\r\n    /**\r\n     * Previous value for the key or `null` if added.\r\n     */\r\n    readonly previousValue: V | null;\r\n}\r\n/**\r\n * Provides a factory for {@link KeyValueDiffer}.\r\n *\r\n *\r\n */\r\nexport interface KeyValueDifferFactory {\r\n    /**\r\n     * Test to see if the differ knows how to diff this kind of object.\r\n     */\r\n    supports(objects: any): boolean;\r\n    /**\r\n     * Create a `KeyValueDiffer`.\r\n     */\r\n    create<K, V>(): KeyValueDiffer<K, V>;\r\n}\r\n/**\r\n * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.\r\n *\r\n */\r\nexport declare class KeyValueDiffers {\r\n    /**\r\n     * @deprecated v4.0.0 - Should be private.\r\n     */\r\n    factories: KeyValueDifferFactory[];\r\n    constructor(factories: KeyValueDifferFactory[]);\r\n    static create<S>(factories: KeyValueDifferFactory[], parent?: KeyValueDiffers): KeyValueDiffers;\r\n    /**\r\n     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the\r\n     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\r\n     * {@link KeyValueDiffers} instance.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * The following example shows how to extend an existing list of factories,\r\n     * which will only be applied to the injector for this component and its children.\r\n     * This step is all that's required to make a new {@link KeyValueDiffer} available.\r\n     *\r\n     * ```\r\n     * @Component({\r\n     *   viewProviders: [\r\n     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\r\n     *   ]\r\n     * })\r\n     * ```\r\n     */\r\n    static extend<S>(factories: KeyValueDifferFactory[]): StaticProvider;\r\n    find(kv: any): KeyValueDifferFactory;\r\n}\r\n",
  "/node_modules/@angular/core/src/change_detection/pipe_transform.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * To create a Pipe, you must implement this interface.\r\n *\r\n * Angular invokes the `transform` method with the value of a binding\r\n * as the first argument, and any parameters as the second argument in list form.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * The `RepeatPipe` below repeats the value as many times as indicated by the first argument:\r\n *\r\n * ```\r\n * import {Pipe, PipeTransform} from '@angular/core';\r\n *\r\n * @Pipe({name: 'repeat'})\r\n * export class RepeatPipe implements PipeTransform {\r\n *   transform(value: any, times: number) {\r\n *     return value.repeat(times);\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Invoking `{{ 'ok' | repeat:3 }}` in a template produces `okokok`.\r\n *\r\n *\r\n */\r\nexport interface PipeTransform {\r\n    transform(value: any, ...args: any[]): any;\r\n}\r\n",
  "/node_modules/@angular/core/src/change_detection.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @module\r\n * @description\r\n * Change detection enables data binding in Angular.\r\n */\r\nexport { ChangeDetectionStrategy, ChangeDetectorRef, CollectionChangeRecord, DefaultIterableDiffer, IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, IterableDiffers, KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers, NgIterable, PipeTransform, SimpleChange, SimpleChanges, TrackByFunction, WrappedValue } from './change_detection/change_detection';\r\n",
  "/node_modules/@angular/core/src/codegen_private_exports.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { CodegenComponentFactoryResolver as CodegenComponentFactoryResolver } from './linker/component_factory_resolver';\r\nexport { registerModuleFactory as registerModuleFactory } from './linker/ng_module_factory_loader';\r\nexport { ArgumentType as ArgumentType, BindingFlags as BindingFlags, DepFlags as DepFlags, EMPTY_ARRAY as EMPTY_ARRAY, EMPTY_MAP as EMPTY_MAP, NodeFlags as NodeFlags, QueryBindingType as QueryBindingType, QueryValueType as QueryValueType, ViewDefinition as ViewDefinition, ViewFlags as ViewFlags, anchorDef as and, createComponentFactory as ccf, createNgModuleFactory as cmf, createRendererType2 as crt, directiveDef as did, elementDef as eld, elementEventFullName as elementEventFullName, getComponentViewDefinitionFactory as getComponentViewDefinitionFactory, inlineInterpolate as inlineInterpolate, interpolate as interpolate, moduleDef as mod, moduleProvideDef as mpd, ngContentDef as ncd, nodeValue as nov, pipeDef as pid, providerDef as prd, pureArrayDef as pad, pureObjectDef as pod, purePipeDef as ppd, queryDef as qud, textDef as ted, unwrapValue as unv, viewDef as vid } from './view/index';\r\n",
  "/node_modules/@angular/core/src/console.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare class Console {\r\n    log(message: string): void;\r\n    warn(message: string): void;\r\n}\r\n",
  "/node_modules/@angular/core/src/core.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @module\r\n * @description\r\n * Entry point from which you should import all public core APIs.\r\n */\r\nexport * from './metadata';\r\nexport * from './version';\r\nexport { TypeDecorator } from './util/decorators';\r\nexport * from './di';\r\nexport { createPlatform, assertPlatform, destroyPlatform, getPlatform, PlatformRef, ApplicationRef, createPlatformFactory, NgProbeToken } from './application_ref';\r\nexport { enableProdMode, isDevMode } from './is_dev_mode';\r\nexport { APP_ID, PACKAGE_ROOT_URL, PLATFORM_INITIALIZER, PLATFORM_ID, APP_BOOTSTRAP_LISTENER } from './application_tokens';\r\nexport { APP_INITIALIZER, ApplicationInitStatus } from './application_init';\r\nexport * from './zone';\r\nexport * from './render';\r\nexport * from './linker';\r\nexport { DebugElement, DebugNode, asNativeElements, getDebugNode, Predicate } from './debug/debug_node';\r\nexport { GetTestability, Testability, TestabilityRegistry, setTestabilityGetter } from './testability/testability';\r\nexport * from './change_detection';\r\nexport * from './platform_core_providers';\r\nexport { TRANSLATIONS, TRANSLATIONS_FORMAT, LOCALE_ID, MissingTranslationStrategy } from './i18n/tokens';\r\nexport { ApplicationModule } from './application_module';\r\nexport { wtfCreateScope, wtfLeave, wtfStartTimeRange, wtfEndTimeRange, WtfScopeFn } from './profile/profile';\r\nexport { Type } from './type';\r\nexport { EventEmitter } from './event_emitter';\r\nexport { ErrorHandler } from './error_handler';\r\nexport * from './core_private_export';\r\nexport * from './core_render3_private_export';\r\nexport { Sanitizer, SecurityContext } from './sanitization/security';\r\nexport * from './codegen_private_exports';\r\n",
  "/node_modules/@angular/core/src/core_private_export.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { ALLOW_MULTIPLE_PLATFORMS as ALLOW_MULTIPLE_PLATFORMS } from './application_ref';\r\nexport { APP_ID_RANDOM_PROVIDER as APP_ID_RANDOM_PROVIDER } from './application_tokens';\r\nexport { defaultIterableDiffers as defaultIterableDiffers, defaultKeyValueDiffers as defaultKeyValueDiffers } from './change_detection/change_detection';\r\nexport { devModeEqual as devModeEqual } from './change_detection/change_detection_util';\r\nexport { isListLikeIterable as isListLikeIterable } from './change_detection/change_detection_util';\r\nexport { ChangeDetectorStatus as ChangeDetectorStatus, isDefaultChangeDetectionStrategy as isDefaultChangeDetectionStrategy } from './change_detection/constants';\r\nexport { Console as Console } from './console';\r\nexport { InjectableDef as InjectableDef, InjectorDef as InjectorDef, getInjectableDef as getInjectableDef } from './di/defs';\r\nexport { inject as inject, setCurrentInjector as setCurrentInjector } from './di/injector';\r\nexport { APP_ROOT as APP_ROOT } from './di/scope';\r\nexport { ivyEnabled as ivyEnabled } from './ivy_switch';\r\nexport { ComponentFactory as ComponentFactory } from './linker/component_factory';\r\nexport { CodegenComponentFactoryResolver as CodegenComponentFactoryResolver } from './linker/component_factory_resolver';\r\nexport { resolveComponentResources as resolveComponentResources } from './metadata/resource_loading';\r\nexport { ReflectionCapabilities as ReflectionCapabilities } from './reflection/reflection_capabilities';\r\nexport { GetterFn as GetterFn, MethodFn as MethodFn, SetterFn as SetterFn } from './reflection/types';\r\nexport { DirectRenderer as DirectRenderer, RenderDebugInfo as RenderDebugInfo } from './render/api';\r\nexport { _sanitizeHtml as _sanitizeHtml } from './sanitization/html_sanitizer';\r\nexport { _sanitizeStyle as _sanitizeStyle } from './sanitization/style_sanitizer';\r\nexport { _sanitizeUrl as _sanitizeUrl } from './sanitization/url_sanitizer';\r\nexport { global as global, looseIdentical as looseIdentical, stringify as stringify } from './util';\r\nexport { makeDecorator as makeDecorator } from './util/decorators';\r\nexport { isObservable as isObservable, isPromise as isPromise } from './util/lang';\r\nexport { clearOverrides as clearOverrides, initServicesIfNeeded as initServicesIfNeeded, overrideComponentView as overrideComponentView, overrideProvider as overrideProvider } from './view/index';\r\nexport { NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR } from './view/provider';\r\n",
  "/node_modules/@angular/core/src/core_render3_private_export.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { defineBase as defineBase, defineComponent as defineComponent, defineDirective as defineDirective, definePipe as definePipe, defineNgModule as defineNgModule, detectChanges as detectChanges, renderComponent as renderComponent, ComponentType as ComponentType, ComponentFactory as Render3ComponentFactory, ComponentRef as Render3ComponentRef, DirectiveType as DirectiveType, RenderFlags as RenderFlags, directiveInject as directiveInject, injectElementRef as injectElementRef, injectTemplateRef as injectTemplateRef, injectViewContainerRef as injectViewContainerRef, injectChangeDetectorRef as injectChangeDetectorRef, injectRenderer2 as injectRenderer2, injectAttribute as injectAttribute, getFactoryOf as getFactoryOf, getInheritedFactory as getInheritedFactory, templateRefExtractor as templateRefExtractor, PublicFeature as PublicFeature, InheritDefinitionFeature as InheritDefinitionFeature, NgOnChangesFeature as NgOnChangesFeature, NgModuleType as NgModuleType, NgModuleRef as Render3NgModuleRef, CssSelectorList as CssSelectorList, markDirty as markDirty, NgModuleFactory as NgModuleFactory, NO_CHANGE as NO_CHANGE, container as container, nextContext as nextContext, elementStart as elementStart, namespaceHTML as namespaceHTML, namespaceMathML as namespaceMathML, namespaceSVG as namespaceSVG, element as element, listener as listener, text as text, embeddedViewStart as embeddedViewStart, query as query, registerContentQuery as registerContentQuery, loadDirective as loadDirective, projection as projection, bind as bind, interpolation1 as interpolation1, interpolation2 as interpolation2, interpolation3 as interpolation3, interpolation4 as interpolation4, interpolation5 as interpolation5, interpolation6 as interpolation6, interpolation7 as interpolation7, interpolation8 as interpolation8, interpolationV as interpolationV, pipeBind1 as pipeBind1, pipeBind2 as pipeBind2, pipeBind3 as pipeBind3, pipeBind4 as pipeBind4, pipeBindV as pipeBindV, pureFunction0 as pureFunction0, pureFunction1 as pureFunction1, pureFunction2 as pureFunction2, pureFunction3 as pureFunction3, pureFunction4 as pureFunction4, pureFunction5 as pureFunction5, pureFunction6 as pureFunction6, pureFunction7 as pureFunction7, pureFunction8 as pureFunction8, pureFunctionV as pureFunctionV, getCurrentView as getCurrentView, restoreView as restoreView, containerRefreshStart as containerRefreshStart, containerRefreshEnd as containerRefreshEnd, queryRefresh as queryRefresh, loadQueryList as loadQueryList, elementEnd as elementEnd, elementProperty as elementProperty, projectionDef as projectionDef, reference as reference, elementAttribute as elementAttribute, elementStyling as elementStyling, elementStylingMap as elementStylingMap, elementStyleProp as elementStylingProp, elementStylingApply as elementStylingApply, elementClassProp as elementClassProp, textBinding as textBinding, template as template, embeddedViewEnd as embeddedViewEnd, store as store, load as load, pipe as pipe, BaseDef as BaseDef, ComponentDef as ComponentDef, ComponentDefInternal as ComponentDefInternal, DirectiveDef as DirectiveDef, PipeDef as PipeDef, whenRendered as whenRendered, i18nApply as i18nApply, i18nExpMapping as i18nExpMapping, i18nInterpolation1 as i18nInterpolation1, i18nInterpolation2 as i18nInterpolation2, i18nInterpolation3 as i18nInterpolation3, i18nInterpolation4 as i18nInterpolation4, i18nInterpolation5 as i18nInterpolation5, i18nInterpolation6 as i18nInterpolation6, i18nInterpolation7 as i18nInterpolation7, i18nInterpolation8 as i18nInterpolation8, i18nInterpolationV as i18nInterpolationV, i18nMapping as i18nMapping, I18nInstruction as I18nInstruction, I18nExpInstruction as I18nExpInstruction, WRAP_RENDERER_FACTORY2 as WRAP_RENDERER_FACTORY2, } from './render3/index';\r\nexport { Render3DebugRendererFactory2 as Render3DebugRendererFactory2 } from './render3/debug';\r\nexport { compileNgModuleDefs as compileNgModuleDefs, patchComponentDefWithScope as patchComponentDefWithScope, } from './render3/jit/module';\r\nexport { compileComponent as compileComponent, compileDirective as compileDirective, } from './render3/jit/directive';\r\nexport { compilePipe as compilePipe, } from './render3/jit/pipe';\r\nexport { NgModuleDef as NgModuleDef, NgModuleDefInternal as NgModuleDefInternal, NgModuleTransitiveScopes as NgModuleTransitiveScopes, } from './metadata/ng_module';\r\nexport { sanitizeHtml as sanitizeHtml, sanitizeStyle as sanitizeStyle, sanitizeUrl as sanitizeUrl, sanitizeResourceUrl as sanitizeResourceUrl, } from './sanitization/sanitization';\r\nexport { bypassSanitizationTrustHtml as bypassSanitizationTrustHtml, bypassSanitizationTrustStyle as bypassSanitizationTrustStyle, bypassSanitizationTrustScript as bypassSanitizationTrustScript, bypassSanitizationTrustUrl as bypassSanitizationTrustUrl, bypassSanitizationTrustResourceUrl as bypassSanitizationTrustResourceUrl, } from './sanitization/bypass';\r\nexport { LContext as LContext, getContext as getContext } from './render3/context_discovery';\r\nexport { R3_COMPILE_COMPONENT__POST_NGCC__ as R3_COMPILE_COMPONENT__POST_NGCC__, R3_COMPILE_DIRECTIVE__POST_NGCC__ as R3_COMPILE_DIRECTIVE__POST_NGCC__, R3_COMPILE_INJECTABLE__POST_NGCC__ as R3_COMPILE_INJECTABLE__POST_NGCC__, R3_COMPILE_NGMODULE__POST_NGCC__ as R3_COMPILE_NGMODULE__POST_NGCC__, R3_COMPILE_PIPE__POST_NGCC__ as R3_COMPILE_PIPE__POST_NGCC__, ivyEnable__POST_NGCC__ as ivyEnable__POST_NGCC__ } from './ivy_switch_legacy';\r\n",
  "/node_modules/@angular/core/src/debug/debug_node.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Injector } from '../di';\r\nimport { DebugContext } from '../view/index';\r\nexport declare class EventListener {\r\n    name: string;\r\n    callback: Function;\r\n    constructor(name: string, callback: Function);\r\n}\r\n/**\r\n * @experimental All debugging apis are currently experimental.\r\n */\r\nexport declare class DebugNode {\r\n    nativeNode: any;\r\n    private _debugContext;\r\n    listeners: EventListener[];\r\n    parent: DebugElement | null;\r\n    constructor(nativeNode: any, parent: DebugNode | null, _debugContext: DebugContext);\r\n    readonly injector: Injector;\r\n    readonly componentInstance: any;\r\n    readonly context: any;\r\n    readonly references: {\r\n        [key: string]: any;\r\n    };\r\n    readonly providerTokens: any[];\r\n}\r\n/**\r\n * @experimental All debugging apis are currently experimental.\r\n */\r\nexport declare class DebugElement extends DebugNode {\r\n    name: string;\r\n    properties: {\r\n        [key: string]: any;\r\n    };\r\n    attributes: {\r\n        [key: string]: string | null;\r\n    };\r\n    classes: {\r\n        [key: string]: boolean;\r\n    };\r\n    styles: {\r\n        [key: string]: string | null;\r\n    };\r\n    childNodes: DebugNode[];\r\n    nativeElement: any;\r\n    constructor(nativeNode: any, parent: any, _debugContext: DebugContext);\r\n    addChild(child: DebugNode): void;\r\n    removeChild(child: DebugNode): void;\r\n    insertChildrenAfter(child: DebugNode, newChildren: DebugNode[]): void;\r\n    insertBefore(refChild: DebugNode, newChild: DebugNode): void;\r\n    query(predicate: Predicate<DebugElement>): DebugElement;\r\n    queryAll(predicate: Predicate<DebugElement>): DebugElement[];\r\n    queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[];\r\n    readonly children: DebugElement[];\r\n    triggerEventHandler(eventName: string, eventObj: any): void;\r\n}\r\n/**\r\n * @experimental\r\n */\r\nexport declare function asNativeElements(debugEls: DebugElement[]): any;\r\n/**\r\n * @experimental\r\n */\r\nexport declare function getDebugNode(nativeNode: any): DebugNode | null;\r\nexport declare function getAllDebugNodes(): DebugNode[];\r\nexport declare function indexDebugNode(node: DebugNode): void;\r\nexport declare function removeDebugNodeFromIndex(node: DebugNode): void;\r\n/**\r\n * A boolean-valued function over a value, possibly including context information\r\n * regarding that value's position in an array.\r\n *\r\n * @experimental All debugging apis are currently experimental.\r\n */\r\nexport interface Predicate<T> {\r\n    (value: T): boolean;\r\n}\r\n",
  "/node_modules/@angular/core/src/di/defs.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Type } from '../type';\r\nimport { ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, ValueProvider } from './provider';\r\n/**\r\n * Information about how a type or `InjectionToken` interfaces with the DI system.\r\n *\r\n * At a minimum, this includes a `factory` which defines how to create the given type `T`, possibly\r\n * requesting injection of other types if necessary.\r\n *\r\n * Optionally, a `providedIn` parameter specifies that the given type belongs to a particular\r\n * `InjectorDef`, `NgModule`, or a special scope (e.g. `'root'`). A value of `null` indicates\r\n * that the injectable does not belong to any scope.\r\n *\r\n * NOTE: This is a private type and should not be exported\r\n */\r\nexport interface InjectableDef<T> {\r\n    /**\r\n     * Specifies that the given type belongs to a particular injector:\r\n     * - `InjectorType` such as `NgModule`,\r\n     * - `'root'` the root injector\r\n     * - `'any'` all injectors.\r\n     * - `null`, does not belong to any injector. Must be explicitly listed in the injector\r\n     *   `providers`.\r\n     */\r\n    providedIn: InjectorType<any> | 'root' | 'any' | null;\r\n    /**\r\n     * Factory method to execute to create an instance of the injectable.\r\n     */\r\n    factory: () => T;\r\n    /**\r\n     * In a case of no explicit injector, a location where the instance of the injectable is stored.\r\n     */\r\n    value: T | undefined;\r\n}\r\n/**\r\n * Information about the providers to be included in an `Injector` as well as how the given type\r\n * which carries the information should be created by the DI system.\r\n *\r\n * An `InjectorDef` can import other types which have `InjectorDefs`, forming a deep nested\r\n * structure of providers with a defined priority (identically to how `NgModule`s also have\r\n * an import/dependency structure).\r\n *\r\n * NOTE: This is a private type and should not be exported\r\n */\r\nexport interface InjectorDef<T> {\r\n    factory: () => T;\r\n    providers: (Type<any> | ValueProvider | ExistingProvider | FactoryProvider | ConstructorProvider | StaticClassProvider | ClassProvider | any[])[];\r\n    imports: (InjectorType<any> | InjectorTypeWithProviders<any>)[];\r\n}\r\n/**\r\n * A `Type` which has an `InjectableDef` static field.\r\n *\r\n * `InjectableDefType`s contain their own Dependency Injection metadata and are usable in an\r\n * `InjectorDef`-based `StaticInjector.\r\n *\r\n * @experimental\r\n */\r\nexport interface InjectableType<T> extends Type<T> {\r\n    /**\r\n     * Opaque type whose structure is highly version dependent. Do not rely on any properties.\r\n     */\r\n    ngInjectableDef: never;\r\n}\r\n/**\r\n * A type which has an `InjectorDef` static field.\r\n *\r\n * `InjectorDefTypes` can be used to configure a `StaticInjector`.\r\n *\r\n * @experimental\r\n */\r\nexport interface InjectorType<T> extends Type<T> {\r\n    /**\r\n     * Opaque type whose structure is highly version dependent. Do not rely on any properties.\r\n     */\r\n    ngInjectorDef: never;\r\n}\r\n/**\r\n * Describes the `InjectorDef` equivalent of a `ModuleWithProviders`, an `InjectorDefType` with an\r\n * associated array of providers.\r\n *\r\n * Objects of this type can be listed in the imports section of an `InjectorDef`.\r\n *\r\n * NOTE: This is a private type and should not be exported\r\n */\r\nexport interface InjectorTypeWithProviders<T> {\r\n    ngModule: InjectorType<T>;\r\n    providers?: (Type<any> | ValueProvider | ExistingProvider | FactoryProvider | ConstructorProvider | StaticClassProvider | ClassProvider | any[])[];\r\n}\r\n/**\r\n * Construct an `InjectableDef` which defines how a token will be constructed by the DI system, and\r\n * in which injectors (if any) it will be available.\r\n *\r\n * This should be assigned to a static `ngInjectableDef` field on a type, which will then be an\r\n * `InjectableType`.\r\n *\r\n * Options:\r\n * * `providedIn` determines which injectors will include the injectable, by either associating it\r\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\r\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\r\n * * `factory` gives the zero argument function which will create an instance of the injectable.\r\n *   The factory can call `inject` to access the `Injector` and request injection of dependencies.\r\n *\r\n * @experimental\r\n */\r\nexport declare function defineInjectable<T>(opts: {\r\n    providedIn?: Type<any> | 'root' | 'any' | null;\r\n    factory: () => T;\r\n}): never;\r\n/**\r\n * Construct an `InjectorDef` which configures an injector.\r\n *\r\n * This should be assigned to a static `ngInjectorDef` field on a type, which will then be an\r\n * `InjectorType`.\r\n *\r\n * Options:\r\n *\r\n * * `factory`: an `InjectorType` is an instantiable type, so a zero argument `factory` function to\r\n *   create the type must be provided. If that factory function needs to inject arguments, it can\r\n *   use the `inject` function.\r\n * * `providers`: an optional array of providers to add to the injector. Each provider must\r\n *   either have a factory or point to a type which has an `ngInjectableDef` static property (the\r\n *   type must be an `InjectableType`).\r\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\r\n *   whose providers will also be added to the injector. Locally provided types will override\r\n *   providers from imports.\r\n *\r\n * @experimental\r\n */\r\nexport declare function defineInjector(options: {\r\n    factory: () => any;\r\n    providers?: any[];\r\n    imports?: any[];\r\n}): never;\r\n/**\r\n * Read the `ngInjectableDef` type in a way which is immune to accidentally reading inherited value.\r\n *\r\n * @param type type which may have `ngInjectableDef`\r\n */\r\nexport declare function getInjectableDef<T>(type: any): InjectableDef<T> | null;\r\n/**\r\n * Read the `ngInjectorDef` type in a way which is immune to accidentally reading inherited value.\r\n *\r\n * @param type type which may have `ngInjectorDef`\r\n */\r\nexport declare function getInjectorDef<T>(type: any): InjectorDef<T> | null;\r\n",
  "/node_modules/@angular/core/src/di/forward_ref.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Type } from '../type';\r\n/**\r\n * An interface that a function passed into {@link forwardRef} has to implement.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}\r\n * @experimental\r\n */\r\nexport interface ForwardRefFn {\r\n    (): any;\r\n}\r\n/**\r\n * Allows to refer to references which are not yet defined.\r\n *\r\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\r\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\r\n * a query is not yet defined.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\r\n * @experimental\r\n */\r\nexport declare function forwardRef(forwardRefFn: ForwardRefFn): Type<any>;\r\n/**\r\n * Lazily retrieves the reference value from a forwardRef.\r\n *\r\n * Acts as the identity function when given a non-forward-ref value.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\r\n *\r\n * @see `forwardRef`\r\n * @experimental\r\n */\r\nexport declare function resolveForwardRef(type: any): any;\r\n",
  "/node_modules/@angular/core/src/di/injectable.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Type } from '../type';\r\nimport { InjectableDef } from './defs';\r\nimport { ClassSansProvider, ConstructorSansProvider, ExistingSansProvider, FactorySansProvider, StaticClassSansProvider, ValueSansProvider } from './provider';\r\n/**\r\n * Injectable providers used in `@Injectable` decorator.\r\n *\r\n * @experimental\r\n */\r\nexport declare type InjectableProvider = ValueSansProvider | ExistingSansProvider | StaticClassSansProvider | ConstructorSansProvider | FactorySansProvider | ClassSansProvider;\r\n/**\r\n * Type of the Injectable decorator / constructor function.\r\n */\r\nexport interface InjectableDecorator {\r\n    /**\r\n     * A marker metadata that marks a class as available to `Injector` for creation.\r\n     *\r\n     * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * {@example core/di/ts/metadata_spec.ts region='Injectable'}\r\n     *\r\n     * `Injector` will throw an error when trying to instantiate a class that\r\n     * does not have `@Injectable` marker, as shown in the example below.\r\n     *\r\n     * {@example core/di/ts/metadata_spec.ts region='InjectableThrows'}\r\n     *\r\n     */\r\n    (): any;\r\n    (options?: {\r\n        providedIn: Type<any> | 'root' | null;\r\n    } & InjectableProvider): any;\r\n    new (): Injectable;\r\n    new (options?: {\r\n        providedIn: Type<any> | 'root' | null;\r\n    } & InjectableProvider): Injectable;\r\n}\r\n/**\r\n * Type of the Injectable metadata.\r\n *\r\n * @experimental\r\n */\r\nexport interface Injectable {\r\n    providedIn?: Type<any> | 'root' | null;\r\n}\r\n/**\r\n* Injectable decorator and metadata.\r\n*\r\n* @Annotation\r\n*/\r\nexport declare const Injectable: InjectableDecorator;\r\n/**\r\n * Type representing injectable service.\r\n *\r\n * @experimental\r\n */\r\nexport interface InjectableType<T> extends Type<T> {\r\n    ngInjectableDef: InjectableDef<T>;\r\n}\r\n",
  "/node_modules/@angular/core/src/di/injection_token.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Type } from '../type';\r\n/**\r\n * Creates a token that can be used in a DI Provider.\r\n *\r\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\r\n * runtime representation) such as when injecting an interface, callable type, array or\r\n * parametrized type.\r\n *\r\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\r\n * the `Injector`. This provides additional level of type safety.\r\n *\r\n * ```\r\n * interface MyInterface {...}\r\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\r\n * // myInterface is inferred to be MyInterface.\r\n * ```\r\n *\r\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\r\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\r\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\r\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\r\n * dependencies, it can do so using the `inject` function. See below for an example.\r\n *\r\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\r\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As\r\n * mentioned above, `'root'` is the default value for `providedIn`.\r\n *\r\n * @usageNotes\r\n * ### Basic Example\r\n *\r\n * #### Plain InjectionToken\r\n *\r\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\r\n *\r\n * #### Tree-shakable InjectionToken\r\n *\r\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\r\n *\r\n */\r\nexport declare class InjectionToken<T> {\r\n    protected _desc: string;\r\n    /** @internal */\r\n    readonly ngMetadataName: string;\r\n    readonly ngInjectableDef: never | undefined;\r\n    constructor(_desc: string, options?: {\r\n        providedIn?: Type<any> | 'root' | null;\r\n        factory: () => T;\r\n    });\r\n    toString(): string;\r\n}\r\nexport interface InjectableDefToken<T> extends InjectionToken<T> {\r\n    ngInjectableDef: never;\r\n}\r\n",
  "/node_modules/@angular/core/src/di/injector.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Type } from '../type';\r\nimport { InjectionToken } from './injection_token';\r\nimport { StaticProvider } from './provider';\r\nexport declare const SOURCE = \"__source\";\r\nexport declare const THROW_IF_NOT_FOUND: Object;\r\n/**\r\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\r\n *\r\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\r\n * project.\r\n *\r\n * @experimental\r\n */\r\nexport declare const INJECTOR: InjectionToken<Injector>;\r\nexport declare class NullInjector implements Injector {\r\n    get(token: any, notFoundValue?: any): any;\r\n}\r\n/**\r\n * Concrete injectors implement this interface.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/injector_spec.ts region='Injector'}\r\n *\r\n * `Injector` returns itself when given `Injector` as a token:\r\n *\r\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\r\n *\r\n *\r\n */\r\nexport declare abstract class Injector {\r\n    static THROW_IF_NOT_FOUND: Object;\r\n    static NULL: Injector;\r\n    /**\r\n     * Retrieves an instance from the injector based on the provided token.\r\n     * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\r\n     * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\r\n     */\r\n    abstract get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\r\n    /**\r\n     * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>\r\n     * @suppress {duplicate}\r\n     */\r\n    abstract get(token: any, notFoundValue?: any): any;\r\n    /**\r\n     * @deprecated from v5 use the new signature Injector.create(options)\r\n     */\r\n    static create(providers: StaticProvider[], parent?: Injector): Injector;\r\n    static create(options: {\r\n        providers: StaticProvider[];\r\n        parent?: Injector;\r\n        name?: string;\r\n    }): Injector;\r\n    static ngInjectableDef: never;\r\n}\r\nexport declare const USE_VALUE: string;\r\nexport declare class StaticInjector implements Injector {\r\n    readonly parent: Injector;\r\n    readonly source: string | null;\r\n    private _records;\r\n    constructor(providers: StaticProvider[], parent?: Injector, source?: string | null);\r\n    get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\r\n    get(token: any, notFoundValue?: any): any;\r\n    toString(): string;\r\n}\r\n/**\r\n * Injection flags for DI.\r\n */\r\nexport declare const enum InjectFlags {\r\n    Default = 0,\r\n    /**\r\n     * Specifies that an injector should retrieve a dependency from any injector until reaching the\r\n     * host element of the current component. (Only used with Element Injector)\r\n     */\r\n    Host = 1,\r\n    /** Don't descend into ancestors of the node requesting injection. */\r\n    Self = 2,\r\n    /** Skip the node that is requesting injection. */\r\n    SkipSelf = 4,\r\n    /** Inject `defaultValue` instead if token not found. */\r\n    Optional = 8\r\n}\r\nexport declare function setCurrentInjector(injector: Injector | null | undefined): Injector | undefined | null;\r\n/**\r\n * Injects a token from the currently active injector.\r\n *\r\n * This function must be used in the context of a factory function such as one defined for an\r\n * `InjectionToken`, and will throw an error if not called from such a context.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/injector_spec.ts region='ShakeableInjectionToken'}\r\n *\r\n * Within such a factory function `inject` is utilized to request injection of a dependency, instead\r\n * of providing an additional array of dependencies as was common to do with `useFactory` providers.\r\n * `inject` is faster and more type-safe.\r\n *\r\n * @experimental\r\n */\r\nexport declare function inject<T>(token: Type<T> | InjectionToken<T>): T;\r\nexport declare function inject<T>(token: Type<T> | InjectionToken<T>, flags?: InjectFlags): T | null;\r\nexport declare function injectArgs(types: (Type<any> | InjectionToken<any> | any[])[]): any[];\r\n",
  "/node_modules/@angular/core/src/di/metadata.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Type of the Inject decorator / constructor function.\r\n */\r\nexport interface InjectDecorator {\r\n    /**\r\n     * A constructor parameter decorator that specifies a\r\n     * custom provider of a dependency.\r\n     *\r\n     * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n     *\r\n     * @usageNotes\r\n     * The following example shows a class constructor that specifies a\r\n     * custom provider of a dependency using the parameter decorator.\r\n     *\r\n     * {@example core/di/ts/metadata_spec.ts region='Inject'}\r\n     *\r\n     * When `@Inject()` is not present, the `Injector` uses the type annotation of the\r\n     * parameter as the provider.\r\n     *\r\n     * {@example core/di/ts/metadata_spec.ts region='InjectWithoutDecorator'}\r\n     */\r\n    (token: any): any;\r\n    new (token: any): Inject;\r\n}\r\n/**\r\n * Type of the Inject metadata.\r\n */\r\nexport interface Inject {\r\n    /**\r\n     * Injector token that maps to the dependency to be injected.\r\n     */\r\n    token: any;\r\n}\r\n/**\r\n * Inject decorator and metadata.\r\n *\r\n * @Annotation\r\n */\r\nexport declare const Inject: InjectDecorator;\r\n/**\r\n * Type of the Optional decorator / constructor function.\r\n */\r\nexport interface OptionalDecorator {\r\n    /**\r\n     * A constructor parameter decorator that marks a dependency as optional.\r\n     *\r\n     * The DI framework provides null if the dependency is not found.\r\n     * For example, the following code allows the possibility of a null result:\r\n     *\r\n     * {@example core/di/ts/metadata_spec.ts region='Optional'}\r\n     *\r\n     * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n     */\r\n    (): any;\r\n    new (): Optional;\r\n}\r\n/**\r\n * Type of the Optional metadata.\r\n */\r\nexport interface Optional {\r\n}\r\n/**\r\n * Optional decorator and metadata.\r\n *\r\n * @Annotation\r\n */\r\nexport declare const Optional: OptionalDecorator;\r\n/**\r\n * Type of the Self decorator / constructor function.\r\n */\r\nexport interface SelfDecorator {\r\n    /**\r\n     * A constructor parameter decorator that tells the DI framework\r\n     * to retrieve a dependency only from the local injector.\r\n     *\r\n     * In the following example, the dependency can be resolved\r\n     * by the local injector when instantiating the class itself, but not\r\n     * when instantiating a child.\r\n     *\r\n     * {@example core/di/ts/metadata_spec.ts region='Self'}\r\n     *\r\n     * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n     *\r\n     *\r\n     */\r\n    (): any;\r\n    new (): Self;\r\n}\r\n/**\r\n * Type of the Self metadata.\r\n */\r\nexport interface Self {\r\n}\r\n/**\r\n * Self decorator and metadata.\r\n *\r\n * @Annotation\r\n */\r\nexport declare const Self: SelfDecorator;\r\n/**\r\n * Type of the SkipSelf decorator / constructor function.\r\n */\r\nexport interface SkipSelfDecorator {\r\n    /**\r\n     * A constructor parameter decorator that tells the DI framework\r\n     * that dependency resolution should start from the parent injector.\r\n     *\r\n     * In the following example, the dependency can be resolved when\r\n     * instantiating a child, but not when instantiating the class itself.\r\n     *\r\n     * {@example core/di/ts/metadata_spec.ts region='SkipSelf'}\r\n     *\r\n     * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n     *\r\n     *\r\n     */\r\n    (): any;\r\n    new (): SkipSelf;\r\n}\r\n/**\r\n * Type of the SkipSelf metadata.\r\n *\r\n *\r\n */\r\nexport interface SkipSelf {\r\n}\r\n/**\r\n * SkipSelf decorator and metadata.\r\n *\r\n * @Annotation\r\n */\r\nexport declare const SkipSelf: SkipSelfDecorator;\r\n/**\r\n * Type of the Host decorator / constructor function.\r\n */\r\nexport interface HostDecorator {\r\n    /**\r\n     * A constructor parameter decorator that tells the DI framework\r\n     * to retrieve a dependency from any injector until\r\n     * reaching the host element of the current component.\r\n     *\r\n     * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * {@example core/di/ts/metadata_spec.ts region='Host'}\r\n     */\r\n    (): any;\r\n    new (): Host;\r\n}\r\n/**\r\n * Type of the Host metadata.\r\n */\r\nexport interface Host {\r\n}\r\n/**\r\n * Host decorator and metadata.\r\n *\r\n * @Annotation\r\n */\r\nexport declare const Host: HostDecorator;\r\n",
  "/node_modules/@angular/core/src/di/provider.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Type } from '../type';\r\n/**\r\n * Configures the `Injector` to return a value for a token.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='ValueSansProvider'}\r\n *\r\n * @experimental\r\n */\r\nexport interface ValueSansProvider {\r\n    /**\r\n     * The value to inject.\r\n     */\r\n    useValue: any;\r\n}\r\n/**\r\n * Configures the `Injector` to return a value for a token.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='ValueProvider'}\r\n *\r\n * ### Multi-value example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\r\n */\r\nexport interface ValueProvider extends ValueSansProvider {\r\n    /**\r\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\r\n     */\r\n    provide: any;\r\n    /**\r\n     * If true, then injector returns an array of instances. This is useful to allow multiple\r\n     * providers spread across many files to provide configuration information to a common token.\r\n     */\r\n    multi?: boolean;\r\n}\r\n/**\r\n * Configures the `Injector` to return an instance of `useClass` for a token.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='StaticClassSansProvider'}\r\n *\r\n * @experimental\r\n */\r\nexport interface StaticClassSansProvider {\r\n    /**\r\n     * An optional class to instantiate for the `token`. (If not provided `provide` is assumed to be a\r\n     * class to instantiate)\r\n     */\r\n    useClass: Type<any>;\r\n    /**\r\n     * A list of `token`s which need to be resolved by the injector. The list of values is then\r\n     * used as arguments to the `useClass` constructor.\r\n     */\r\n    deps: any[];\r\n}\r\n/**\r\n * Configures the `Injector` to return an instance of `useClass` for a token.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='StaticClassProvider'}\r\n *\r\n * Note that following two providers are not equal:\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='StaticClassProviderDifference'}\r\n *\r\n * ### Multi-value example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\r\n */\r\nexport interface StaticClassProvider extends StaticClassSansProvider {\r\n    /**\r\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\r\n     */\r\n    provide: any;\r\n    /**\r\n     * If true, then injector returns an array of instances. This is useful to allow multiple\r\n     * providers spread across many files to provide configuration information to a common token.\r\n     */\r\n    multi?: boolean;\r\n}\r\n/**\r\n * Configures the `Injector` to return an instance of a token.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```\r\n * @Injectable(SomeModule, {deps: []})\r\n * class MyService {}\r\n * ```\r\n *\r\n * @experimental\r\n */\r\nexport interface ConstructorSansProvider {\r\n    /**\r\n     * A list of `token`s which need to be resolved by the injector. The list of values is then\r\n     * used as arguments to the `useClass` constructor.\r\n     */\r\n    deps?: any[];\r\n}\r\n/**\r\n * Configures the `Injector` to return an instance of a token.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\r\n *\r\n * ### Multi-value example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\r\n */\r\nexport interface ConstructorProvider extends ConstructorSansProvider {\r\n    /**\r\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\r\n     */\r\n    provide: Type<any>;\r\n    /**\r\n     * If true, then injector returns an array of instances. This is useful to allow multiple\r\n     * providers spread across many files to provide configuration information to a common token.\r\n     */\r\n    multi?: boolean;\r\n}\r\n/**\r\n * Configures the `Injector` to return a value of another `useExisting` token.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='ExistingSansProvider'}\r\n */\r\nexport interface ExistingSansProvider {\r\n    /**\r\n     * Existing `token` to return. (equivalent to `injector.get(useExisting)`)\r\n     */\r\n    useExisting: any;\r\n}\r\n/**\r\n * Configures the `Injector` to return a value of another `useExisting` token.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='ExistingProvider'}\r\n *\r\n * ### Multi-value example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\r\n */\r\nexport interface ExistingProvider extends ExistingSansProvider {\r\n    /**\r\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\r\n     */\r\n    provide: any;\r\n    /**\r\n     * If true, then injector returns an array of instances. This is useful to allow multiple\r\n     * providers spread across many files to provide configuration information to a common token.\r\n     */\r\n    multi?: boolean;\r\n}\r\n/**\r\n * Configures the `Injector` to return a value by invoking a `useFactory` function.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='FactorySansProvider'}\r\n *\r\n * @experimental\r\n */\r\nexport interface FactorySansProvider {\r\n    /**\r\n     * A function to invoke to create a value for this `token`. The function is invoked with\r\n     * resolved values of `token`s in the `deps` field.\r\n     */\r\n    useFactory: Function;\r\n    /**\r\n     * A list of `token`s which need to be resolved by the injector. The list of values is then\r\n     * used as arguments to the `useFactory` function.\r\n     */\r\n    deps?: any[];\r\n}\r\n/**\r\n * Configures the `Injector` to return a value by invoking a `useFactory` function.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='FactoryProvider'}\r\n *\r\n * Dependencies can also be marked as optional:\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='FactoryProviderOptionalDeps'}\r\n *\r\n * ### Multi-value example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\r\n */\r\nexport interface FactoryProvider extends FactorySansProvider {\r\n    /**\r\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\r\n     */\r\n    provide: any;\r\n    /**\r\n     * If true, then injector returns an array of instances. This is useful to allow multiple\r\n     * providers spread across many files to provide configuration information to a common token.\r\n     */\r\n    multi?: boolean;\r\n}\r\n/**\r\n * Describes how the `Injector` should be configured in a static way (Without reflection).\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @see `ValueProvider`\r\n * @see `ExistingProvider`\r\n * @see `FactoryProvider`\r\n */\r\nexport declare type StaticProvider = ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider | any[];\r\n/**\r\n * Configures the `Injector` to return an instance of `Type` when `Type' is used as the token.\r\n *\r\n * Create an instance by invoking the `new` operator and supplying additional arguments.\r\n * This form is a short form of `TypeProvider`;\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='TypeProvider'}\r\n */\r\nexport interface TypeProvider extends Type<any> {\r\n}\r\n/**\r\n * Configures the `Injector` to return a value by invoking a `useClass` function.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='ClassSansProvider'}\r\n *\r\n * @experimental\r\n */\r\nexport interface ClassSansProvider {\r\n    /**\r\n     * Class to instantiate for the `token`.\r\n     */\r\n    useClass: Type<any>;\r\n}\r\n/**\r\n * Configures the `Injector` to return an instance of `useClass` for a token.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='ClassProvider'}\r\n *\r\n * Note that following two providers are not equal:\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='ClassProviderDifference'}\r\n *\r\n * ### Multi-value example\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\r\n */\r\nexport interface ClassProvider extends ClassSansProvider {\r\n    /**\r\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\r\n     */\r\n    provide: any;\r\n    /**\r\n     * If true, then injector returns an array of instances. This is useful to allow multiple\r\n     * providers spread across many files to provide configuration information to a common token.\r\n     */\r\n    multi?: boolean;\r\n}\r\n/**\r\n * Describes how the `Injector` should be configured.\r\n *\r\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n *\r\n * @see `TypeProvider`\r\n * @see `ClassProvider`\r\n * @see `StaticProvider`\r\n */\r\nexport declare type Provider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider | any[];\r\n",
  "/node_modules/@angular/core/src/di/r3_injector.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Type } from '../type';\r\nimport { InjectorType } from './defs';\r\nimport { InjectionToken } from './injection_token';\r\nimport { InjectFlags, Injector } from './injector';\r\nimport { StaticProvider } from './provider';\r\n/**\r\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\r\n *\r\n * @experimental\r\n */\r\nexport declare function createInjector(defType: any, parent?: Injector | null, additionalProviders?: StaticProvider[] | null): Injector;\r\nexport declare class R3Injector {\r\n    readonly parent: Injector;\r\n    /**\r\n     * Map of tokens to records which contain the instances of those tokens.\r\n     */\r\n    private records;\r\n    /**\r\n     * The transitive set of `InjectorType`s which define this injector.\r\n     */\r\n    private injectorDefTypes;\r\n    /**\r\n     * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\r\n     */\r\n    private onDestroy;\r\n    /**\r\n     * Flag indicating this injector provides the APP_ROOT_SCOPE token, and thus counts as the\r\n     * root scope.\r\n     */\r\n    private readonly isRootInjector;\r\n    /**\r\n     * Flag indicating that this injector was previously destroyed.\r\n     */\r\n    private destroyed;\r\n    constructor(def: InjectorType<any>, additionalProviders: StaticProvider[] | null, parent: Injector);\r\n    /**\r\n     * Destroy the injector and release references to every instance or provider associated with it.\r\n     *\r\n     * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\r\n     * hook was found.\r\n     */\r\n    destroy(): void;\r\n    get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: any, flags?: InjectFlags): T;\r\n    private assertNotDestroyed;\r\n    /**\r\n     * Add an `InjectorType` or `InjectorDefTypeWithProviders` and all of its transitive providers\r\n     * to this injector.\r\n     */\r\n    private processInjectorType;\r\n    /**\r\n     * Process a `SingleProvider` and add it.\r\n     */\r\n    private processProvider;\r\n    private hydrate;\r\n    private injectableDefInScope;\r\n}\r\n",
  "/node_modules/@angular/core/src/di/reflective_errors.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Type } from '../type';\r\nimport { ReflectiveInjector } from './reflective_injector';\r\nimport { ReflectiveKey } from './reflective_key';\r\nexport interface InjectionError extends Error {\r\n    keys: ReflectiveKey[];\r\n    injectors: ReflectiveInjector[];\r\n    constructResolvingMessage: (keys: ReflectiveKey[]) => string;\r\n    addKey(injector: ReflectiveInjector, key: ReflectiveKey): void;\r\n}\r\n/**\r\n * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the\r\n * {@link Injector} does not have a {@link Provider} for the given key.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```typescript\r\n * class A {\r\n *   constructor(b:B) {}\r\n * }\r\n *\r\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\r\n * ```\r\n */\r\nexport declare function noProviderError(injector: ReflectiveInjector, key: ReflectiveKey): InjectionError;\r\n/**\r\n * Thrown when dependencies form a cycle.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```typescript\r\n * var injector = Injector.resolveAndCreate([\r\n *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\r\n *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\r\n * ]);\r\n *\r\n * expect(() => injector.get(\"one\")).toThrowError();\r\n * ```\r\n *\r\n * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\r\n */\r\nexport declare function cyclicDependencyError(injector: ReflectiveInjector, key: ReflectiveKey): InjectionError;\r\n/**\r\n * Thrown when a constructing type returns with an Error.\r\n *\r\n * The `InstantiationError` class contains the original error plus the dependency graph which caused\r\n * this object to be instantiated.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```typescript\r\n * class A {\r\n *   constructor() {\r\n *     throw new Error('message');\r\n *   }\r\n * }\r\n *\r\n * var injector = Injector.resolveAndCreate([A]);\r\n\r\n * try {\r\n *   injector.get(A);\r\n * } catch (e) {\r\n *   expect(e instanceof InstantiationError).toBe(true);\r\n *   expect(e.originalException.message).toEqual(\"message\");\r\n *   expect(e.originalStack).toBeDefined();\r\n * }\r\n * ```\r\n */\r\nexport declare function instantiationError(injector: ReflectiveInjector, originalException: any, originalStack: any, key: ReflectiveKey): InjectionError;\r\n/**\r\n * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\r\n * creation.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```typescript\r\n * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\r\n * ```\r\n */\r\nexport declare function invalidProviderError(provider: any): Error;\r\n/**\r\n * Thrown when the class has no annotation information.\r\n *\r\n * Lack of annotation information prevents the {@link Injector} from determining which dependencies\r\n * need to be injected into the constructor.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```typescript\r\n * class A {\r\n *   constructor(b) {}\r\n * }\r\n *\r\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\r\n * ```\r\n *\r\n * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\r\n *\r\n * ```typescript\r\n * class B {}\r\n *\r\n * class A {\r\n *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\r\n * }\r\n *\r\n * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\r\n * ```\r\n *\r\n */\r\nexport declare function noAnnotationError(typeOrFunc: Type<any> | Function, params: any[][]): Error;\r\n/**\r\n * Thrown when getting an object by index.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```typescript\r\n * class A {}\r\n *\r\n * var injector = Injector.resolveAndCreate([A]);\r\n *\r\n * expect(() => injector.getAt(100)).toThrowError();\r\n * ```\r\n *\r\n */\r\nexport declare function outOfBoundsError(index: number): Error;\r\n/**\r\n * Thrown when a multi provider and a regular provider are bound to the same token.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```typescript\r\n * expect(() => Injector.resolveAndCreate([\r\n *   { provide: \"Strings\", useValue: \"string1\", multi: true},\r\n *   { provide: \"Strings\", useValue: \"string2\", multi: false}\r\n * ])).toThrowError();\r\n * ```\r\n */\r\nexport declare function mixingMultiProvidersWithRegularProvidersError(provider1: any, provider2: any): Error;\r\n",
  "/node_modules/@angular/core/src/di/reflective_injector.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Injector } from './injector';\r\nimport { Self, SkipSelf } from './metadata';\r\nimport { Provider } from './provider';\r\nimport { ReflectiveKey } from './reflective_key';\r\nimport { ResolvedReflectiveProvider } from './reflective_provider';\r\n/**\r\n * A ReflectiveDependency injection container used for instantiating objects and resolving\r\n * dependencies.\r\n *\r\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\r\n * constructor dependencies.\r\n *\r\n * In typical use, application code asks for the dependencies in the constructor and they are\r\n * resolved by the `Injector`.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * The following example creates an `Injector` configured to create `Engine` and `Car`.\r\n *\r\n * ```typescript\r\n * @Injectable()\r\n * class Engine {\r\n * }\r\n *\r\n * @Injectable()\r\n * class Car {\r\n *   constructor(public engine:Engine) {}\r\n * }\r\n *\r\n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\r\n * var car = injector.get(Car);\r\n * expect(car instanceof Car).toBe(true);\r\n * expect(car.engine instanceof Engine).toBe(true);\r\n * ```\r\n *\r\n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\r\n * resolve all of the object's dependencies automatically.\r\n *\r\n * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\r\n */\r\nexport declare abstract class ReflectiveInjector implements Injector {\r\n    /**\r\n     * Turns an array of provider definitions into an array of resolved providers.\r\n     *\r\n     * A resolution is a process of flattening multiple nested arrays and converting individual\r\n     * providers into an array of `ResolvedReflectiveProvider`s.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * @Injectable()\r\n     * class Engine {\r\n     * }\r\n     *\r\n     * @Injectable()\r\n     * class Car {\r\n     *   constructor(public engine:Engine) {}\r\n     * }\r\n     *\r\n     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\r\n     *\r\n     * expect(providers.length).toEqual(2);\r\n     *\r\n     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\r\n     * expect(providers[0].key.displayName).toBe(\"Car\");\r\n     * expect(providers[0].dependencies.length).toEqual(1);\r\n     * expect(providers[0].factory).toBeDefined();\r\n     *\r\n     * expect(providers[1].key.displayName).toBe(\"Engine\");\r\n     * });\r\n     * ```\r\n     *\r\n     */\r\n    static resolve(providers: Provider[]): ResolvedReflectiveProvider[];\r\n    /**\r\n     * Resolves an array of providers and creates an injector from those providers.\r\n     *\r\n     * The passed-in providers can be an array of `Type`, `Provider`,\r\n     * or a recursive array of more providers.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * @Injectable()\r\n     * class Engine {\r\n     * }\r\n     *\r\n     * @Injectable()\r\n     * class Car {\r\n     *   constructor(public engine:Engine) {}\r\n     * }\r\n     *\r\n     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\r\n     * expect(injector.get(Car) instanceof Car).toBe(true);\r\n     * ```\r\n     */\r\n    static resolveAndCreate(providers: Provider[], parent?: Injector): ReflectiveInjector;\r\n    /**\r\n     * Creates an injector from previously resolved providers.\r\n     *\r\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * @Injectable()\r\n     * class Engine {\r\n     * }\r\n     *\r\n     * @Injectable()\r\n     * class Car {\r\n     *   constructor(public engine:Engine) {}\r\n     * }\r\n     *\r\n     * var providers = ReflectiveInjector.resolve([Car, Engine]);\r\n     * var injector = ReflectiveInjector.fromResolvedProviders(providers);\r\n     * expect(injector.get(Car) instanceof Car).toBe(true);\r\n     * ```\r\n     * @experimental\r\n     */\r\n    static fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent?: Injector): ReflectiveInjector;\r\n    /**\r\n     * Parent of this injector.\r\n     *\r\n     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\r\n     * -->\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * var parent = ReflectiveInjector.resolveAndCreate([]);\r\n     * var child = parent.resolveAndCreateChild([]);\r\n     * expect(child.parent).toBe(parent);\r\n     * ```\r\n     */\r\n    abstract readonly parent: Injector | null;\r\n    /**\r\n     * Resolves an array of providers and creates a child injector from those providers.\r\n     *\r\n     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\r\n     * -->\r\n     *\r\n     * The passed-in providers can be an array of `Type`, `Provider`,\r\n     * or a recursive array of more providers.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * class ParentProvider {}\r\n     * class ChildProvider {}\r\n     *\r\n     * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\r\n     * var child = parent.resolveAndCreateChild([ChildProvider]);\r\n     *\r\n     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\r\n     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\r\n     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\r\n     * ```\r\n     */\r\n    abstract resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;\r\n    /**\r\n     * Creates a child injector from previously resolved providers.\r\n     *\r\n     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\r\n     * -->\r\n     *\r\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * class ParentProvider {}\r\n     * class ChildProvider {}\r\n     *\r\n     * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\r\n     * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\r\n     *\r\n     * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\r\n     * var child = parent.createChildFromResolved(childProviders);\r\n     *\r\n     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\r\n     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\r\n     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\r\n     * ```\r\n     */\r\n    abstract createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;\r\n    /**\r\n     * Resolves a provider and instantiates an object in the context of the injector.\r\n     *\r\n     * The created object does not get cached by the injector.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * @Injectable()\r\n     * class Engine {\r\n     * }\r\n     *\r\n     * @Injectable()\r\n     * class Car {\r\n     *   constructor(public engine:Engine) {}\r\n     * }\r\n     *\r\n     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\r\n     *\r\n     * var car = injector.resolveAndInstantiate(Car);\r\n     * expect(car.engine).toBe(injector.get(Engine));\r\n     * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\r\n     * ```\r\n     */\r\n    abstract resolveAndInstantiate(provider: Provider): any;\r\n    /**\r\n     * Instantiates an object using a resolved provider in the context of the injector.\r\n     *\r\n     * The created object does not get cached by the injector.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * @Injectable()\r\n     * class Engine {\r\n     * }\r\n     *\r\n     * @Injectable()\r\n     * class Car {\r\n     *   constructor(public engine:Engine) {}\r\n     * }\r\n     *\r\n     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\r\n     * var carProvider = ReflectiveInjector.resolve([Car])[0];\r\n     * var car = injector.instantiateResolved(carProvider);\r\n     * expect(car.engine).toBe(injector.get(Engine));\r\n     * expect(car).not.toBe(injector.instantiateResolved(carProvider));\r\n     * ```\r\n     */\r\n    abstract instantiateResolved(provider: ResolvedReflectiveProvider): any;\r\n    abstract get(token: any, notFoundValue?: any): any;\r\n}\r\nexport declare class ReflectiveInjector_ implements ReflectiveInjector {\r\n    private static INJECTOR_KEY;\r\n    /** @internal */\r\n    _constructionCounter: number;\r\n    /** @internal */\r\n    _providers: ResolvedReflectiveProvider[];\r\n    readonly parent: Injector | null;\r\n    keyIds: number[];\r\n    objs: any[];\r\n    /**\r\n     * Private\r\n     */\r\n    constructor(_providers: ResolvedReflectiveProvider[], _parent?: Injector);\r\n    get(token: any, notFoundValue?: any): any;\r\n    resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;\r\n    createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;\r\n    resolveAndInstantiate(provider: Provider): any;\r\n    instantiateResolved(provider: ResolvedReflectiveProvider): any;\r\n    getProviderAtIndex(index: number): ResolvedReflectiveProvider;\r\n    /** @internal */\r\n    _new(provider: ResolvedReflectiveProvider): any;\r\n    private _getMaxNumberOfObjects;\r\n    private _instantiateProvider;\r\n    private _instantiate;\r\n    private _getByReflectiveDependency;\r\n    private _getByKey;\r\n    private _getObjByKeyId;\r\n    /** @internal */\r\n    _throwOrNull(key: ReflectiveKey, notFoundValue: any): any;\r\n    /** @internal */\r\n    _getByKeySelf(key: ReflectiveKey, notFoundValue: any): any;\r\n    /** @internal */\r\n    _getByKeyDefault(key: ReflectiveKey, notFoundValue: any, visibility: Self | SkipSelf | null): any;\r\n    readonly displayName: string;\r\n    toString(): string;\r\n}\r\n",
  "/node_modules/@angular/core/src/di/reflective_key.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A unique object used for retrieving items from the {@link ReflectiveInjector}.\r\n *\r\n * Keys have:\r\n * - a system-wide unique `id`.\r\n * - a `token`.\r\n *\r\n * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\r\n * the\r\n * injector to store created objects in a more efficient way.\r\n *\r\n * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\r\n * resolving\r\n * providers.\r\n * @deprecated No replacement\r\n */\r\nexport declare class ReflectiveKey {\r\n    token: Object;\r\n    id: number;\r\n    readonly displayName: string;\r\n    /**\r\n     * Private\r\n     */\r\n    constructor(token: Object, id: number);\r\n    /**\r\n     * Retrieves a `Key` for a token.\r\n     */\r\n    static get(token: Object): ReflectiveKey;\r\n    /**\r\n     * @returns the number of keys registered in the system.\r\n     */\r\n    static readonly numberOfKeys: number;\r\n}\r\nexport declare class KeyRegistry {\r\n    private _allKeys;\r\n    get(token: Object): ReflectiveKey;\r\n    readonly numberOfKeys: number;\r\n}\r\n",
  "/node_modules/@angular/core/src/di/reflective_provider.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Self, SkipSelf } from './metadata';\r\nimport { Provider } from './provider';\r\nimport { ReflectiveKey } from './reflective_key';\r\n/**\r\n * `Dependency` is used by the framework to extend DI.\r\n * This is internal to Angular and should not be used directly.\r\n */\r\nexport declare class ReflectiveDependency {\r\n    key: ReflectiveKey;\r\n    optional: boolean;\r\n    visibility: Self | SkipSelf | null;\r\n    constructor(key: ReflectiveKey, optional: boolean, visibility: Self | SkipSelf | null);\r\n    static fromKey(key: ReflectiveKey): ReflectiveDependency;\r\n}\r\n/**\r\n * An internal resolved representation of a `Provider` used by the `Injector`.\r\n *\r\n * @usageNotes\r\n * This is usually created automatically by `Injector.resolveAndCreate`.\r\n *\r\n * It can be created manually, as follows:\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);\r\n * var injector = Injector.fromResolvedProviders(resolvedProviders);\r\n *\r\n * expect(injector.get('message')).toEqual('Hello');\r\n * ```\r\n *\r\n * @experimental\r\n */\r\nexport interface ResolvedReflectiveProvider {\r\n    /**\r\n     * A key, usually a `Type<any>`.\r\n     */\r\n    key: ReflectiveKey;\r\n    /**\r\n     * Factory function which can return an instance of an object represented by a key.\r\n     */\r\n    resolvedFactories: ResolvedReflectiveFactory[];\r\n    /**\r\n     * Indicates if the provider is a multi-provider or a regular provider.\r\n     */\r\n    multiProvider: boolean;\r\n}\r\nexport declare class ResolvedReflectiveProvider_ implements ResolvedReflectiveProvider {\r\n    key: ReflectiveKey;\r\n    resolvedFactories: ResolvedReflectiveFactory[];\r\n    multiProvider: boolean;\r\n    readonly resolvedFactory: ResolvedReflectiveFactory;\r\n    constructor(key: ReflectiveKey, resolvedFactories: ResolvedReflectiveFactory[], multiProvider: boolean);\r\n}\r\n/**\r\n * An internal resolved representation of a factory function created by resolving `Provider`.\r\n * @experimental\r\n */\r\nexport declare class ResolvedReflectiveFactory {\r\n    /**\r\n     * Factory function which can return an instance of an object represented by a key.\r\n     */\r\n    factory: Function;\r\n    /**\r\n     * Arguments (dependencies) to the `factory` function.\r\n     */\r\n    dependencies: ReflectiveDependency[];\r\n    constructor(\r\n    /**\r\n     * Factory function which can return an instance of an object represented by a key.\r\n     */\r\n    factory: Function, \r\n    /**\r\n     * Arguments (dependencies) to the `factory` function.\r\n     */\r\n    dependencies: ReflectiveDependency[]);\r\n}\r\n/**\r\n * Resolve a list of Providers.\r\n */\r\nexport declare function resolveReflectiveProviders(providers: Provider[]): ResolvedReflectiveProvider[];\r\n/**\r\n * Merges a list of ResolvedProviders into a list where each key is contained exactly once and\r\n * multi providers have been merged.\r\n */\r\nexport declare function mergeResolvedReflectiveProviders(providers: ResolvedReflectiveProvider[], normalizedProvidersMap: Map<number, ResolvedReflectiveProvider>): Map<number, ResolvedReflectiveProvider>;\r\nexport declare function constructDependencies(typeOrFunc: any, dependencies?: any[]): ReflectiveDependency[];\r\n",
  "/node_modules/@angular/core/src/di/scope.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { InjectionToken } from './injection_token';\r\n/**\r\n * An internal token whose presence in an injector indicates that the injector should treat itself\r\n * as a root scoped injector when processing requests for unknown tokens which may indicate\r\n * they are provided in the root scope.\r\n */\r\nexport declare const APP_ROOT: InjectionToken<boolean>;\r\n",
  "/node_modules/@angular/core/src/di.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @module\r\n * @description\r\n * The `di` module provides dependency injection container services.\r\n */\r\nexport * from './di/metadata';\r\nexport { InjectableType, InjectorType, defineInjectable, defineInjector } from './di/defs';\r\nexport { forwardRef, resolveForwardRef, ForwardRefFn } from './di/forward_ref';\r\nexport { Injectable, InjectableDecorator, InjectableProvider } from './di/injectable';\r\nexport { inject, InjectFlags, INJECTOR, Injector } from './di/injector';\r\nexport { ReflectiveInjector } from './di/reflective_injector';\r\nexport { StaticProvider, ValueProvider, ConstructorSansProvider, ExistingProvider, FactoryProvider, Provider, TypeProvider, ClassProvider } from './di/provider';\r\nexport { createInjector } from './di/r3_injector';\r\nexport { ResolvedReflectiveFactory, ResolvedReflectiveProvider } from './di/reflective_provider';\r\nexport { ReflectiveKey } from './di/reflective_key';\r\nexport { InjectionToken } from './di/injection_token';\r\n",
  "/node_modules/@angular/core/src/errors.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { DebugContext } from './view';\r\nexport declare const ERROR_TYPE = \"ngType\";\r\nexport declare const ERROR_DEBUG_CONTEXT = \"ngDebugContext\";\r\nexport declare const ERROR_ORIGINAL_ERROR = \"ngOriginalError\";\r\nexport declare const ERROR_LOGGER = \"ngErrorLogger\";\r\nexport declare function getType(error: Error): Function;\r\nexport declare function getDebugContext(error: Error): DebugContext;\r\nexport declare function getOriginalError(error: Error): Error;\r\nexport declare function getErrorLogger(error: Error): (console: Console, ...values: any[]) => void;\r\n",
  "/node_modules/@angular/core/src/error_handler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Provides a hook for centralized exception handling.\r\n *\r\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\r\n * intercept error handling, write a custom exception handler that replaces this default as\r\n * appropriate for your app.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```\r\n * class MyErrorHandler implements ErrorHandler {\r\n *   handleError(error) {\r\n *     // do something with the exception\r\n *   }\r\n * }\r\n *\r\n * @NgModule({\r\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\r\n * })\r\n * class MyModule {}\r\n * ```\r\n */\r\nexport declare class ErrorHandler {\r\n    /**\r\n     * @internal\r\n     */\r\n    _console: Console;\r\n    handleError(error: any): void;\r\n    /** @internal */\r\n    _findContext(error: any): any;\r\n    /** @internal */\r\n    _findOriginalError(error: Error): any;\r\n}\r\nexport declare function wrappedError(message: string, originalError: any): Error;\r\n",
  "/node_modules/@angular/core/src/event_emitter.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Subject } from 'rxjs';\r\n/**\r\n * Use in directives and components to emit custom events synchronously\r\n * or asynchronously, and register handlers for those events by subscribing\r\n * to an instance.\r\n *\r\n * @usageNotes\r\n *\r\n * In the following example, a component defines two output properties\r\n * that create event emitters. When the title is clicked, the emitter\r\n * emits an open or close event to toggle the current visibility state.\r\n *\r\n * ```\r\n * @Component({\r\n *   selector: 'zippy',\r\n *   template: `\r\n *   <div class=\"zippy\">\r\n *     <div (click)=\"toggle()\">Toggle</div>\r\n *     <div [hidden]=\"!visible\">\r\n *       <ng-content></ng-content>\r\n *     </div>\r\n *  </div>`})\r\n * export class Zippy {\r\n *   visible: boolean = true;\r\n *   @Output() open: EventEmitter<any> = new EventEmitter();\r\n *   @Output() close: EventEmitter<any> = new EventEmitter();\r\n *\r\n *   toggle() {\r\n *     this.visible = !this.visible;\r\n *     if (this.visible) {\r\n *       this.open.emit(null);\r\n *     } else {\r\n *       this.close.emit(null);\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Access the event object with the `$event` argument passed to the output event\r\n * handler:\r\n *\r\n * ```\r\n * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\r\n * ```\r\n *\r\n * ### Notes\r\n *\r\n * Uses Rx.Observable but provides an adapter to make it work as specified here:\r\n * https://github.com/jhusain/observable-spec\r\n *\r\n * Once a reference implementation of the spec is available, switch to it.\r\n *\r\n */\r\nexport declare class EventEmitter<T> extends Subject<T> {\r\n    /**\r\n     * Internal\r\n     */\r\n    __isAsync: boolean;\r\n    /**\r\n     * Creates an instance of this class that can\r\n     * deliver events synchronously or asynchronously.\r\n     *\r\n     * @param isAsync When true, deliver events asynchronously.\r\n     *\r\n     */\r\n    constructor(isAsync?: boolean);\r\n    /**\r\n     * Emits an event containing a given value.\r\n     * @param value The value to emit.\r\n     */\r\n    emit(value?: T): void;\r\n    /**\r\n     * Registers handlers for events emitted by this instance.\r\n     * @param generatorOrNext When supplied, a custom handler for emitted events.\r\n     * @param error When supplied, a custom handler for an error notification\r\n     * from this emitter.\r\n     * @param complete When supplied, a custom handler for a completion\r\n     * notification from this emitter.\r\n     */\r\n    subscribe(generatorOrNext?: any, error?: any, complete?: any): any;\r\n}\r\n",
  "/node_modules/@angular/core/src/i18n/tokens.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { InjectionToken } from '../di/injection_token';\r\n/**\r\n * Provide this token to set the locale of your application.\r\n * It is used for i18n extraction, by i18n pipes (DatePipe, I18nPluralPipe, CurrencyPipe,\r\n * DecimalPipe and PercentPipe) and by ICU expressions.\r\n *\r\n * See the [i18n guide](guide/i18n#setting-up-locale) for more information.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { LOCALE_ID } from '@angular/core';\r\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\n * import { AppModule } from './app/app.module';\r\n *\r\n * platformBrowserDynamic().bootstrapModule(AppModule, {\r\n *   providers: [{provide: LOCALE_ID, useValue: 'en-US' }]\r\n * });\r\n * ```\r\n *\r\n * @experimental i18n support is experimental.\r\n */\r\nexport declare const LOCALE_ID: InjectionToken<string>;\r\n/**\r\n * Use this token at bootstrap to provide the content of your translation file (`xtb`,\r\n * `xlf` or `xlf2`) when you want to translate your application in another language.\r\n *\r\n * See the [i18n guide](guide/i18n#merge) for more information.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { TRANSLATIONS } from '@angular/core';\r\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\n * import { AppModule } from './app/app.module';\r\n *\r\n * // content of your translation file\r\n * const translations = '....';\r\n *\r\n * platformBrowserDynamic().bootstrapModule(AppModule, {\r\n *   providers: [{provide: TRANSLATIONS, useValue: translations }]\r\n * });\r\n * ```\r\n *\r\n * @experimental i18n support is experimental.\r\n */\r\nexport declare const TRANSLATIONS: InjectionToken<string>;\r\n/**\r\n * Provide this token at bootstrap to set the format of your {@link TRANSLATIONS}: `xtb`,\r\n * `xlf` or `xlf2`.\r\n *\r\n * See the [i18n guide](guide/i18n#merge) for more information.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { TRANSLATIONS_FORMAT } from '@angular/core';\r\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\n * import { AppModule } from './app/app.module';\r\n *\r\n * platformBrowserDynamic().bootstrapModule(AppModule, {\r\n *   providers: [{provide: TRANSLATIONS_FORMAT, useValue: 'xlf' }]\r\n * });\r\n * ```\r\n *\r\n * @experimental i18n support is experimental.\r\n */\r\nexport declare const TRANSLATIONS_FORMAT: InjectionToken<string>;\r\n/**\r\n * Use this enum at bootstrap as an option of `bootstrapModule` to define the strategy\r\n * that the compiler should use in case of missing translations:\r\n * - Error: throw if you have missing translations.\r\n * - Warning (default): show a warning in the console and/or shell.\r\n * - Ignore: do nothing.\r\n *\r\n * See the [i18n guide](guide/i18n#missing-translation) for more information.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n * ```typescript\r\n * import { MissingTranslationStrategy } from '@angular/core';\r\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\n * import { AppModule } from './app/app.module';\r\n *\r\n * platformBrowserDynamic().bootstrapModule(AppModule, {\r\n *   missingTranslation: MissingTranslationStrategy.Error\r\n * });\r\n * ```\r\n *\r\n * @experimental i18n support is experimental.\r\n */\r\nexport declare enum MissingTranslationStrategy {\r\n    Error = 0,\r\n    Warning = 1,\r\n    Ignore = 2\r\n}\r\n",
  "/node_modules/@angular/core/src/is_dev_mode.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Returns whether Angular is in development mode. After called once,\r\n * the value is locked and won't change any more.\r\n *\r\n * By default, this is true, unless a user calls `enableProdMode` before calling this.\r\n *\r\n * @experimental APIs related to application bootstrap are currently under review.\r\n */\r\nexport declare function isDevMode(): boolean;\r\n/**\r\n * Disable Angular's development mode, which turns off assertions and other\r\n * checks within the framework.\r\n *\r\n * One important assertion this disables verifies that a change detection pass\r\n * does not result in additional changes to any bindings (also known as\r\n * unidirectional data flow).\r\n */\r\nexport declare function enableProdMode(): void;\r\n",
  "/node_modules/@angular/core/src/ivy_switch.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * This file is used to control if the default rendering pipeline should be `ViewEngine` or `Ivy`.\r\n *\r\n * For more information on how to run and debug tests with either Ivy or View Engine (legacy),\r\n * please see [BAZEL.md](./docs/BAZEL.md).\r\n */\r\nexport * from './ivy_switch_on';\r\n",
  "/node_modules/@angular/core/src/ivy_switch_jit.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport * from './ivy_switch_on';\r\n",
  "/node_modules/@angular/core/src/ivy_switch_legacy.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport interface DirectiveCompiler {\r\n    (type: any, meta: any): void;\r\n}\r\nexport declare const R3_COMPILE_COMPONENT__POST_NGCC__: DirectiveCompiler;\r\nexport declare const R3_COMPILE_DIRECTIVE__POST_NGCC__: DirectiveCompiler;\r\nexport declare const R3_COMPILE_INJECTABLE__POST_NGCC__: DirectiveCompiler;\r\nexport declare const R3_COMPILE_NGMODULE__POST_NGCC__: DirectiveCompiler;\r\nexport declare const R3_COMPILE_PIPE__POST_NGCC__: DirectiveCompiler;\r\nexport declare const ivyEnable__POST_NGCC__: boolean;\r\nexport declare const ivyEnabled: boolean;\r\nexport declare let R3_COMPILE_COMPONENT: DirectiveCompiler;\r\nexport declare let R3_COMPILE_DIRECTIVE: DirectiveCompiler;\r\nexport declare let R3_COMPILE_INJECTABLE: DirectiveCompiler;\r\nexport declare let R3_COMPILE_NGMODULE: DirectiveCompiler;\r\nexport declare let R3_COMPILE_PIPE: DirectiveCompiler;\r\n",
  "/node_modules/@angular/core/src/ivy_switch_local.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport * from './ivy_switch_on';\r\n",
  "/node_modules/@angular/core/src/ivy_switch_on.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { compileComponent, compileDirective } from './render3/jit/directive';\r\nimport { compileInjectable } from './render3/jit/injectable';\r\nimport { compileNgModule } from './render3/jit/module';\r\nimport { compilePipe } from './render3/jit/pipe';\r\nexport declare const ivyEnabled: boolean;\r\nexport declare const R3_COMPILE_COMPONENT: typeof compileComponent;\r\nexport declare const R3_COMPILE_DIRECTIVE: typeof compileDirective;\r\nexport declare const R3_COMPILE_INJECTABLE: typeof compileInjectable;\r\nexport declare const R3_COMPILE_NGMODULE: typeof compileNgModule;\r\nexport declare const R3_COMPILE_PIPE: typeof compilePipe;\r\n",
  "/node_modules/@angular/core/src/linker/compiler.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { InjectionToken } from '../di/injection_token';\r\nimport { StaticProvider } from '../di/provider';\r\nimport { MissingTranslationStrategy } from '../i18n/tokens';\r\nimport { ViewEncapsulation } from '../metadata';\r\nimport { Type } from '../type';\r\nimport { ComponentFactory } from './component_factory';\r\nimport { NgModuleFactory } from './ng_module_factory';\r\n/**\r\n * Combination of NgModuleFactory and ComponentFactorys.\r\n *\r\n * @experimental\r\n */\r\nexport declare class ModuleWithComponentFactories<T> {\r\n    ngModuleFactory: NgModuleFactory<T>;\r\n    componentFactories: ComponentFactory<any>[];\r\n    constructor(ngModuleFactory: NgModuleFactory<T>, componentFactories: ComponentFactory<any>[]);\r\n}\r\n/**\r\n * Low-level service for running the angular compiler during runtime\r\n * to create {@link ComponentFactory}s, which\r\n * can later be used to create and render a Component instance.\r\n *\r\n * Each `@NgModule` provides an own `Compiler` to its injector,\r\n * that will use the directives/pipes of the ng module for compilation\r\n * of components.\r\n *\r\n */\r\nexport declare class Compiler {\r\n    /**\r\n     * Compiles the given NgModule and all of its components. All templates of the components listed\r\n     * in `entryComponents` have to be inlined.\r\n     */\r\n    compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T>;\r\n    /**\r\n     * Compiles the given NgModule and all of its components\r\n     */\r\n    compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>>;\r\n    /**\r\n     * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.\r\n     */\r\n    compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T>;\r\n    /**\r\n     * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.\r\n     */\r\n    compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>): Promise<ModuleWithComponentFactories<T>>;\r\n    /**\r\n     * Clears all caches.\r\n     */\r\n    clearCache(): void;\r\n    /**\r\n     * Clears the cache for the given component/ngModule.\r\n     */\r\n    clearCacheFor(type: Type<any>): void;\r\n    /**\r\n     * Returns the id for a given NgModule, if one is defined and known to the compiler.\r\n     */\r\n    getModuleId(moduleType: Type<any>): string | undefined;\r\n}\r\n/**\r\n * Options for creating a compiler\r\n *\r\n * @experimental\r\n */\r\nexport declare type CompilerOptions = {\r\n    useJit?: boolean;\r\n    defaultEncapsulation?: ViewEncapsulation;\r\n    providers?: StaticProvider[];\r\n    missingTranslation?: MissingTranslationStrategy;\r\n    preserveWhitespaces?: boolean;\r\n};\r\n/**\r\n * Token to provide CompilerOptions in the platform injector.\r\n *\r\n * @experimental\r\n */\r\nexport declare const COMPILER_OPTIONS: InjectionToken<CompilerOptions[]>;\r\n/**\r\n * A factory for creating a Compiler\r\n *\r\n * @experimental\r\n */\r\nexport declare abstract class CompilerFactory {\r\n    abstract createCompiler(options?: CompilerOptions[]): Compiler;\r\n}\r\n",
  "/node_modules/@angular/core/src/linker/component_factory.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ChangeDetectorRef } from '../change_detection/change_detection';\r\nimport { Injector } from '../di/injector';\r\nimport { Type } from '../type';\r\nimport { ElementRef } from './element_ref';\r\nimport { NgModuleRef } from './ng_module_factory';\r\nimport { ViewRef } from './view_ref';\r\n/**\r\n * Represents an instance of a Component created via a {@link ComponentFactory}.\r\n *\r\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\r\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\r\n * method.\r\n *\r\n */\r\nexport declare abstract class ComponentRef<C> {\r\n    /**\r\n     * Location of the Host Element of this Component Instance.\r\n     */\r\n    abstract readonly location: ElementRef;\r\n    /**\r\n     * The injector on which the component instance exists.\r\n     */\r\n    abstract readonly injector: Injector;\r\n    /**\r\n     * The instance of the Component.\r\n     */\r\n    abstract readonly instance: C;\r\n    /**\r\n     * The {@link ViewRef} of the Host View of this Component instance.\r\n     */\r\n    abstract readonly hostView: ViewRef;\r\n    /**\r\n     * The {@link ChangeDetectorRef} of the Component instance.\r\n     */\r\n    abstract readonly changeDetectorRef: ChangeDetectorRef;\r\n    /**\r\n     * The component type.\r\n     */\r\n    abstract readonly componentType: Type<any>;\r\n    /**\r\n     * Destroys the component instance and all of the data structures associated with it.\r\n     */\r\n    abstract destroy(): void;\r\n    /**\r\n     * Allows to register a callback that will be called when the component is destroyed.\r\n     */\r\n    abstract onDestroy(callback: Function): void;\r\n}\r\nexport declare abstract class ComponentFactory<C> {\r\n    abstract readonly selector: string;\r\n    abstract readonly componentType: Type<any>;\r\n    /**\r\n     * selector for all <ng-content> elements in the component.\r\n     */\r\n    abstract readonly ngContentSelectors: string[];\r\n    /**\r\n     * the inputs of the component.\r\n     */\r\n    abstract readonly inputs: {\r\n        propName: string;\r\n        templateName: string;\r\n    }[];\r\n    /**\r\n     * the outputs of the component.\r\n     */\r\n    abstract readonly outputs: {\r\n        propName: string;\r\n        templateName: string;\r\n    }[];\r\n    /**\r\n     * Creates a new component.\r\n     */\r\n    abstract create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, ngModule?: NgModuleRef<any>): ComponentRef<C>;\r\n}\r\n",
  "/node_modules/@angular/core/src/linker/component_factory_resolver.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Injector } from '../di/injector';\r\nimport { Type } from '../type';\r\nimport { ComponentFactory, ComponentRef } from './component_factory';\r\nimport { NgModuleRef } from './ng_module_factory';\r\nexport declare function noComponentFactoryError(component: Function): Error;\r\nexport declare function getComponent(error: Error): Type<any>;\r\nexport declare abstract class ComponentFactoryResolver {\r\n    static NULL: ComponentFactoryResolver;\r\n    abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;\r\n}\r\nexport declare class CodegenComponentFactoryResolver implements ComponentFactoryResolver {\r\n    private _parent;\r\n    private _ngModule;\r\n    private _factories;\r\n    constructor(factories: ComponentFactory<any>[], _parent: ComponentFactoryResolver, _ngModule: NgModuleRef<any>);\r\n    resolveComponentFactory<T>(component: {\r\n        new (...args: any[]): T;\r\n    }): ComponentFactory<T>;\r\n}\r\nexport declare class ComponentFactoryBoundToModule<C> extends ComponentFactory<C> {\r\n    private factory;\r\n    private ngModule;\r\n    readonly selector: string;\r\n    readonly componentType: Type<any>;\r\n    readonly ngContentSelectors: string[];\r\n    readonly inputs: {\r\n        propName: string;\r\n        templateName: string;\r\n    }[];\r\n    readonly outputs: {\r\n        propName: string;\r\n        templateName: string;\r\n    }[];\r\n    constructor(factory: ComponentFactory<C>, ngModule: NgModuleRef<any>);\r\n    create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, ngModule?: NgModuleRef<any>): ComponentRef<C>;\r\n}\r\n",
  "/node_modules/@angular/core/src/linker/element_ref.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A wrapper around a native element inside of a View.\r\n *\r\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\r\n * element.\r\n *\r\n * @security Permitting direct access to the DOM can make your application more vulnerable to\r\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\r\n * [Security Guide](http://g.co/ng/security).\r\n *\r\n *\r\n */\r\nexport declare class ElementRef<T = any> {\r\n    /**\r\n     * The underlying native element or `null` if direct access to native elements is not supported\r\n     * (e.g. when the application runs in a web worker).\r\n     *\r\n     * <div class=\"callout is-critical\">\r\n     *   <header>Use with caution</header>\r\n     *   <p>\r\n     *    Use this API as the last resort when direct access to DOM is needed. Use templating and\r\n     *    data-binding provided by Angular instead. Alternatively you can take a look at {@link\r\n     * Renderer2}\r\n     *    which provides API that can safely be used even when direct access to native elements is not\r\n     *    supported.\r\n     *   </p>\r\n     *   <p>\r\n     *    Relying on direct DOM access creates tight coupling between your application and rendering\r\n     *    layers which will make it impossible to separate the two and deploy your application into a\r\n     *    web worker.\r\n     *   </p>\r\n     * </div>\r\n     *\r\n     */\r\n    nativeElement: T;\r\n    constructor(nativeElement: T);\r\n}\r\n",
  "/node_modules/@angular/core/src/linker/ng_module_factory.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Injector } from '../di/injector';\r\nimport { Type } from '../type';\r\nimport { ComponentFactoryResolver } from './component_factory_resolver';\r\n/**\r\n * Represents an instance of an NgModule created via a {@link NgModuleFactory}.\r\n *\r\n * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this\r\n * NgModule Instance.\r\n *\r\n *\r\n */\r\nexport declare abstract class NgModuleRef<T> {\r\n    /**\r\n     * The injector that contains all of the providers of the NgModule.\r\n     */\r\n    abstract readonly injector: Injector;\r\n    /**\r\n     * The ComponentFactoryResolver to get hold of the ComponentFactories\r\n     * declared in the `entryComponents` property of the module.\r\n     */\r\n    abstract readonly componentFactoryResolver: ComponentFactoryResolver;\r\n    /**\r\n     * The NgModule instance.\r\n     */\r\n    abstract readonly instance: T;\r\n    /**\r\n     * Destroys the module instance and all of the data structures associated with it.\r\n     */\r\n    abstract destroy(): void;\r\n    /**\r\n     * Allows to register a callback that will be called when the module is destroyed.\r\n     */\r\n    abstract onDestroy(callback: () => void): void;\r\n}\r\nexport interface InternalNgModuleRef<T> extends NgModuleRef<T> {\r\n    _bootstrapComponents: Type<any>[];\r\n}\r\n/**\r\n * @experimental\r\n */\r\nexport declare abstract class NgModuleFactory<T> {\r\n    abstract readonly moduleType: Type<T>;\r\n    abstract create(parentInjector: Injector | null): NgModuleRef<T>;\r\n}\r\n",
  "/node_modules/@angular/core/src/linker/ng_module_factory_loader.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { NgModuleFactory } from './ng_module_factory';\r\n/**\r\n * Used to load ng module factories.\r\n *\r\n */\r\nexport declare abstract class NgModuleFactoryLoader {\r\n    abstract load(path: string): Promise<NgModuleFactory<any>>;\r\n}\r\n/**\r\n * Registers a loaded module. Should only be called from generated NgModuleFactory code.\r\n * @experimental\r\n */\r\nexport declare function registerModuleFactory(id: string, factory: NgModuleFactory<any>): void;\r\nexport declare function clearModulesForTest(): void;\r\n/**\r\n * Returns the NgModuleFactory with the given id, if it exists and has been loaded.\r\n * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module\r\n * cannot be found.\r\n * @experimental\r\n */\r\nexport declare function getModuleFactory(id: string): NgModuleFactory<any>;\r\n",
  "/node_modules/@angular/core/src/linker/query_list.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Observable } from 'rxjs';\r\n/**\r\n * An unmodifiable list of items that Angular keeps up to date when the state\r\n * of the application changes.\r\n *\r\n * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\r\n * provide.\r\n *\r\n * Implements an iterable interface, therefore it can be used in both ES6\r\n * javascript `for (var i of items)` loops as well as in Angular templates with\r\n * `*ngFor=\"let i of myList\"`.\r\n *\r\n * Changes can be observed by subscribing to the changes `Observable`.\r\n *\r\n * NOTE: In the future this class will implement an `Observable` interface.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n * ```typescript\r\n * @Component({...})\r\n * class Container {\r\n *   @ViewChildren(Item) items:QueryList<Item>;\r\n * }\r\n * ```\r\n */\r\nexport declare class QueryList<T> {\r\n    readonly dirty: boolean;\r\n    private _results;\r\n    readonly changes: Observable<any>;\r\n    readonly length: number;\r\n    readonly first: T;\r\n    readonly last: T;\r\n    /**\r\n     * See\r\n     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\r\n     */\r\n    map<U>(fn: (item: T, index: number, array: T[]) => U): U[];\r\n    /**\r\n     * See\r\n     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\r\n     */\r\n    filter(fn: (item: T, index: number, array: T[]) => boolean): T[];\r\n    /**\r\n     * See\r\n     * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\r\n     */\r\n    find(fn: (item: T, index: number, array: T[]) => boolean): T | undefined;\r\n    /**\r\n     * See\r\n     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\r\n     */\r\n    reduce<U>(fn: (prevValue: U, curValue: T, curIndex: number, array: T[]) => U, init: U): U;\r\n    /**\r\n     * See\r\n     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\r\n     */\r\n    forEach(fn: (item: T, index: number, array: T[]) => void): void;\r\n    /**\r\n     * See\r\n     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\r\n     */\r\n    some(fn: (value: T, index: number, array: T[]) => boolean): boolean;\r\n    toArray(): T[];\r\n    toString(): string;\r\n    reset(res: Array<T | any[]>): void;\r\n    notifyOnChanges(): void;\r\n    /** internal */\r\n    setDirty(): void;\r\n    /** internal */\r\n    destroy(): void;\r\n}\r\n",
  "/node_modules/@angular/core/src/linker/system_js_ng_module_factory_loader.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Compiler } from './compiler';\r\nimport { NgModuleFactory } from './ng_module_factory';\r\nimport { NgModuleFactoryLoader } from './ng_module_factory_loader';\r\n/**\r\n * Configuration for SystemJsNgModuleLoader.\r\n * token.\r\n *\r\n * @experimental\r\n */\r\nexport declare abstract class SystemJsNgModuleLoaderConfig {\r\n    /**\r\n     * Prefix to add when computing the name of the factory module for a given module name.\r\n     */\r\n    factoryPathPrefix: string;\r\n    /**\r\n     * Suffix to add when computing the name of the factory module for a given module name.\r\n     */\r\n    factoryPathSuffix: string;\r\n}\r\n/**\r\n * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory\r\n * @experimental\r\n */\r\nexport declare class SystemJsNgModuleLoader implements NgModuleFactoryLoader {\r\n    private _compiler;\r\n    private _config;\r\n    constructor(_compiler: Compiler, config?: SystemJsNgModuleLoaderConfig);\r\n    load(path: string): Promise<NgModuleFactory<any>>;\r\n    private loadAndCompile;\r\n    private loadFactory;\r\n}\r\n",
  "/node_modules/@angular/core/src/linker/template_ref.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ElementRef } from './element_ref';\r\nimport { EmbeddedViewRef } from './view_ref';\r\n/**\r\n * Represents an Embedded Template that can be used to instantiate Embedded Views.\r\n *\r\n * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<ng-template>` element\r\n * (or directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into\r\n * the constructor of the directive using the `TemplateRef` Token. Alternatively you can query for\r\n * the `TemplateRef` from a Component or a Directive via {@link Query}.\r\n *\r\n * To instantiate Embedded Views based on a Template, use {@link ViewContainerRef#\r\n * createEmbeddedView}, which will create the View and attach it to the View Container.\r\n *\r\n */\r\nexport declare abstract class TemplateRef<C> {\r\n    /**\r\n     * The location in the View where the Embedded View logically belongs to.\r\n     *\r\n     * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`\r\n     * inherit from the contexts of this location.\r\n     *\r\n     * Typically new Embedded Views are attached to the View Container of this location, but in\r\n     * advanced use-cases, the View can be attached to a different container while keeping the\r\n     * data-binding and injection context from the original location.\r\n     *\r\n     */\r\n    abstract readonly elementRef: ElementRef;\r\n    abstract createEmbeddedView(context: C): EmbeddedViewRef<C>;\r\n}\r\n",
  "/node_modules/@angular/core/src/linker/view_container_ref.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Injector } from '../di/injector';\r\nimport { ComponentFactory, ComponentRef } from './component_factory';\r\nimport { ElementRef } from './element_ref';\r\nimport { NgModuleRef } from './ng_module_factory';\r\nimport { TemplateRef } from './template_ref';\r\nimport { EmbeddedViewRef, ViewRef } from './view_ref';\r\n/**\r\n * Represents a container where one or more Views can be attached.\r\n *\r\n * The container can contain two kinds of Views. Host Views, created by instantiating a\r\n * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an\r\n * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.\r\n *\r\n * The location of the View Container within the containing View is specified by the Anchor\r\n * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only\r\n * have a single View Container.\r\n *\r\n * Root elements of Views attached to this container become siblings of the Anchor Element in\r\n * the Rendered View.\r\n *\r\n * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected\r\n * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.\r\n *\r\n */\r\nexport declare abstract class ViewContainerRef {\r\n    /**\r\n     * Anchor element that specifies the location of this container in the containing View.\r\n     * <!-- TODO: rename to anchorElement -->\r\n     */\r\n    abstract readonly element: ElementRef;\r\n    abstract readonly injector: Injector;\r\n    /** @deprecated No replacement */\r\n    abstract readonly parentInjector: Injector;\r\n    /**\r\n     * Destroys all Views in this container.\r\n     */\r\n    abstract clear(): void;\r\n    /**\r\n     * Returns the {@link ViewRef} for the View located in this container at the specified index.\r\n     */\r\n    abstract get(index: number): ViewRef | null;\r\n    /**\r\n     * Returns the number of Views currently attached to this container.\r\n     */\r\n    abstract readonly length: number;\r\n    /**\r\n     * Instantiates an Embedded View based on the {@link TemplateRef `templateRef`} and inserts it\r\n     * into this container at the specified `index`.\r\n     *\r\n     * If `index` is not specified, the new View will be inserted as the last View in the container.\r\n     *\r\n     * Returns the {@link ViewRef} for the newly created View.\r\n     */\r\n    abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>;\r\n    /**\r\n     * Instantiates a single {@link Component} and inserts its Host View into this container at the\r\n     * specified `index`.\r\n     *\r\n     * The component is instantiated using its {@link ComponentFactory} which can be obtained via\r\n     * {@link ComponentFactoryResolver#resolveComponentFactory resolveComponentFactory}.\r\n     *\r\n     * If `index` is not specified, the new View will be inserted as the last View in the container.\r\n     *\r\n     * You can optionally specify the {@link Injector} that will be used as parent for the Component.\r\n     *\r\n     * Returns the {@link ComponentRef} of the Host View created for the newly instantiated Component.\r\n     */\r\n    abstract createComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector, projectableNodes?: any[][], ngModule?: NgModuleRef<any>): ComponentRef<C>;\r\n    /**\r\n     * Inserts a View identified by a {@link ViewRef} into the container at the specified `index`.\r\n     *\r\n     * If `index` is not specified, the new View will be inserted as the last View in the container.\r\n     *\r\n     * Returns the inserted {@link ViewRef}.\r\n     */\r\n    abstract insert(viewRef: ViewRef, index?: number): ViewRef;\r\n    /**\r\n     * Moves a View identified by a {@link ViewRef} into the container at the specified `index`.\r\n     *\r\n     * Returns the inserted {@link ViewRef}.\r\n     */\r\n    abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;\r\n    /**\r\n     * Returns the index of the View, specified via {@link ViewRef}, within the current container or\r\n     * `-1` if this container doesn't contain the View.\r\n     */\r\n    abstract indexOf(viewRef: ViewRef): number;\r\n    /**\r\n     * Destroys a View attached to this container at the specified `index`.\r\n     *\r\n     * If `index` is not specified, the last View in the container will be removed.\r\n     */\r\n    abstract remove(index?: number): void;\r\n    /**\r\n     * Use along with {@link #insert} to move a View within the current container.\r\n     *\r\n     * If the `index` param is omitted, the last {@link ViewRef} is detached.\r\n     */\r\n    abstract detach(index?: number): ViewRef | null;\r\n}\r\n",
  "/node_modules/@angular/core/src/linker/view_ref.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ApplicationRef } from '../application_ref';\r\nimport { ChangeDetectorRef } from '../change_detection/change_detector_ref';\r\nexport declare abstract class ViewRef extends ChangeDetectorRef {\r\n    /**\r\n     * Destroys the view and all of the data structures associated with it.\r\n     */\r\n    abstract destroy(): void;\r\n    abstract readonly destroyed: boolean;\r\n    abstract onDestroy(callback: Function): any /** TODO #9100 */;\r\n}\r\n/**\r\n * Represents an Angular View.\r\n *\r\n * <!-- TODO: move the next two paragraphs to the dev guide -->\r\n * A View is a fundamental building block of the application UI. It is the smallest grouping of\r\n * Elements which are created and destroyed together.\r\n *\r\n * Properties of elements in a View can change, but the structure (number and order) of elements in\r\n * a View cannot. Changing the structure of Elements can only be done by inserting, moving or\r\n * removing nested Views via a `ViewContainerRef`. Each View can contain many View Containers.\r\n * <!-- /TODO -->\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * Given this template...\r\n *\r\n * ```\r\n * Count: {{items.length}}\r\n * <ul>\r\n *   <li *ngFor=\"let  item of items\">{{item}}</li>\r\n * </ul>\r\n * ```\r\n *\r\n * We have two `TemplateRef`s:\r\n *\r\n * Outer `TemplateRef`:\r\n *\r\n * ```\r\n * Count: {{items.length}}\r\n * <ul>\r\n *   <ng-template ngFor let-item [ngForOf]=\"items\"></ng-template>\r\n * </ul>\r\n * ```\r\n *\r\n * Inner `TemplateRef`:\r\n *\r\n * ```\r\n *   <li>{{item}}</li>\r\n * ```\r\n *\r\n * Notice that the original template is broken down into two separate `TemplateRef`s.\r\n *\r\n * The outer/inner `TemplateRef`s are then assembled into views like so:\r\n *\r\n * ```\r\n * <!-- ViewRef: outer-0 -->\r\n * Count: 2\r\n * <ul>\r\n *   <ng-template view-container-ref></ng-template>\r\n *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->\r\n *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->\r\n * </ul>\r\n * <!-- /ViewRef: outer-0 -->\r\n * ```\r\n * @experimental\r\n */\r\nexport declare abstract class EmbeddedViewRef<C> extends ViewRef {\r\n    abstract readonly context: C;\r\n    abstract readonly rootNodes: any[];\r\n}\r\nexport interface InternalViewRef extends ViewRef {\r\n    detachFromAppRef(): void;\r\n    attachToAppRef(appRef: ApplicationRef): void;\r\n}\r\n",
  "/node_modules/@angular/core/src/linker.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { COMPILER_OPTIONS, Compiler, CompilerFactory, CompilerOptions, ModuleWithComponentFactories } from './linker/compiler';\r\nexport { ComponentFactory, ComponentRef } from './linker/component_factory';\r\nexport { ComponentFactoryResolver } from './linker/component_factory_resolver';\r\nexport { ElementRef } from './linker/element_ref';\r\nexport { NgModuleFactory, NgModuleRef } from './linker/ng_module_factory';\r\nexport { NgModuleFactoryLoader, getModuleFactory } from './linker/ng_module_factory_loader';\r\nexport { QueryList } from './linker/query_list';\r\nexport { SystemJsNgModuleLoader, SystemJsNgModuleLoaderConfig } from './linker/system_js_ng_module_factory_loader';\r\nexport { TemplateRef } from './linker/template_ref';\r\nexport { ViewContainerRef } from './linker/view_container_ref';\r\nexport { EmbeddedViewRef, ViewRef } from './linker/view_ref';\r\n",
  "/node_modules/@angular/core/src/metadata/di.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { InjectionToken } from '../di/injection_token';\r\nimport { Type } from '../type';\r\n/**\r\n * This token can be used to create a virtual provider that will populate the\r\n * `entryComponents` fields of components and ng modules based on its `useValue`.\r\n * All components that are referenced in the `useValue` value (either directly\r\n * or in a nested array or map) will be added to the `entryComponents` property.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n * The following example shows how the router can populate the `entryComponents`\r\n * field of an NgModule based on the router configuration which refers\r\n * to components.\r\n *\r\n * ```typescript\r\n * // helper function inside the router\r\n * function provideRoutes(routes) {\r\n *   return [\r\n *     {provide: ROUTES, useValue: routes},\r\n *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}\r\n *   ];\r\n * }\r\n *\r\n * // user code\r\n * let routes = [\r\n *   {path: '/root', component: RootComp},\r\n *   {path: '/teams', component: TeamsComp}\r\n * ];\r\n *\r\n * @NgModule({\r\n *   providers: [provideRoutes(routes)]\r\n * })\r\n * class ModuleWithRoutes {}\r\n * ```\r\n *\r\n * @experimental\r\n */\r\nexport declare const ANALYZE_FOR_ENTRY_COMPONENTS: InjectionToken<any>;\r\n/**\r\n * Type of the Attribute decorator / constructor function.\r\n *\r\n *\r\n */\r\nexport interface AttributeDecorator {\r\n    /**\r\n     * Specifies that a constant attribute value should be injected.\r\n     *\r\n     * The directive can inject constant string literals of host element attributes.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * Suppose we have an `<input>` element and want to know its `type`.\r\n     *\r\n     * ```html\r\n     * <input type=\"text\">\r\n     * ```\r\n     *\r\n     * A decorator can inject string literal `text` like so:\r\n     *\r\n     * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\r\n     *\r\n     * ### Example as TypeScript Decorator\r\n     *\r\n     * {@example core/ts/metadata/metadata.ts region='attributeFactory'}\r\n     *\r\n     * ### Example as ES5 annotation\r\n     *\r\n     * ```\r\n     * var MyComponent = function(title) {\r\n     *   ...\r\n     * };\r\n     *\r\n     * MyComponent.annotations = [\r\n     *   new ng.Component({...})\r\n     * ]\r\n     * MyComponent.parameters = [\r\n     *   [new ng.Attribute('title')]\r\n     * ]\r\n     * ```\r\n     *\r\n     *\r\n     */\r\n    (name: string): any;\r\n    new (name: string): Attribute;\r\n}\r\n/**\r\n * Type of the Attribute metadata.\r\n */\r\nexport interface Attribute {\r\n    attributeName?: string;\r\n}\r\n/**\r\n * Attribute decorator and metadata.\r\n *\r\n * @Annotation\r\n */\r\nexport declare const Attribute: AttributeDecorator;\r\n/**\r\n * Type of the Query metadata.\r\n */\r\nexport interface Query {\r\n    descendants: boolean;\r\n    first: boolean;\r\n    read: any;\r\n    isViewQuery: boolean;\r\n    selector: any;\r\n}\r\n/**\r\n * Base class for query metadata.\r\n *\r\n * @see `ContentChildren`.\r\n * @see `ContentChild`.\r\n * @see `ViewChildren`.\r\n * @see `ViewChild`.\r\n */\r\nexport declare abstract class Query {\r\n}\r\n/**\r\n * Type of the ContentChildren decorator / constructor function.\r\n *\r\n * @see `ContentChildren`.\r\n */\r\nexport interface ContentChildrenDecorator {\r\n    /**\r\n     * Configures a content query.\r\n     *\r\n     * You can use ContentChildren to get the `QueryList` of elements or directives from the\r\n     * content DOM. Any time a child element is added, removed, or moved, the query list will be\r\n     * updated, and the changes observable of the query list will emit a new value.\r\n     *\r\n     * Content queries are set before the `ngAfterContentInit` callback is called.\r\n     *\r\n     * **Metadata Properties**:\r\n     *\r\n     * * **selector** - the directive type or the name used for querying.\r\n     * * **descendants** - include only direct children or all descendants.\r\n     * * **read** - read a different token from the queried elements.\r\n     *\r\n     * @usageNotes\r\n     * ### Basic Example\r\n     *\r\n     * Here is a simple demonstration of how the `ContentChildren` decorator can be used.\r\n     *\r\n     * {@example core/di/ts/contentChildren/content_children_howto.ts region='HowTo'}\r\n     *\r\n     * ### Tab-pane Example\r\n     *\r\n     * Here is a slightly more realistic example that shows how `ContentChildren` decorators\r\n     * can be used to implement a tab pane component.\r\n     *\r\n     * {@example core/di/ts/contentChildren/content_children_example.ts region='Component'}\r\n     *\r\n     * @Annotation\r\n     */\r\n    (selector: Type<any> | Function | string, opts?: {\r\n        descendants?: boolean;\r\n        read?: any;\r\n    }): any;\r\n    new (selector: Type<any> | Function | string, opts?: {\r\n        descendants?: boolean;\r\n        read?: any;\r\n    }): Query;\r\n}\r\n/**\r\n * Type of the ContentChildren metadata.\r\n *\r\n *\r\n * @Annotation\r\n */\r\nexport declare type ContentChildren = Query;\r\n/**\r\n * ContentChildren decorator and metadata.\r\n *\r\n *\r\n *  @Annotation\r\n */\r\nexport declare const ContentChildren: ContentChildrenDecorator;\r\n/**\r\n * Type of the ContentChild decorator / constructor function.\r\n *\r\n *\r\n *\r\n */\r\nexport interface ContentChildDecorator {\r\n    /**\r\n     * Configures a content query.\r\n     *\r\n     * You can use ContentChild to get the first element or the directive matching the selector from\r\n     * the content DOM. If the content DOM changes, and a new child matches the selector,\r\n     * the property will be updated.\r\n     *\r\n     * Content queries are set before the `ngAfterContentInit` callback is called.\r\n     *\r\n     * **Metadata Properties**:\r\n     *\r\n     * * **selector** - the directive type or the name used for querying.\r\n     * * **read** - read a different token from the queried element.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}\r\n     *\r\n     * ### Example\r\n     *\r\n     * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}\r\n     *\r\n     * @Annotation\r\n     */\r\n    (selector: Type<any> | Function | string, opts?: {\r\n        read?: any;\r\n    }): any;\r\n    new (selector: Type<any> | Function | string, opts?: {\r\n        read?: any;\r\n    }): ContentChild;\r\n}\r\n/**\r\n * Type of the ContentChild metadata.\r\n *\r\n * @see `ContentChild`.\r\n *\r\n *\r\n */\r\nexport declare type ContentChild = Query;\r\n/**\r\n * ContentChild decorator and metadata.\r\n *\r\n *\r\n * @Annotation\r\n */\r\nexport declare const ContentChild: ContentChildDecorator;\r\n/**\r\n * Type of the ViewChildren decorator / constructor function.\r\n *\r\n * @see `ViewChildren`.\r\n *\r\n *\r\n */\r\nexport interface ViewChildrenDecorator {\r\n    /**\r\n     * Configures a view query.\r\n     *\r\n     * You can use ViewChildren to get the `QueryList` of elements or directives from the\r\n     * view DOM. Any time a child element is added, removed, or moved, the query list will be updated,\r\n     * and the changes observable of the query list will emit a new value.\r\n     *\r\n     * View queries are set before the `ngAfterViewInit` callback is called.\r\n     *\r\n     * **Metadata Properties**:\r\n     *\r\n     * * **selector** - the directive type or the name used for querying.\r\n     * * **read** - read a different token from the queried elements.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Example\r\n     *\r\n     * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}\r\n     *\r\n     * ### Example\r\n     *\r\n     * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}\r\n     *\r\n     * @Annotation\r\n     */\r\n    (selector: Type<any> | Function | string, opts?: {\r\n        read?: any;\r\n    }): any;\r\n    new (selector: Type<any> | Function | string, opts?: {\r\n        read?: any;\r\n    }): ViewChildren;\r\n}\r\n/**\r\n * Type of the ViewChildren metadata.\r\n */\r\nexport declare type ViewChildren = Query;\r\n/**\r\n * ViewChildren decorator and metadata.\r\n *\r\n * @Annotation\r\n */\r\nexport declare const ViewChildren: ViewChildrenDecorator;\r\n/**\r\n * Type of the ViewChild decorator / constructor function.\r\n *\r\n * @see `ViewChild`.\r\n */\r\nexport interface ViewChildDecorator {\r\n    /**\r\n     * @description\r\n     * Property decorator that configures a view query.\r\n     * The change detector looks for the first element or the directive matching the selector\r\n     * in the view DOM. If the view DOM changes, and a new child matches the selector,\r\n     * the property is updated.\r\n     *\r\n     * View queries are set before the `ngAfterViewInit` callback is called.\r\n     *\r\n     * **Metadata Properties**:\r\n     *\r\n     * * **selector** - the directive type or the name used for querying.\r\n     * * **read** - read a different token from the queried elements.\r\n     *\r\n     * Supported selectors include:\r\n     *   * any class with the `@Component` or `@Directive` decorator\r\n     *   * a template reference variable as a string (e.g. query `<my-component #cmp></my-component>\r\n     * with `@ViewChild('cmp')`)\r\n     *   * any provider defined in the child component tree of the current component (e.g.\r\n     * `@ViewChild(SomeService) someService: SomeService`)\r\n     *   * any provider defined through a string token (e.g. `@ViewChild('someToken') someTokenVal:\r\n     * any`)\r\n     *   * a `TemplateRef` (e.g. query `<ng-template></ng-template>` with `@ViewChild(TemplateRef)\r\n     * template;`)\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * {@example core/di/ts/viewChild/view_child_example.ts region='Component'}\r\n     *\r\n     * ### Example\r\n     *\r\n     * {@example core/di/ts/viewChild/view_child_howto.ts region='HowTo'}\r\n     *\r\n     * ### Example\r\n     *\r\n     * {@example core/di/ts/viewChild/view_child_example.ts region='Component'}\r\n     *\r\n     * @Annotation\r\n     */\r\n    (selector: Type<any> | Function | string, opts?: {\r\n        read?: any;\r\n    }): any;\r\n    new (selector: Type<any> | Function | string, opts?: {\r\n        read?: any;\r\n    }): ViewChild;\r\n}\r\n/**\r\n * Type of the ViewChild metadata.\r\n */\r\nexport declare type ViewChild = Query;\r\n/**\r\n * ViewChild decorator and metadata.\r\n *\r\n * @Annotation\r\n */\r\nexport declare const ViewChild: ViewChildDecorator;\r\n",
  "/node_modules/@angular/core/src/metadata/directives.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ChangeDetectionStrategy } from '../change_detection/constants';\r\nimport { Provider } from '../di';\r\nimport { Type } from '../type';\r\nimport { TypeDecorator } from '../util/decorators';\r\nimport { ViewEncapsulation } from './view';\r\n/**\r\n * Type of the Directive decorator / constructor function.\r\n */\r\nexport interface DirectiveDecorator {\r\n    /**\r\n     * Marks a class as an Angular directive. You can define your own\r\n     * directives to attach custom behavior to elements in the DOM.\r\n     * The options provide configuration metadata that determines\r\n     * how the directive should be processed, instantiated and used at\r\n     * runtime.\r\n     *\r\n     * Directive classes, like component classes, can implement\r\n     * [life-cycle hooks](guide/lifecycle-hooks) to influence their configuration and behavior.\r\n     *\r\n     *\r\n     * @usageNotes\r\n     * To define a directive, mark the class with the decorator and provide metadata.\r\n     *\r\n     * ```\r\n     * import {Directive} from '@angular/core';\r\n     *\r\n     * @Directive({\r\n     *   selector: 'my-directive',\r\n     * })\r\n     * export class MyDirective {\r\n     * ...\r\n     * }\r\n     * ```\r\n     *\r\n     * ### Declaring directives\r\n     *\r\n     * Directives are [declarables](guide/glossary#declarable).\r\n     * They must be declared by an NgModule\r\n     * in order to be usable in an app.\r\n     *\r\n     * A directive must belong to exactly one NgModule. Do not re-declare\r\n     * a directive imported from another module.\r\n     * List the directive class in the `declarations` field of an NgModule.\r\n     *\r\n     * ```\r\n     * declarations: [\r\n     *  AppComponent,\r\n     *  MyDirective\r\n     * ],\r\n     * ```\r\n     *\r\n     * @Annotation\r\n     */\r\n    (obj: Directive): TypeDecorator;\r\n    /**\r\n     * See the `Directive` decorator.\r\n     */\r\n    new (obj: Directive): Directive;\r\n}\r\nexport interface Directive {\r\n    /**\r\n     * The CSS selector that triggers the instantiation of a directive.\r\n     *\r\n     * Declare as one of the following:\r\n     *\r\n     * - `element-name`: select by element name.\r\n     * - `.class`: select by class name.\r\n     * - `[attribute]`: select by attribute name.\r\n     * - `[attribute=value]`: select by attribute name and value.\r\n     * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.\r\n     * - `selector1, selector2`: select if either `selector1` or `selector2` matches.\r\n     *\r\n     * Angular only allows directives to trigger on CSS selectors that do not cross element\r\n     * boundaries. For example, consider a directive with an `input[type=text]` selector.\r\n     * For the following HTML, the directive is instantiated only on the\r\n     * `<input type=\"text\">` element.\r\n     *\r\n     * ```html\r\n     * <form>\r\n     *   <input type=\"text\">\r\n     *   <input type=\"radio\">\r\n     * <form>\r\n     * ```\r\n     *\r\n     */\r\n    selector?: string;\r\n    /**\r\n     * Enumerates the set of data-bound input properties for a directive\r\n     *\r\n     * Angular automatically updates input properties during change detection.\r\n     * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`\r\n     * configuration:\r\n     *\r\n     * - `directiveProperty` specifies the component property where the value is written.\r\n     * - `bindingProperty` specifies the DOM property where the value is read from.\r\n     *\r\n     * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.\r\n     * @usageNotes\r\n     *\r\n     * ### Example\r\n     *\r\n     * The following example creates a component with two data-bound properties.\r\n     *\r\n     * ```typescript\r\n     * @Component({\r\n     *   selector: 'bank-account',\r\n     *   inputs: ['bankName', 'id: account-id'],\r\n     *   template: `\r\n     *     Bank Name: {{bankName}}\r\n     *     Account Id: {{id}}\r\n     *   `\r\n     * })\r\n     * class BankAccount {\r\n     *   bankName: string;\r\n     *   id: string;\r\n     *\r\n     * ```\r\n     */\r\n    inputs?: string[];\r\n    /**\r\n     * Enumerates the set of event-bound output properties.\r\n     *\r\n     * When an output property emits an event, an event handler attached to that event\r\n     * in the template is invoked.\r\n     *\r\n     * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`\r\n     * configuration:\r\n     *\r\n     * - `directiveProperty` specifies the component property that emits events.\r\n     * - `bindingProperty` specifies the DOM property the event handler is attached to.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * @Directive({\r\n     *   selector: 'child-dir',\r\n     *   exportAs: 'child'\r\n     * })\r\n     * class ChildDir {\r\n     * }\r\n     *\r\n     * @Component({\r\n     *   selector: 'main',\r\n     *   template: `<child-dir #c=\"child\"></child-dir>`\r\n     * })\r\n     * class MainComponent {\r\n     * }\r\n     * ```\r\n     */\r\n    outputs?: string[];\r\n    /**\r\n     * A set of injection tokens that allow the DI system to\r\n     * provide a dependency to this directive or component.\r\n     */\r\n    providers?: Provider[];\r\n    /**\r\n     * Defines the name that can be used in the template to assign this directive to a variable.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Simple Example\r\n     *\r\n     * ```\r\n     * @Directive({\r\n     *   selector: 'child-dir',\r\n     *   exportAs: 'child'\r\n     * })\r\n     * class ChildDir {\r\n     * }\r\n     *\r\n     * @Component({\r\n     *   selector: 'main',\r\n     *   template: `<child-dir #c=\"child\"></child-dir>`\r\n     * })\r\n     * class MainComponent {\r\n     * }\r\n     * ```\r\n     */\r\n    exportAs?: string;\r\n    /**\r\n     * Configures the queries that will be injected into the directive.\r\n     *\r\n     * Content queries are set before the `ngAfterContentInit` callback is called.\r\n     * View queries are set before the `ngAfterViewInit` callback is called.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Example\r\n     *\r\n     * The following example shows how queries are defined\r\n     * and when their results are available in lifecycle hooks:\r\n     *\r\n     * ```\r\n     * @Component({\r\n     *   selector: 'someDir',\r\n     *   queries: {\r\n     *     contentChildren: new ContentChildren(ChildDirective),\r\n     *     viewChildren: new ViewChildren(ChildDirective)\r\n     *   },\r\n     *   template: '<child-directive></child-directive>'\r\n     * })\r\n     * class SomeDir {\r\n     *   contentChildren: QueryList<ChildDirective>,\r\n     *   viewChildren: QueryList<ChildDirective>\r\n     *\r\n     *   ngAfterContentInit() {\r\n     *     // contentChildren is set\r\n     *   }\r\n     *\r\n     *   ngAfterViewInit() {\r\n     *     // viewChildren is set\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * @Annotation\r\n     */\r\n    queries?: {\r\n        [key: string]: any;\r\n    };\r\n    /**\r\n     * If true, this directive/component will be skipped by the AOT compiler and so will always be\r\n     * compiled using JIT.\r\n     *\r\n     * This exists to support future Ivy work and has no effect currently.\r\n     */\r\n    jit?: true;\r\n}\r\n/**\r\n * Directive decorator and metadata.\r\n *\r\n * @Annotation\r\n */\r\nexport interface Directive {\r\n    /**\r\n     * The CSS selector that identifies this directive in a template\r\n     * and triggers instantiation of the directive.\r\n     *\r\n     * Declare as one of the following:\r\n     *\r\n     * - `element-name`: Select by element name.\r\n     * - `.class`: Select by class name.\r\n     * - `[attribute]`: Select by attribute name.\r\n     * - `[attribute=value]`: Select by attribute name and value.\r\n     * - `:not(sub_selector)`: Select only if the element does not match the `sub_selector`.\r\n     * - `selector1, selector2`: Select if either `selector1` or `selector2` matches.\r\n     *\r\n     * Angular only allows directives to apply on CSS selectors that do not cross\r\n     * element boundaries.\r\n     *\r\n     * For the following template HTML, a directive with an `input[type=text]` selector,\r\n     * would be instantiated only on the `<input type=\"text\">` element.\r\n     *\r\n     * ```html\r\n     * <form>\r\n     *   <input type=\"text\">\r\n     *   <input type=\"radio\">\r\n     * <form>\r\n     * ```\r\n     *\r\n     */\r\n    selector?: string;\r\n    /**\r\n     * The set of event-bound output properties.\r\n     * When an output property emits an event, an event handler attached\r\n     * to that event in the template is invoked.\r\n     *\r\n     * Each output property maps a `directiveProperty` to a `bindingProperty`:\r\n     * - `directiveProperty` specifies the component property that emits events.\r\n     * - `bindingProperty` specifies the HTML attribute the event handler is attached to.\r\n     *\r\n     */\r\n    outputs?: string[];\r\n    /**\r\n     * Maps class properties to host element bindings for properties,\r\n     * attributes, and events, using a set of key-value pairs.\r\n     *\r\n     * Angular automatically checks host property bindings during change detection.\r\n     * If a binding changes, Angular updates the directive's host element.\r\n     *\r\n     * When the key is a property of the host element, the property value is\r\n     * the propagated to the specified DOM property.\r\n     *\r\n     * When the key is a static attribute in the DOM, the attribute value\r\n     * is propagated to the specified property in the host element.\r\n     *\r\n     * For event handling:\r\n     * - The key is the DOM event that the directive listens to.\r\n     * To listen to global events, add the target to the event name.\r\n     * The target can be `window`, `document` or `body`.\r\n     * - The value is the statement to execute when the event occurs. If the\r\n     * statement evalueates to `false`, then `preventDefault` is applied on the DOM\r\n     * event. A handler method can refer to the `$event` local variable.\r\n     *\r\n     */\r\n    host?: {\r\n        [key: string]: string;\r\n    };\r\n    /**\r\n     * Configures the [injector](guide/glossary#injector) of this\r\n     * directive or component with a [token](guide/glossary#di-token)\r\n     * that maps to a [provider](guide/glossary#provider) of a dependency.\r\n     */\r\n    providers?: Provider[];\r\n    /**\r\n     * The name or names that can be used in the template to assign this directive to a variable.\r\n     * For multiple names, use a comma-separated string.\r\n     *\r\n     */\r\n    exportAs?: string;\r\n    /**\r\n     * Configures the queries that will be injected into the directive.\r\n     *\r\n     * Content queries are set before the `ngAfterContentInit` callback is called.\r\n     * View queries are set before the `ngAfterViewInit` callback is called.\r\n     *\r\n     */\r\n    queries?: {\r\n        [key: string]: any;\r\n    };\r\n}\r\n/**\r\n * Type of the Directive metadata.\r\n */\r\nexport declare const Directive: DirectiveDecorator;\r\n/**\r\n * Component decorator interface\r\n *\r\n */\r\nexport interface ComponentDecorator {\r\n    /**\r\n     * Decorator that marks a class as an Angular component and provides configuration\r\n     * metadata that determines how the component should be processed,\r\n     * instantiated, and used at runtime.\r\n     *\r\n     * Components are the most basic UI building block of an Angular app.\r\n     * An Angular app contains a tree of Angular components.\r\n     *\r\n     * Angular components are a subset of directives, always associated with a template.\r\n     * Unlike other directives, only one component can be instantiated per an element in a template.\r\n     *\r\n     * A component must belong to an NgModule in order for it to be available\r\n     * to another component or application. To make it a member of an NgModule,\r\n     * list it in the `declarations` field of the `@NgModule` metadata.\r\n     *\r\n     * Note that, in addition to these options for configuring a directive,\r\n     * you can control a component's runtime behavior by implementing\r\n     * life-cycle hooks. For more information, see the\r\n     * [Lifecycle Hooks](guide/lifecycle-hooks) guide.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Setting component inputs\r\n     *\r\n     * The following example creates a component with two data-bound properties,\r\n     * specified by the `inputs` value.\r\n     *\r\n     * <code-example path=\"core/ts/metadata/directives.ts\" region=\"component-input\">\r\n     * </code-example>\r\n     *\r\n     *\r\n     * ### Setting component outputs\r\n     *\r\n     * The following example shows two event emitters that emit on an interval. One\r\n     * emits an output every second, while the other emits every five seconds.\r\n     *\r\n     * {@example core/ts/metadata/directives.ts region='component-output-interval'}\r\n     *\r\n     * ### Injecting a class with a view provider\r\n     *\r\n     * The following simple example injects a class into a component\r\n     * using the view provider specified in component metadata:\r\n     *\r\n     * ```\r\n     * class Greeter {\r\n     *    greet(name:string) {\r\n     *      return 'Hello ' + name + '!';\r\n     *    }\r\n     * }\r\n     *\r\n     * @Directive({\r\n     *   selector: 'needs-greeter'\r\n     * })\r\n     * class NeedsGreeter {\r\n     *   greeter:Greeter;\r\n     *\r\n     *   constructor(greeter:Greeter) {\r\n     *     this.greeter = greeter;\r\n     *   }\r\n     * }\r\n     *\r\n     * @Component({\r\n     *   selector: 'greet',\r\n     *   viewProviders: [\r\n     *     Greeter\r\n     *   ],\r\n     *   template: `<needs-greeter></needs-greeter>`\r\n     * })\r\n     * class HelloWorld {\r\n     * }\r\n     *\r\n     * ```\r\n     *\r\n     *\r\n     * @Annotation\r\n     */\r\n    (obj: Component): TypeDecorator;\r\n    /**\r\n     * See the `@Component` decorator.\r\n     */\r\n    new (obj: Component): Component;\r\n}\r\n/**\r\n * Supplies configuration metadata for an Angular component.\r\n */\r\nexport interface Component extends Directive {\r\n    /**\r\n     * The change-detection strategy to use for this component.\r\n     *\r\n     * When a component is instantiated, Angular creates a change detector,\r\n     * which is responsible for propagating the component's bindings.\r\n     * The strategy is one of:\r\n     * - `ChangeDetectionStrategy#OnPush` sets the strategy to `CheckOnce` (on demand).\r\n     * - `ChangeDetectionStrategy#Default` sets the strategy to `CheckAlways`.\r\n     */\r\n    changeDetection?: ChangeDetectionStrategy;\r\n    /**\r\n     * Defines the set of injectable objects that are visible to its view DOM children.\r\n     * See [example](#injecting-a-class-with-a-view-provider).\r\n     *\r\n     */\r\n    viewProviders?: Provider[];\r\n    /**\r\n     * The module ID of the module that contains the component.\r\n     * The component must be able to resolve relative URLs for templates and styles.\r\n     * SystemJS exposes the `__moduleName` variable within each module.\r\n     * In CommonJS, this can  be set to `module.id`.\r\n     *\r\n     */\r\n    moduleId?: string;\r\n    /**\r\n     * The URL of a template file for an Angular component. If provided,\r\n     * do not supply an inline template using `template`.\r\n     *\r\n     */\r\n    templateUrl?: string;\r\n    /**\r\n     * An inline template for an Angular component. If provided,\r\n     * do not supply a template file using `templateUrl`.\r\n     *\r\n     */\r\n    template?: string;\r\n    /**\r\n     * One or more URLs for files containing CSS stylesheets to use\r\n     * in this component.\r\n     */\r\n    styleUrls?: string[];\r\n    /**\r\n     * One or more inline CSS stylesheets to use\r\n     * in this component.\r\n     */\r\n    styles?: string[];\r\n    /**\r\n     * One or more animation `trigger()` calls, containing\r\n     * `state()` and `transition()` definitions.\r\n     * See the [Animations guide](/guide/animations) and animations API documentation.\r\n     *\r\n     */\r\n    animations?: any[];\r\n    /**\r\n     * An encapsulation policy for the template and CSS styles. One of:\r\n     * - `ViewEncapsulation.Native`: Use shadow roots. This works\r\n     * only if natively available on the platform.\r\n     * - `ViewEncapsulation.Emulated`: Use shimmed CSS that\r\n     * emulates the native behavior.\r\n     * - `ViewEncapsulation.None`: Use global CSS without any\r\n     * encapsulation.\r\n     *\r\n     * If not supplied, the value is taken from `CompilerOptions`. The default compiler option is\r\n     * `ViewEncapsulation.Emulated`.\r\n     *\r\n     * If the policy is set to `ViewEncapsulation.Emulated` and the component has no `styles`\r\n     * or `styleUrls` specified, the policy is automatically switched to `ViewEncapsulation.None`.\r\n     */\r\n    encapsulation?: ViewEncapsulation;\r\n    /**\r\n     * Overrides the default encapsulation start and end delimiters (`{{` and `}}`)\r\n     */\r\n    interpolation?: [string, string];\r\n    /**\r\n     * A set of components that should be compiled along with\r\n     * this component. For each component listed here,\r\n     * Angular creates a {@link ComponentFactory} and stores it in the\r\n     * {@link ComponentFactoryResolver}.\r\n     */\r\n    entryComponents?: Array<Type<any> | any[]>;\r\n    /**\r\n     * True to preserve or false to remove potentially superfluous whitespace characters\r\n     * from the compiled template. Whitespace characters are those matching the `\\s`\r\n     * character class in JavaScript regular expressions. Default is false, unless\r\n     * overridden in compiler options.\r\n     */\r\n    preserveWhitespaces?: boolean;\r\n}\r\n/**\r\n * Component decorator and metadata.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using animations\r\n *\r\n * The following snippet shows an animation trigger in a component's\r\n * metadata. The trigger is attached to an element in the component's\r\n * template, using \"@_trigger_name_\", and a state expression that is evaluated\r\n * at run time to determine whether the animation should start.\r\n *\r\n * ```typescript\r\n * @Component({\r\n *   selector: 'animation-cmp',\r\n *   templateUrl: 'animation-cmp.html',\r\n *   animations: [\r\n *     trigger('myTriggerName', [\r\n *       state('on', style({ opacity: 1 }),\r\n *       state('off', style({ opacity: 0 }),\r\n *       transition('on => off', [\r\n *         animate(\"1s\")\r\n *       ])\r\n *     ])\r\n *   ]\r\n * })\r\n * ```\r\n *\r\n * ```html\r\n * <!-- animation-cmp.html -->\r\n * <div @myTriggerName=\"expression\">...</div>\r\n * ```\r\n *\r\n * ### Preserving whitespace\r\n *\r\n * Removing whitespace can greatly reduce AOT-generated code size, and speed up view creation.\r\n * As of Angular 6, default for `preserveWhitespaces` is false (whitespace is removed).\r\n * To change the default setting for all components in your application, set\r\n * the `preserveWhitespaces` option of the AOT compiler.\r\n *\r\n * Current implementation removes whitespace characters as follows:\r\n * - Trims all whitespaces at the beginning and the end of a template.\r\n * - Removes whitespace-only text nodes. For example,\r\n * `<button>Action 1</button>  <button>Action 2</button>` becomes\r\n * `<button>Action 1</button><button>Action 2</button>`.\r\n * - Replaces a series of whitespace characters in text nodes with a single space.\r\n * For example, `<span>\\n some text\\n</span>` becomes `<span> some text </span>`.\r\n * - Does NOT alter text nodes inside HTML tags such as `<pre>` or `<textarea>`,\r\n * where whitespace characters are significant.\r\n *\r\n * Note that these transformations can influence DOM nodes layout, although impact\r\n * should be minimal.\r\n *\r\n * You can override the default behavior to preserve whitespace characters\r\n * in certain fragments of a template. For example, you can exclude an entire\r\n * DOM sub-tree by using the `ngPreserveWhitespaces` attribute:\r\n *\r\n * ```html\r\n * <div ngPreserveWhitespaces>\r\n *     whitespaces are preserved here\r\n *     <span>    and here </span>\r\n * </div>\r\n * ```\r\n *\r\n * You can force a single space to be preserved in a text node by using `&ngsp;`,\r\n * which is replaced with a space character by Angular's template\r\n * compiler:\r\n *\r\n * ```html\r\n * <a>Spaces</a>&ngsp;<a>between</a>&ngsp;<a>links.</a>\r\n * <!-->compiled to be equivalent to:</>\r\n *  <a>Spaces</a> <a>between</a> <a>links.</a>\r\n * ```\r\n *\r\n * Note that sequences of `&ngsp;` are still collapsed to just one space character when\r\n * the `preserveWhitespaces` option is set to `false`.\r\n *\r\n * ```html\r\n * <a>before</a>&ngsp;&ngsp;&ngsp;<a>after</a>\r\n * <!-->compiled to be equivalent to:</>\r\n *  <a>Spaces</a> <a>between</a> <a>links.</a>\r\n * ```\r\n *\r\n * To preserve sequences of whitespace characters, use the\r\n * `ngPreserveWhitespaces` attribute.\r\n *\r\n * @Annotation\r\n */\r\nexport declare const Component: ComponentDecorator;\r\n/**\r\n * Type of the Pipe decorator / constructor function.\r\n */\r\nexport interface PipeDecorator {\r\n    /**\r\n     * Declares a reusable pipe function, and supplies configuration metadata.\r\n     *\r\n     */\r\n    (obj: Pipe): TypeDecorator;\r\n    /**\r\n     * See the `Pipe` decorator.\r\n     */\r\n    new (obj: Pipe): Pipe;\r\n}\r\n/**\r\n * Type of the Pipe metadata.\r\n */\r\nexport interface Pipe {\r\n    /**\r\n     * The pipe name to use in template bindings.\r\n     *\r\n     */\r\n    name: string;\r\n    /**\r\n     * When true, the pipe is pure, meaning that the\r\n     * `transform()` method is invoked only when its input arguments\r\n     * change. Pipes are pure by default.\r\n     *\r\n     * If the pipe has internal state (that is, the result\r\n     * depends on state other than its arguments), set `pure` to false.\r\n     * In this case, the pipe is invoked on each change-detection cycle,\r\n     * even if the arguments have not changed.\r\n     */\r\n    pure?: boolean;\r\n}\r\n/**\r\n *\r\n *\r\n * @Annotation\r\n */\r\nexport declare const Pipe: PipeDecorator;\r\n/**\r\n *\r\n */\r\nexport interface InputDecorator {\r\n    /**\r\n     * Decorator that marks a class as pipe and supplies configuration metadata.\r\n     *\r\n     * A pipe class must implement the `PipeTransform` interface.\r\n     * For example, if the name is \"myPipe\", use a template binding expression\r\n     * such as the following:\r\n     *\r\n     * ```\r\n     * {{ exp | myPipe }}\r\n     * ```\r\n     *\r\n     * The result of the expression is passed to the pipe's `transform()` method.\r\n     *\r\n     * A pipe must belong to an NgModule in order for it to be available\r\n     * to a template. To make it a member of an NgModule,\r\n     * list it in the `declarations` field of the `@NgModule` metadata.\r\n     *\r\n     */\r\n    (bindingPropertyName?: string): any;\r\n    new (bindingPropertyName?: string): any;\r\n}\r\n/**\r\n * Type of metadata for an `Input` property.\r\n *\r\n *\r\n */\r\nexport interface Input {\r\n    /**\r\n     * Decorator that marks a class field as an input property and supplies configuration metadata.\r\n     * Declares a data-bound input property, which Angular automatically updates\r\n     * during change detection.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * You can supply an optional name to use in templates when the\r\n     * component is instantiated, that maps to the\r\n     * name of the bound property. By default, the original\r\n     * name of the bound property is used for input binding.\r\n     *\r\n     * The following example creates a component with two input properties,\r\n     * one of which is given a special binding name.\r\n     *\r\n     * ```typescript\r\n     * @Component({\r\n     *   selector: 'bank-account',\r\n     *   template: `\r\n     *     Bank Name: {{bankName}}\r\n     *     Account Id: {{id}}\r\n     *   `\r\n     * })\r\n     * class BankAccount {\r\n     *   // This property is bound using its original name.\r\n     *   @Input() bankName: string;\r\n     *   // this property value is bound to a different property name\r\n     *   // when this component is instantiated in a template.\r\n     *   @Input('account-id') id: string;\r\n     *\r\n     *   // this property is not bound, and is not automatically updated by Angular\r\n     *   normalizedBankName: string;\r\n     * }\r\n     *\r\n     * @Component({\r\n     *   selector: 'app',\r\n     *   template: `\r\n     *     <bank-account bankName=\"RBC\" account-id=\"4747\"></bank-account>\r\n     *   `\r\n     * })\r\n     *\r\n     * class App {}\r\n     * ```\r\n     */\r\n    bindingPropertyName?: string;\r\n}\r\n/**\r\n *\r\n * @Annotation\r\n */\r\nexport declare const Input: InputDecorator;\r\n/**\r\n * Type of the Output decorator / constructor function.\r\n */\r\nexport interface OutputDecorator {\r\n    /**\r\n    * Decorator that marks a class field as an output property and supplies configuration metadata.\r\n    * Declares a data-bound output property, which Angular automatically updates\r\n    * during change detection.\r\n    *\r\n    * @usageNotes\r\n    *\r\n    * You can supply an optional name to use in templates when the\r\n    * component is instantiated, that maps to the\r\n    * name of the bound property. By default, the original\r\n    * name of the bound property is used for output binding.\r\n    *\r\n    * See `@Input` decorator for an example of providing a binding name.\r\n    *\r\n    */\r\n    (bindingPropertyName?: string): any;\r\n    new (bindingPropertyName?: string): any;\r\n}\r\n/**\r\n * Type of the Output metadata.\r\n */\r\nexport interface Output {\r\n    bindingPropertyName?: string;\r\n}\r\n/**\r\n *\r\n * @Annotation\r\n */\r\nexport declare const Output: OutputDecorator;\r\n/**\r\n * Type of the HostBinding decorator / constructor function.\r\n */\r\nexport interface HostBindingDecorator {\r\n    /**\r\n     * Decorator that marks a DOM property as a host-binding property and supplies configuration\r\n     * metadata.\r\n     * Angular automatically checks host property bindings during change detection, and\r\n     * if a binding changes it updates the host element of the directive.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * The following example creates a directive that sets the `valid` and `invalid`\r\n     * properties on the DOM element that has an `ngModel` directive on it.\r\n     *\r\n     * ```typescript\r\n     * @Directive({selector: '[ngModel]'})\r\n     * class NgModelStatus {\r\n     *   constructor(public control: NgModel) {}\r\n     *   @HostBinding('class.valid') get valid() { return this.control.valid; }\r\n     *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }\r\n     * }\r\n     *\r\n     * @Component({\r\n     *   selector: 'app',\r\n     *   template: `<input [(ngModel)]=\"prop\">`,\r\n     * })\r\n     * class App {\r\n     *   prop;\r\n     * }\r\n     * ```\r\n     */\r\n    (hostPropertyName?: string): any;\r\n    new (hostPropertyName?: string): any;\r\n}\r\n/**\r\n * Type of the HostBinding metadata.\r\n *\r\n */\r\nexport interface HostBinding {\r\n    hostPropertyName?: string;\r\n}\r\n/**\r\n *\r\n * @Annotation\r\n */\r\nexport declare const HostBinding: HostBindingDecorator;\r\n/**\r\n * Type of the HostListener decorator / constructor function.\r\n */\r\nexport interface HostListenerDecorator {\r\n    (eventName: string, args?: string[]): any;\r\n    new (eventName: string, args?: string[]): any;\r\n}\r\n/**\r\n * Type of the HostListener metadata.\r\n */\r\nexport interface HostListener {\r\n    /**\r\n     * The CSS event to listen for.\r\n     */\r\n    eventName?: string;\r\n    /**\r\n     * A set of arguments to pass to the handler method when the event occurs.\r\n     */\r\n    args?: string[];\r\n}\r\n/**\r\n * Binds a CSS event to a host listener and supplies configuration metadata.\r\n * Angular invokes the supplied handler method when the host element emits the specified event,\r\n * and updates the bound element with the result.\r\n * If the handler method returns false, applies `preventDefault` on the bound element.\r\n *\r\n * @usageNotes\r\n *\r\n * The following example declares a directive\r\n * that attaches a click listener to a button and counts clicks.\r\n *\r\n * ```\r\n * @Directive({selector: 'button[counting]'})\r\n * class CountClicks {\r\n *   numberOfClicks = 0;\r\n *\r\n *   @HostListener('click', ['$event.target'])\r\n *   onClick(btn) {\r\n *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);\r\n *  }\r\n * }\r\n *\r\n * @Component({\r\n *   selector: 'app',\r\n *   template: '<button counting>Increment</button>',\r\n * })\r\n * class App {}\r\n * ```\r\n *\r\n * @Annotation\r\n */\r\nexport declare const HostListener: HostListenerDecorator;\r\n",
  "/node_modules/@angular/core/src/metadata/lifecycle_hooks.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { SimpleChange } from '../change_detection/change_detection_util';\r\n/**\r\n * Defines an object that associates properties with\r\n * instances of `SimpleChange`.\r\n *\r\n * @see `OnChanges`\r\n *\r\n */\r\nexport interface SimpleChanges {\r\n    [propName: string]: SimpleChange;\r\n}\r\n/**\r\n * @description\r\n * A lifecycle hook that is called when any data-bound property of a directive changes.\r\n * Define an `ngOnChanges()` method to handle the changes.\r\n *\r\n * @see `DoCheck`\r\n * @see `OnInit`\r\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\r\n *\r\n * @usageNotes\r\n * The following snippet shows how a component can implement this interface to\r\n * define an on-changes handler for an input property.\r\n *\r\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}\r\n *\r\n */\r\nexport interface OnChanges {\r\n    /**\r\n     * A callback method that is invoked immediately after the\r\n     * default change detector has checked data-bound properties\r\n     * if at least one has changed, and before the view and content\r\n     * children are checked.\r\n     * @param changes The changed properties.\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n}\r\n/**\r\n * @description\r\n * A lifecycle hook that is called after Angular has initialized\r\n * all data-bound properties of a directive.\r\n * Define an `ngOnInit()` method to handle any additional initialization tasks.\r\n *\r\n * @see `AfterContentInit`\r\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\r\n *\r\n * @usageNotes\r\n * The following snippet shows how a component can implement this interface to\r\n * define its own initialization method.\r\n *\r\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}\r\n *\r\n *\r\n */\r\nexport interface OnInit {\r\n    /**\r\n     * A callback method that is invoked immediately after the\r\n     * default change detector has checked the directive's\r\n     * data-bound properties for the first time,\r\n     * and before any of the view or content children have been checked.\r\n     * It is invoked only once when the directive is instantiated.\r\n     */\r\n    ngOnInit(): void;\r\n}\r\n/**\r\n * A lifecycle hook that invokes a custom change-detection function for a directive,\r\n * in addition to the check performed by the default change-detector.\r\n *\r\n * The default change-detection algorithm looks for differences by comparing\r\n * bound-property values by reference across change detection runs. You can use this\r\n * hook to check for and respond to changes by some other means.\r\n *\r\n * When the default change detector detects changes, it invokes `ngOnChanges()` if supplied,\r\n * regardless of whether you perform additional change detection.\r\n * Typically, you should not use both `DoCheck` and `OnChanges` to respond to\r\n * changes on the same input.\r\n *\r\n * @see `OnChanges`\r\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\r\n *\r\n * @usageNotes\r\n * The following snippet shows how a component can implement this interface\r\n * to invoke it own change-detection cycle.\r\n *\r\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}\r\n *\r\n */\r\nexport interface DoCheck {\r\n    /**\r\n       * A callback method that performs change-detection, invoked\r\n       * after the default change-detector runs.\r\n       * See `KeyValueDiffers` and `IterableDiffers` for implementing\r\n       * custom change checking for collections.\r\n       *\r\n       */\r\n    ngDoCheck(): void;\r\n}\r\n/**\r\n * A lifecycle hook that is called when a directive, pipe, or service is destroyed.\r\n * Use for any custom cleanup that needs to occur when the\r\n * instance is destroyed.\r\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\r\n *\r\n * @usageNotes\r\n * The following snippet shows how a component can implement this interface\r\n * to define its own custom clean-up method.\r\n *\r\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}\r\n *\r\n */\r\nexport interface OnDestroy {\r\n    /**\r\n     * A callback method that performs custom clean-up, invoked immediately\r\n     * after a directive, pipe, or service instance is destroyed.\r\n     */\r\n    ngOnDestroy(): void;\r\n}\r\n/**\r\n * @description\r\n * A lifecycle hook that is called after Angular has fully initialized\r\n * all content of a directive.\r\n * Define an `ngAfterContentInit()` method to handle any additional initialization tasks.\r\n *\r\n * @see `OnInit`\r\n * @see `AfterViewInit`\r\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\r\n *\r\n * @usageNotes\r\n * The following snippet shows how a component can implement this interface to\r\n * define its own content initialization method.\r\n *\r\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}\r\n *\r\n *\r\n */\r\nexport interface AfterContentInit {\r\n    /**\r\n     * A callback method that is invoked immediately after\r\n     * Angular has completed initialization of all of the directive's\r\n     * content.\r\n     * It is invoked only once when the directive is instantiated.\r\n     */\r\n    ngAfterContentInit(): void;\r\n}\r\n/**\r\n * @description\r\n * A lifecycle hook that is called after the default change detector has\r\n * completed checking all content of a directive.\r\n *\r\n * @see `AfterViewChecked`\r\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\r\n *\r\n * @usageNotes\r\n * The following snippet shows how a component can implement this interface to\r\n * define its own after-check functionality.\r\n *\r\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}\r\n *\r\n *\r\n */\r\nexport interface AfterContentChecked {\r\n    /**\r\n     * A callback method that is invoked immediately after the\r\n     * default change detector has completed checking all of the directive's\r\n     * content.\r\n     */\r\n    ngAfterContentChecked(): void;\r\n}\r\n/**\r\n * @description\r\n * A lifecycle hook that is called after Angular has fully initialized\r\n * a component's view.\r\n * Define an `ngAfterViewInit()` method to handle any additional initialization tasks.\r\n *\r\n * @see `OnInit`\r\n * @see `AfterContentInit`\r\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\r\n *\r\n * @usageNotes\r\n * The following snippet shows how a component can implement this interface to\r\n * define its own view initialization method.\r\n *\r\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}\r\n *\r\n *\r\n */\r\nexport interface AfterViewInit {\r\n    /**\r\n     * A callback method that is invoked immediately after\r\n     * Angular has completed initialization of a component's view.\r\n     * It is invoked only once when the view is instantiated.\r\n     *\r\n     */\r\n    ngAfterViewInit(): void;\r\n}\r\n/**\r\n * @description\r\n * A lifecycle hook that is called after the default change detector has\r\n * completed checking a component's view for changes.\r\n *\r\n * @see `AfterContentChecked`\r\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\r\n *\r\n * @usageNotes\r\n * The following snippet shows how a component can implement this interface to\r\n * define its own after-check functionality.\r\n *\r\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}\r\n *\r\n */\r\nexport interface AfterViewChecked {\r\n    /**\r\n     * A callback method that is invoked immediately after the\r\n     * default change detector has completed one change-check cycle\r\n     * for a component's view.\r\n     */\r\n    ngAfterViewChecked(): void;\r\n}\r\n",
  "/node_modules/@angular/core/src/metadata/ng_module.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ApplicationRef } from '../application_ref';\r\nimport { Provider } from '../di/provider';\r\nimport { Type } from '../type';\r\nimport { TypeDecorator } from '../util/decorators';\r\n/**\r\n * Represents the expansion of an `NgModule` into its scopes.\r\n *\r\n * A scope is a set of directives and pipes that are visible in a particular context. Each\r\n * `NgModule` has two scopes. The `compilation` scope is the set of directives and pipes that will\r\n * be recognized in the templates of components declared by the module. The `exported` scope is the\r\n * set of directives and pipes exported by a module (that is, module B's exported scope gets added\r\n * to module A's compilation scope when module A imports B).\r\n */\r\nexport interface NgModuleTransitiveScopes {\r\n    compilation: {\r\n        directives: Set<any>;\r\n        pipes: Set<any>;\r\n    };\r\n    exported: {\r\n        directives: Set<any>;\r\n        pipes: Set<any>;\r\n    };\r\n}\r\n/**\r\n * A version of {@link NgModuleDef} that represents the runtime type shape only, and excludes\r\n * metadata parameters.\r\n */\r\nexport declare type NgModuleDefInternal<T> = NgModuleDef<T, any, any, any>;\r\n/**\r\n * Runtime link information for NgModules.\r\n *\r\n * This is the internal data structure used by the runtime to assemble components, directives,\r\n * pipes, and injectors.\r\n *\r\n * NOTE: Always use `defineNgModule` function to create this object,\r\n * never create the object directly since the shape of this object\r\n * can change between versions.\r\n */\r\nexport interface NgModuleDef<T, Declarations, Imports, Exports> {\r\n    /** Token representing the module. Used by DI. */\r\n    type: T;\r\n    /** List of components to bootstrap. */\r\n    bootstrap: Type<any>[];\r\n    /** List of components, directives, and pipes declared by this module. */\r\n    declarations: Type<any>[];\r\n    /** List of modules or `ModuleWithProviders` imported by this module. */\r\n    imports: Type<any>[];\r\n    /**\r\n     * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\r\n     * module.\r\n     */\r\n    exports: Type<any>[];\r\n    /**\r\n     * Cached value of computed `transitiveCompileScopes` for this module.\r\n     *\r\n     * This should never be read directly, but accessed via `transitiveScopesFor`.\r\n     */\r\n    transitiveCompileScopes: NgModuleTransitiveScopes | null;\r\n}\r\n/**\r\n * A wrapper around an NgModule that associates it with the providers.\r\n *\r\n * @param T the module type. In Ivy applications, this must be explicitly\r\n * provided.\r\n */\r\nexport interface ModuleWithProviders<T = any> {\r\n    ngModule: Type<T>;\r\n    providers?: Provider[];\r\n}\r\n/**\r\n * A schema definition associated with an NgModule.\r\n *\r\n * @see `@NgModule`, `CUSTOM_ELEMENTS_SCHEMA`, `NO_ERRORS_SCHEMA`\r\n *\r\n * @param name The name of a defined schema.\r\n *\r\n * @experimental\r\n */\r\nexport interface SchemaMetadata {\r\n    name: string;\r\n}\r\n/**\r\n * Defines a schema that allows an NgModule to contain the following:\r\n * - Non-Angular elements named with dash case (`-`).\r\n * - Element properties named with dash case (`-`).\r\n * Dash case is the naming convention for custom elements.\r\n *\r\n *\r\n */\r\nexport declare const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata;\r\n/**\r\n * Defines a schema that allows any property on any element.\r\n *\r\n * @experimental\r\n */\r\nexport declare const NO_ERRORS_SCHEMA: SchemaMetadata;\r\n/**\r\n * Type of the NgModule decorator / constructor function.\r\n *\r\n *\r\n */\r\nexport interface NgModuleDecorator {\r\n    /**\r\n     * Marks a class as an NgModule and supplies configuration metadata.\r\n     */\r\n    (obj?: NgModule): TypeDecorator;\r\n    new (obj?: NgModule): NgModule;\r\n}\r\n/**\r\n * Type of the NgModule metadata.\r\n *\r\n *\r\n */\r\nexport interface NgModule {\r\n    /**\r\n     * The set of injectable objects that are available in the injector\r\n     * of this module.\r\n     *\r\n     * @see [Dependency Injection guide](guide/dependency-injection)\r\n     * @see [NgModule guide](guide/providers)\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * Dependencies whose providers are listed here become available for injection\r\n     * into any component, directive, pipe or service that is a child of this injector.\r\n     * The NgModule used for bootstrapping uses the root injector, and can provide dependencies\r\n     * to any part of the app.\r\n     *\r\n     * A lazy-loaded module has its own injector, typically a child of the app root injector.\r\n     * Lazy-loaded services are scoped to the lazy-loaded module's injector.\r\n     * If a lazy-loaded module also provides the `UserService`, any component created\r\n     * within that module's context (such as by router navigation) gets the local instance\r\n     * of the service, not the instance in the root injector.\r\n     * Components in external modules continue to receive the instance provided by their injectors.\r\n     *\r\n     * ### Example\r\n     *\r\n     * The following example defines a class that is injected in\r\n     * the HelloWorld NgModule:\r\n     *\r\n     * ```\r\n     * class Greeter {\r\n     *    greet(name:string) {\r\n     *      return 'Hello ' + name + '!';\r\n     *    }\r\n     * }\r\n     *\r\n     * @NgModule({\r\n     *   providers: [\r\n     *     Greeter\r\n     *   ]\r\n     * })\r\n     * class HelloWorld {\r\n     *   greeter:Greeter;\r\n     *\r\n     *   constructor(greeter:Greeter) {\r\n     *     this.greeter = greeter;\r\n     *   }\r\n     * }\r\n     * ```\r\n     */\r\n    providers?: Provider[];\r\n    /**\r\n     * The set of components, directives, and pipes ([declarables](guide/glossary#declarable))\r\n     * that belong to this module.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * The set of selectors that are available to a template include those declared here, and\r\n     * those that are exported from imported NgModules.\r\n     *\r\n     * Declarables must belong to exactly one module.\r\n     * The compiler emits an error if you try to declare the same class in more than one module.\r\n     * Be careful not to declare a class that is imported from another module.\r\n     *\r\n     * ### Example\r\n     *\r\n     * The following example allows the CommonModule to use the `NgFor`\r\n     * directive.\r\n     *\r\n     * ```javascript\r\n     * @NgModule({\r\n     *   declarations: [NgFor]\r\n     * })\r\n     * class CommonModule {\r\n     * }\r\n     * ```\r\n     */\r\n    declarations?: Array<Type<any> | any[]>;\r\n    /**\r\n     * The set of NgModules whose exported [declarables](guide/glossary#declarable)\r\n     * are available to templates in this module.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * A template can use exported declarables from any\r\n     * imported module, including those from modules that are imported indirectly\r\n     * and re-exported.\r\n     * For example, `ModuleA` imports `ModuleB`, and also exports\r\n     * it, which makes the declarables from `ModuleB` available\r\n     * wherever `ModuleA` is imported.\r\n     *\r\n     * ### Example\r\n     *\r\n     * The following example allows MainModule to use anthing exported by\r\n     * `CommonModule`:\r\n     *\r\n     * ```javascript\r\n     * @NgModule({\r\n     *   imports: [CommonModule]\r\n     * })\r\n     * class MainModule {\r\n     * }\r\n     * ```\r\n     *\r\n     */\r\n    imports?: Array<Type<any> | ModuleWithProviders | any[]>;\r\n    /**\r\n     * The set of components, directives, and pipes declared in this\r\n     * NgModule that can be used in the template of any component that is part of an\r\n     * NgModule that imports this NgModule. Exported declarations are the module's public API.\r\n     *\r\n     * A declarable belongs to one and only one NgModule.\r\n     * A module can list another module among its exports, in which case all of that module's\r\n     * public declaration are exported.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * Declarations are private by default.\r\n     * If this ModuleA does not export UserComponent, then only the components within this\r\n     * ModuleA can use UserComponent.\r\n     *\r\n     * ModuleA can import ModuleB and also export it, making exports from ModuleB\r\n     * available to an NgModule that imports ModuleA.\r\n     *\r\n     * ### Example\r\n     *\r\n     * The following example exports the `NgFor` directive from CommonModule.\r\n     *\r\n     * ```javascript\r\n     * @NgModule({\r\n     *   exports: [NgFor]\r\n     * })\r\n     * class CommonModule {\r\n     * }\r\n     * ```\r\n     */\r\n    exports?: Array<Type<any> | any[]>;\r\n    /**\r\n     * The set of components to compile when this NgModule is defined,\r\n     * so that they can be dynamically loaded into the view.\r\n     *\r\n     * For each component listed here, Angular creates a `ComponentFactory`\r\n     * and stores it in the `ComponentFactoryResolver`.\r\n     *\r\n     * Angular automatically adds components in the module's bootstrap\r\n     * and route definitions into the `entryComponents` list. Use this\r\n     * option to add components that are bootstrapped\r\n     * using one of the imperative techniques, such as `ViewContainerRef.createComponent()`.\r\n     *\r\n     * @see [Entry Components](guide/entry-components)\r\n     */\r\n    entryComponents?: Array<Type<any> | any[]>;\r\n    /**\r\n     * The set of components that are bootstrapped when\r\n     * this module is bootstrapped. The components listed here\r\n     * are automatically added to `entryComponents`.\r\n     */\r\n    bootstrap?: Array<Type<any> | any[]>;\r\n    /**\r\n     * The set of schemas that declare elements to be allowed in the NgModule.\r\n     * Elements and properties that are neither Angular components nor directives\r\n     * must be declared in a schema.\r\n     *\r\n     * Allowed value are `NO_ERRORS_SCHEMA` and `CUSTOM_ELEMENTS_SCHEMA`.\r\n     *\r\n     * @security When using one of `NO_ERRORS_SCHEMA` or `CUSTOM_ELEMENTS_SCHEMA`\r\n     * you must ensure that allowed elements and properties securely escape inputs.\r\n     */\r\n    schemas?: Array<SchemaMetadata | any[]>;\r\n    /**\r\n     * A name or path that uniquely identifies this NgModule in `getModuleFactory`.\r\n     * If left `undefined`, the NgModule is not registered with\r\n     * `getModuleFactory`.\r\n     */\r\n    id?: string;\r\n    /**\r\n     * If true, this module will be skipped by the AOT compiler and so will always be compiled\r\n     * using JIT.\r\n     *\r\n     * This exists to support future Ivy work and has no effect currently.\r\n     */\r\n    jit?: true;\r\n}\r\n/**\r\n * @Annotation\r\n */\r\nexport declare const NgModule: NgModuleDecorator;\r\n/**\r\n * @description\r\n * Hook for manual bootstrapping of the application instead of using bootstrap array in @NgModule\r\n * annotation.\r\n *\r\n * Reference to the current application is provided as a parameter.\r\n *\r\n * See [\"Bootstrapping\"](guide/bootstrapping) and [\"Entry components\"](guide/entry-components).\r\n *\r\n * @usageNotes\r\n * ```typescript\r\n * class AppModule implements DoBootstrap {\r\n *   ngDoBootstrap(appRef: ApplicationRef) {\r\n *     appRef.bootstrap(AppComponent); // Or some other component\r\n *   }\r\n * }\r\n * ```\r\n *\r\n */\r\nexport interface DoBootstrap {\r\n    ngDoBootstrap(appRef: ApplicationRef): void;\r\n}\r\n",
  "/node_modules/@angular/core/src/metadata/resource_loading.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Component } from './directives';\r\n/**\r\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\r\n *\r\n * Example:\r\n * ```\r\n * @Component({\r\n *   selector: 'my-comp',\r\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\r\n * })\r\n * class MyComponnent{\r\n * }\r\n *\r\n * // Calling `renderComponent` will fail because `MyComponent`'s `@Compenent.templateUrl`\r\n * // needs to be resolved because `renderComponent` is synchronous process.\r\n * // renderComponent(MyComponent);\r\n *\r\n * // Calling `resolveComponentResources` will resolve `@Compenent.templateUrl` into\r\n * // `@Compenent.template`, which would allow `renderComponent` to proceed in synchronous manner.\r\n * // Use browser's `fetch` function as the default resource resolution strategy.\r\n * resolveComponentResources(fetch).then(() => {\r\n *   // After resolution all URLs have been converted into strings.\r\n *   renderComponent(MyComponent);\r\n * });\r\n *\r\n * ```\r\n *\r\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\r\n * to call this method outside JIT mode.\r\n *\r\n * @param resourceResolver a function which is responsible to returning a `Promise` of the resolved\r\n * URL. Browser's `fetch` method is a good default implementation.\r\n */\r\nexport declare function resolveComponentResources(resourceResolver: (url: string) => (Promise<string | {\r\n    text(): Promise<string>;\r\n}>)): Promise<null>;\r\nexport declare function maybeQueueResolutionOfComponentResources(metadata: Component): void;\r\nexport declare function componentNeedsResolution(component: Component): string | number;\r\nexport declare function clearResolutionOfComponentResourcesQueue(): void;\r\n",
  "/node_modules/@angular/core/src/metadata/view.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Defines template and style encapsulation options available for Component's {@link Component}.\r\n *\r\n * See {@link Component#encapsulation encapsulation}.\r\n *\r\n */\r\nexport declare enum ViewEncapsulation {\r\n    /**\r\n     * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host\r\n     * Element and pre-processing the style rules provided via {@link Component#styles styles} or\r\n     * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all\r\n     * selectors.\r\n     *\r\n     * This is the default option.\r\n     */\r\n    Emulated = 0,\r\n    /**\r\n     * @deprecated v6.1.0 - use {ViewEncapsulation.ShadowDom} instead.\r\n     * Use the native encapsulation mechanism of the renderer.\r\n     *\r\n     * For the DOM this means using the deprecated [Shadow DOM\r\n     * v0](https://w3c.github.io/webcomponents/spec/shadow/) and\r\n     * creating a ShadowRoot for Component's Host Element.\r\n     */\r\n    Native = 1,\r\n    /**\r\n     * Don't provide any template or style encapsulation.\r\n     */\r\n    None = 2,\r\n    /**\r\n     * Use Shadow DOM to encapsulate styles.\r\n     *\r\n     * For the DOM this means using modern [Shadow\r\n     * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\r\n     * creating a ShadowRoot for Component's Host Element.\r\n     *\r\n     * ### Example\r\n     * {@example core/ts/metadata/encapsulation.ts region='longform'}\r\n     */\r\n    ShadowDom = 3\r\n}\r\n",
  "/node_modules/@angular/core/src/metadata.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { ANALYZE_FOR_ENTRY_COMPONENTS, Attribute, ContentChild, ContentChildDecorator, ContentChildren, ContentChildrenDecorator, Query, ViewChild, ViewChildDecorator, ViewChildren, ViewChildrenDecorator } from './metadata/di';\r\nexport { Component, ComponentDecorator, Directive, DirectiveDecorator, HostBinding, HostListener, Input, Output, Pipe } from './metadata/directives';\r\nexport { AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, DoCheck, OnChanges, OnDestroy, OnInit } from './metadata/lifecycle_hooks';\r\nexport { CUSTOM_ELEMENTS_SCHEMA, DoBootstrap, ModuleWithProviders, NO_ERRORS_SCHEMA, NgModule, SchemaMetadata } from './metadata/ng_module';\r\nexport { ViewEncapsulation } from './metadata/view';\r\n",
  "/node_modules/@angular/core/src/platform_core_providers.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { PlatformRef } from './application_ref';\r\nimport { StaticProvider } from './di';\r\n/**\r\n * This platform has to be included in any other platform\r\n *\r\n * @experimental\r\n */\r\nexport declare const platformCore: (extraProviders?: StaticProvider[]) => PlatformRef;\r\n",
  "/node_modules/@angular/core/src/profile/profile.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { WtfScopeFn } from './wtf_impl';\r\nexport { WtfScopeFn } from './wtf_impl';\r\n/**\r\n * True if WTF is enabled.\r\n */\r\nexport declare const wtfEnabled: boolean;\r\n/**\r\n * Create trace scope.\r\n *\r\n * Scopes must be strictly nested and are analogous to stack frames, but\r\n * do not have to follow the stack frames. Instead it is recommended that they follow logical\r\n * nesting. You may want to use\r\n * [Event\r\n * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)\r\n * as they are defined in WTF.\r\n *\r\n * Used to mark scope entry. The return value is used to leave the scope.\r\n *\r\n *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');\r\n *\r\n *     someMethod() {\r\n *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI\r\n *        // DO SOME WORK HERE\r\n *        return wtfLeave(s, 123); // Return value 123\r\n *     }\r\n *\r\n * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can\r\n * negatively impact the performance of your application. For this reason we recommend that\r\n * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and\r\n * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to\r\n * exception, will produce incorrect trace, but presence of exception signifies logic error which\r\n * needs to be fixed before the app should be profiled. Add try-finally only when you expect that\r\n * an exception is expected during normal execution while profiling.\r\n *\r\n * @experimental\r\n */\r\nexport declare const wtfCreateScope: (signature: string, flags?: any) => WtfScopeFn;\r\n/**\r\n * Used to mark end of Scope.\r\n *\r\n * - `scope` to end.\r\n * - `returnValue` (optional) to be passed to the WTF.\r\n *\r\n * Returns the `returnValue for easy chaining.\r\n * @experimental\r\n */\r\nexport declare const wtfLeave: <T>(scope: any, returnValue?: T) => T;\r\n/**\r\n * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.\r\n * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been\r\n * enabled.\r\n *\r\n *     someMethod() {\r\n *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');\r\n *        var future = new Future.delay(5).then((_) {\r\n *          wtfEndTimeRange(s);\r\n *        });\r\n *     }\r\n * @experimental\r\n */\r\nexport declare const wtfStartTimeRange: (rangeType: string, action: string) => any;\r\n/**\r\n * Ends a async time range operation.\r\n * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been\r\n * enabled.\r\n * @experimental\r\n */\r\nexport declare const wtfEndTimeRange: (range: any) => void;\r\n",
  "/node_modules/@angular/core/src/profile/wtf_impl.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A scope function for the Web Tracing Framework (WTF).\r\n *\r\n * @experimental\r\n */\r\nexport interface WtfScopeFn {\r\n    (arg0?: any, arg1?: any): any;\r\n}\r\nexport interface Range {\r\n}\r\nexport interface Scope {\r\n    (...args: any[] /** TODO #9100 */): any;\r\n}\r\nexport declare function detectWTF(): boolean;\r\nexport declare function createScope(signature: string, flags?: any): any;\r\nexport declare function leave<T>(scope: Scope): void;\r\nexport declare function leave<T>(scope: Scope, returnValue?: T): T;\r\nexport declare function startTimeRange(rangeType: string, action: string): Range;\r\nexport declare function endTimeRange(range: Range): void;\r\n",
  "/node_modules/@angular/core/src/r3_symbols.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { InjectableDef as InjectableDef, InjectorDef as InjectorDef, defineInjectable, defineInjector } from './di/defs';\r\nexport { inject } from './di/injector';\r\nexport { NgModuleDef as NgModuleDef } from './metadata/ng_module';\r\nexport { defineNgModule as defineNgModule } from './render3/definition';\r\nexport { NgModuleFactory as NgModuleFactory } from './render3/ng_module_ref';\r\n/**\r\n * The existence of this constant (in this particular file) informs the Angular compiler that the\r\n * current program is actually @angular/core, which needs to be compiled specially.\r\n */\r\nexport declare const ITS_JUST_ANGULAR: boolean;\r\n",
  "/node_modules/@angular/core/src/reflection/platform_reflection_capabilities.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Type } from '../type';\r\nimport { GetterFn, MethodFn, SetterFn } from './types';\r\nexport interface PlatformReflectionCapabilities {\r\n    isReflectionEnabled(): boolean;\r\n    factory(type: Type<any>): Function;\r\n    hasLifecycleHook(type: any, lcProperty: string): boolean;\r\n    guards(type: any): {\r\n        [key: string]: any;\r\n    };\r\n    /**\r\n     * Return a list of annotations/types for constructor parameters\r\n     */\r\n    parameters(type: Type<any>): any[][];\r\n    /**\r\n     * Return a list of annotations declared on the class\r\n     */\r\n    annotations(type: Type<any>): any[];\r\n    /**\r\n     * Return a object literal which describes the annotations on Class fields/properties.\r\n     */\r\n    propMetadata(typeOrFunc: Type<any>): {\r\n        [key: string]: any[];\r\n    };\r\n    getter(name: string): GetterFn;\r\n    setter(name: string): SetterFn;\r\n    method(name: string): MethodFn;\r\n    importUri(type: Type<any>): string;\r\n    resourceUri(type: Type<any>): string;\r\n    resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any;\r\n    resolveEnum(enumIdentifier: any, name: string): any;\r\n}\r\n",
  "/node_modules/@angular/core/src/reflection/reflection.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Reflector } from './reflector';\r\nexport { Reflector } from './reflector';\r\n/**\r\n * The {@link Reflector} used internally in Angular to access metadata\r\n * about symbols.\r\n */\r\nexport declare const reflector: Reflector;\r\n",
  "/node_modules/@angular/core/src/reflection/reflection_capabilities.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Type } from '../type';\r\nimport { PlatformReflectionCapabilities } from './platform_reflection_capabilities';\r\nimport { GetterFn, MethodFn, SetterFn } from './types';\r\n/**\r\n * Attention: These regex has to hold even if the code is minified!\r\n */\r\nexport declare const DELEGATE_CTOR: RegExp;\r\nexport declare const INHERITED_CLASS: RegExp;\r\nexport declare const INHERITED_CLASS_WITH_CTOR: RegExp;\r\nexport declare class ReflectionCapabilities implements PlatformReflectionCapabilities {\r\n    private _reflect;\r\n    constructor(reflect?: any);\r\n    isReflectionEnabled(): boolean;\r\n    factory<T>(t: Type<T>): (args: any[]) => T;\r\n    /** @internal */\r\n    _zipTypesAndAnnotations(paramTypes: any[], paramAnnotations: any[]): any[][];\r\n    private _ownParameters;\r\n    parameters(type: Type<any>): any[][];\r\n    private _ownAnnotations;\r\n    annotations(typeOrFunc: Type<any>): any[];\r\n    private _ownPropMetadata;\r\n    propMetadata(typeOrFunc: any): {\r\n        [key: string]: any[];\r\n    };\r\n    hasLifecycleHook(type: any, lcProperty: string): boolean;\r\n    guards(type: any): {\r\n        [key: string]: any;\r\n    };\r\n    getter(name: string): GetterFn;\r\n    setter(name: string): SetterFn;\r\n    method(name: string): MethodFn;\r\n    importUri(type: any): string;\r\n    resourceUri(type: any): string;\r\n    resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any;\r\n    resolveEnum(enumIdentifier: any, name: string): any;\r\n}\r\n",
  "/node_modules/@angular/core/src/reflection/reflector.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Type } from '../type';\r\nimport { PlatformReflectionCapabilities } from './platform_reflection_capabilities';\r\nimport { GetterFn, MethodFn, SetterFn } from './types';\r\nexport { PlatformReflectionCapabilities };\r\nexport { GetterFn, MethodFn, SetterFn };\r\n/**\r\n * Provides access to reflection data about symbols. Used internally by Angular\r\n * to power dependency injection and compilation.\r\n */\r\nexport declare class Reflector {\r\n    reflectionCapabilities: PlatformReflectionCapabilities;\r\n    constructor(reflectionCapabilities: PlatformReflectionCapabilities);\r\n    updateCapabilities(caps: PlatformReflectionCapabilities): void;\r\n    factory(type: Type<any>): Function;\r\n    parameters(typeOrFunc: Type<any>): any[][];\r\n    annotations(typeOrFunc: Type<any>): any[];\r\n    propMetadata(typeOrFunc: Type<any>): {\r\n        [key: string]: any[];\r\n    };\r\n    hasLifecycleHook(type: any, lcProperty: string): boolean;\r\n    getter(name: string): GetterFn;\r\n    setter(name: string): SetterFn;\r\n    method(name: string): MethodFn;\r\n    importUri(type: any): string;\r\n    resourceUri(type: any): string;\r\n    resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any;\r\n    resolveEnum(identifier: any, name: string): any;\r\n}\r\n",
  "/node_modules/@angular/core/src/reflection/types.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare type SetterFn = (obj: any, value: any) => void;\r\nexport declare type GetterFn = (obj: any) => any;\r\nexport declare type MethodFn = (obj: any, args: any[]) => any;\r\n",
  "/node_modules/@angular/core/src/render/api.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { InjectionToken } from '../di/injection_token';\r\nimport { Injector } from '../di/injector';\r\nimport { ViewEncapsulation } from '../metadata/view';\r\n/**\r\n * @deprecated Use `RendererType2` (and `Renderer2`) instead.\r\n */\r\nexport declare class RenderComponentType {\r\n    id: string;\r\n    templateUrl: string;\r\n    slotCount: number;\r\n    encapsulation: ViewEncapsulation;\r\n    styles: Array<string | any[]>;\r\n    animations: any;\r\n    constructor(id: string, templateUrl: string, slotCount: number, encapsulation: ViewEncapsulation, styles: Array<string | any[]>, animations: any);\r\n}\r\n/**\r\n * @deprecated Debug info is handeled internally in the view engine now.\r\n */\r\nexport declare abstract class RenderDebugInfo {\r\n    abstract readonly injector: Injector;\r\n    abstract readonly component: any;\r\n    abstract readonly providerTokens: any[];\r\n    abstract readonly references: {\r\n        [key: string]: any;\r\n    };\r\n    abstract readonly context: any;\r\n    abstract readonly source: string;\r\n}\r\n/**\r\n * @deprecated Use the `Renderer2` instead.\r\n */\r\nexport interface DirectRenderer {\r\n    remove(node: any): void;\r\n    appendChild(node: any, parent: any): void;\r\n    insertBefore(node: any, refNode: any): void;\r\n    nextSibling(node: any): any;\r\n    parentElement(node: any): any;\r\n}\r\n/**\r\n * @deprecated Use the `Renderer2` instead.\r\n */\r\nexport declare abstract class Renderer {\r\n    abstract selectRootElement(selectorOrNode: string | any, debugInfo?: RenderDebugInfo): any;\r\n    abstract createElement(parentElement: any, name: string, debugInfo?: RenderDebugInfo): any;\r\n    abstract createViewRoot(hostElement: any): any;\r\n    abstract createTemplateAnchor(parentElement: any, debugInfo?: RenderDebugInfo): any;\r\n    abstract createText(parentElement: any, value: string, debugInfo?: RenderDebugInfo): any;\r\n    abstract projectNodes(parentElement: any, nodes: any[]): void;\r\n    abstract attachViewAfter(node: any, viewRootNodes: any[]): void;\r\n    abstract detachView(viewRootNodes: any[]): void;\r\n    abstract destroyView(hostElement: any, viewAllNodes: any[]): void;\r\n    abstract listen(renderElement: any, name: string, callback: Function): Function;\r\n    abstract listenGlobal(target: string, name: string, callback: Function): Function;\r\n    abstract setElementProperty(renderElement: any, propertyName: string, propertyValue: any): void;\r\n    abstract setElementAttribute(renderElement: any, attributeName: string, attributeValue: string): void;\r\n    /**\r\n     * Used only in debug mode to serialize property changes to dom nodes as attributes.\r\n     */\r\n    abstract setBindingDebugInfo(renderElement: any, propertyName: string, propertyValue: string): void;\r\n    abstract setElementClass(renderElement: any, className: string, isAdd: boolean): void;\r\n    abstract setElementStyle(renderElement: any, styleName: string, styleValue: string): void;\r\n    abstract invokeElementMethod(renderElement: any, methodName: string, args?: any[]): void;\r\n    abstract setText(renderNode: any, text: string): void;\r\n    abstract animate(element: any, startingStyles: any, keyframes: any[], duration: number, delay: number, easing: string, previousPlayers?: any[]): any;\r\n}\r\nexport declare const Renderer2Interceptor: InjectionToken<Renderer2[]>;\r\n/**\r\n * Injectable service that provides a low-level interface for modifying the UI.\r\n *\r\n * Use this service to bypass Angular's templating and make custom UI changes that can't be\r\n * expressed declaratively. For example if you need to set a property or an attribute whose name is\r\n * not statically known, use {@link Renderer#setElementProperty setElementProperty} or\r\n * {@link Renderer#setElementAttribute setElementAttribute} respectively.\r\n *\r\n * If you are implementing a custom renderer, you must implement this interface.\r\n *\r\n * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.\r\n *\r\n * @deprecated Use `RendererFactory2` instead.\r\n */\r\nexport declare abstract class RootRenderer {\r\n    abstract renderComponent(componentType: RenderComponentType): Renderer;\r\n}\r\n/**\r\n * Used by `RendererFactory2` to associate custom rendering data and styles\r\n * with a rendering implementation.\r\n *  @experimental\r\n */\r\nexport interface RendererType2 {\r\n    /**\r\n     * A unique identifying string for the new renderer, used when creating\r\n     * unique styles for encapsulation.\r\n     */\r\n    id: string;\r\n    /**\r\n     * The view encapsulation type, which determines how styles are applied to\r\n     * DOM elements. One of\r\n     * - `Emulated` (default): Emulate native scoping of styles.\r\n     * - `Native`: Use the native encapsulation mechanism of the renderer.\r\n     * - `ShadowDom`: Use modern [Shadow\r\n     * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\r\n     * create a ShadowRoot for component's host element.\r\n     * - `None`: Do not provide any template or style encapsulation.\r\n     */\r\n    encapsulation: ViewEncapsulation;\r\n    /**\r\n     * Defines CSS styles to be stored on a renderer instance.\r\n     */\r\n    styles: (string | any[])[];\r\n    /**\r\n     * Defines arbitrary developer-defined data to be stored on a renderer instance.\r\n     * This is useful for renderers that delegate to other renderers.\r\n     */\r\n    data: {\r\n        [kind: string]: any;\r\n    };\r\n}\r\n/**\r\n * Creates and initializes a custom renderer that implements the `Renderer2` base class.\r\n *\r\n * @experimental\r\n */\r\nexport declare abstract class RendererFactory2 {\r\n    /**\r\n     * Creates and initializes a custom renderer for a host DOM element.\r\n     * @param hostElement The element to render.\r\n     * @param type The base class to implement.\r\n     * @returns The new custom renderer instance.\r\n     */\r\n    abstract createRenderer(hostElement: any, type: RendererType2 | null): Renderer2;\r\n    /**\r\n     * A callback invoked when rendering has begun.\r\n     */\r\n    abstract begin?(): void;\r\n    /**\r\n     * A callback invoked when rendering has completed.\r\n     */\r\n    abstract end?(): void;\r\n    /**\r\n     * Use with animations test-only mode. Notifies the test when rendering has completed.\r\n     * @returns The asynchronous result of the developer-defined function.\r\n     */\r\n    abstract whenRenderingDone?(): Promise<any>;\r\n}\r\n/**\r\n * Flags for renderer-specific style modifiers.\r\n * @experimental\r\n */\r\nexport declare enum RendererStyleFlags2 {\r\n    /**\r\n     * Marks a style as important.\r\n     */\r\n    Important = 1,\r\n    /**\r\n     * Marks a style as using dash case naming (this-is-dash-case).\r\n     */\r\n    DashCase = 2\r\n}\r\n/**\r\n * Extend this base class to implement custom rendering. By default, Angular\r\n * renders a template into DOM. You can use custom rendering to intercept\r\n * rendering calls, or to render to something other than DOM.\r\n *\r\n * Create your custom renderer using `RendererFactory2`.\r\n *\r\n * Use a custom renderer to bypass Angular's templating and\r\n * make custom UI changes that can't be expressed declaratively.\r\n * For example if you need to set a property or an attribute whose name is\r\n * not statically known, use the `setProperty()` or\r\n * `setAttribute()` method.\r\n *\r\n * @experimental\r\n */\r\nexport declare abstract class Renderer2 {\r\n    /**\r\n     * Use to store arbitrary developer-defined data on a renderer instance,\r\n     * as an object containing key-value pairs.\r\n     * This is useful for renderers that delegate to other renderers.\r\n     */\r\n    abstract readonly data: {\r\n        [key: string]: any;\r\n    };\r\n    /**\r\n     * Implement this callback to destroy the renderer or the host element.\r\n     */\r\n    abstract destroy(): void;\r\n    /**\r\n     * Implement this callback to create an instance of the host element.\r\n     * @param name An identifying name for the new element, unique within the namespace.\r\n     * @param namespace The namespace for the new element.\r\n     * @returns The new element.\r\n     */\r\n    abstract createElement(name: string, namespace?: string | null): any;\r\n    /**\r\n     * Implement this callback to add a comment to the DOM of the host element.\r\n     * @param value The comment text.\r\n     * @returns The modified element.\r\n     */\r\n    abstract createComment(value: string): any;\r\n    /**\r\n     * Implement this callback to add text to the DOM of the host element.\r\n     * @param value The text string.\r\n     * @returns The modified element.\r\n     */\r\n    abstract createText(value: string): any;\r\n    /**\r\n     * If null or undefined, the view engine won't call it.\r\n     * This is used as a performance optimization for production mode.\r\n     */\r\n    destroyNode: ((node: any) => void) | null;\r\n    /**\r\n     * Appends a child to a given parent node in the host element DOM.\r\n     * @param parent The parent node.\r\n     * @param newChild The new child node.\r\n     */\r\n    abstract appendChild(parent: any, newChild: any): void;\r\n    /**\r\n     * Implement this callback to insert a child node at a given position in a parent node\r\n     * in the host element DOM.\r\n     * @param parent The parent node.\r\n     * @param newChild The new child nodes.\r\n     * @param refChild The existing child node that should precede the new node.\r\n     */\r\n    abstract insertBefore(parent: any, newChild: any, refChild: any): void;\r\n    /**\r\n     * Implement this callback to remove a child node from the host element's DOM.\r\n     * @param parent The parent node.\r\n     * @param oldChild The child node to remove.\r\n     */\r\n    abstract removeChild(parent: any, oldChild: any): void;\r\n    /**\r\n     * Implement this callback to prepare an element to be bootstrapped\r\n     * as a root element, and return the element instance.\r\n     * @param selectorOrNode The DOM element.\r\n     * @param preserveContent Whether the contents of the root element\r\n     * should be preserved, or cleared upon bootstrap (default behavior).\r\n     * Use with `ViewEncapsulation.ShadowDom` to allow simple native\r\n     * content projection via `<slot>` elements.\r\n     * @returns The root element.\r\n     */\r\n    abstract selectRootElement(selectorOrNode: string | any, preserveContent?: boolean): any;\r\n    /**\r\n     * Implement this callback to get the parent of a given node\r\n     * in the host element's DOM.\r\n     * @param node The child node to query.\r\n     * @returns The parent node, or null if there is no parent.\r\n     * For WebWorkers, always returns true.\r\n     * This is because the check is synchronous,\r\n     * and the caller can't rely on checking for null.\r\n     */\r\n    abstract parentNode(node: any): any;\r\n    /**\r\n     * Implement this callback to get the next sibling node of a given node\r\n     * in the host element's DOM.\r\n     * @returns The sibling node, or null if there is no sibling.\r\n     * For WebWorkers, always returns a value.\r\n     * This is because the check is synchronous,\r\n     * and the caller can't rely on checking for null.\r\n     */\r\n    abstract nextSibling(node: any): any;\r\n    /**\r\n     * Implement this callback to set an attribute value for an element in the DOM.\r\n     * @param el The element.\r\n     * @param name The attribute name.\r\n     * @param value The new value.\r\n     * @param namespace The namespace.\r\n     */\r\n    abstract setAttribute(el: any, name: string, value: string, namespace?: string | null): void;\r\n    /**\r\n     * Implement this callback to remove an attribute from an element in the DOM.\r\n     * @param el The element.\r\n     * @param name The attribute name.\r\n     * @param namespace The namespace.\r\n     */\r\n    abstract removeAttribute(el: any, name: string, namespace?: string | null): void;\r\n    /**\r\n     * Implement this callback to add a class to an element in the DOM.\r\n     * @param el The element.\r\n     * @param name The class name.\r\n     */\r\n    abstract addClass(el: any, name: string): void;\r\n    /**\r\n     * Implement this callback to remove a class from an element in the DOM.\r\n     * @param el The element.\r\n     * @param name The class name.\r\n     */\r\n    abstract removeClass(el: any, name: string): void;\r\n    /**\r\n     * Implement this callback to set a CSS style for an element in the DOM.\r\n     * @param el The element.\r\n     * @param style The name of the style.\r\n     * @param value The new value.\r\n     * @param flags Flags for style variations. No flags are set by default.\r\n     */\r\n    abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void;\r\n    /**\r\n     * Implement this callback to remove the value from a CSS style for an element in the DOM.\r\n     * @param el The element.\r\n     * @param style The name of the style.\r\n     * @param flags Flags for style variations to remove, if set. ???\r\n     */\r\n    abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;\r\n    /**\r\n     * Implement this callback to set the value of a property of an element in the DOM.\r\n     * @param el The element.\r\n     * @param name The property name.\r\n     * @param value The new value.\r\n     */\r\n    abstract setProperty(el: any, name: string, value: any): void;\r\n    /**\r\n     * Implement this callback to set the value of a node in the host element.\r\n     * @param node The node.\r\n     * @param value The new value.\r\n     */\r\n    abstract setValue(node: any, value: string): void;\r\n    /**\r\n     * Implement this callback to start an event listener.\r\n     * @param target The context in which to listen for events. Can be\r\n     * the entire window or document, the body of the document, or a specific\r\n     * DOM element.\r\n     * @param eventName The event to listen for.\r\n     * @param callback A handler function to invoke when the event occurs.\r\n     * @returns An \"unlisten\" function for disposing of this handler.\r\n     */\r\n    abstract listen(target: 'window' | 'document' | 'body' | any, eventName: string, callback: (event: any) => boolean | void): () => void;\r\n}\r\n",
  "/node_modules/@angular/core/src/render.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { RenderComponentType, Renderer, Renderer2, RendererFactory2, RendererStyleFlags2, RendererType2, RootRenderer } from './render/api';\r\n",
  "/node_modules/@angular/core/src/render3/assert.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare function assertNumber(actual: any, msg: string): void;\r\nexport declare function assertEqual<T>(actual: T, expected: T, msg: string): void;\r\nexport declare function assertNotEqual<T>(actual: T, expected: T, msg: string): void;\r\nexport declare function assertSame<T>(actual: T, expected: T, msg: string): void;\r\nexport declare function assertLessThan<T>(actual: T, expected: T, msg: string): void;\r\nexport declare function assertGreaterThan<T>(actual: T, expected: T, msg: string): void;\r\nexport declare function assertNotDefined<T>(actual: T, msg: string): void;\r\nexport declare function assertDefined<T>(actual: T, msg: string): void;\r\nexport declare function assertComponentType(actual: any, msg?: string): void;\r\nexport declare function assertNgModuleType(actual: any, msg?: string): void;\r\n",
  "/node_modules/@angular/core/src/render3/component.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Type } from '../core';\r\nimport { Injector } from '../di/injector';\r\nimport { Sanitizer } from '../sanitization/security';\r\nimport { ComponentDef, ComponentDefInternal, ComponentType } from './interfaces/definition';\r\nimport { LElementNode } from './interfaces/node';\r\nimport { RElement, RendererFactory3 } from './interfaces/renderer';\r\nimport { LViewData, RootContext } from './interfaces/view';\r\n/** Options that control how the component should be bootstrapped. */\r\nexport interface CreateComponentOptions {\r\n    /** Which renderer factory to use. */\r\n    rendererFactory?: RendererFactory3;\r\n    /** A custom sanitizer instance */\r\n    sanitizer?: Sanitizer;\r\n    /**\r\n     * Host element on which the component will be bootstrapped. If not specified,\r\n     * the component definition's `tag` is used to query the existing DOM for the\r\n     * element to bootstrap.\r\n     */\r\n    host?: RElement | string;\r\n    /** Module injector for the component. If unspecified, the injector will be NULL_INJECTOR. */\r\n    injector?: Injector;\r\n    /**\r\n     * List of features to be applied to the created component. Features are simply\r\n     * functions that decorate a component with a certain behavior.\r\n     *\r\n     * Typically, the features in this list are features that cannot be added to the\r\n     * other features list in the component definition because they rely on other factors.\r\n     *\r\n     * Example: `RootLifecycleHooks` is a function that adds lifecycle hook capabilities\r\n     * to root components in a tree-shakable way. It cannot be added to the component\r\n     * features list because there's no way of knowing when the component will be used as\r\n     * a root component.\r\n     */\r\n    hostFeatures?: HostFeature[];\r\n    /**\r\n     * A function which is used to schedule change detection work in the future.\r\n     *\r\n     * When marking components as dirty, it is necessary to schedule the work of\r\n     * change detection in the future. This is done to coalesce multiple\r\n     * {@link markDirty} calls into a single changed detection processing.\r\n     *\r\n     * The default value of the scheduler is the `requestAnimationFrame` function.\r\n     *\r\n     * It is also useful to override this function for testing purposes.\r\n     */\r\n    scheduler?: (work: () => void) => void;\r\n}\r\n/** See CreateComponentOptions.hostFeatures */\r\ndeclare type HostFeature = (<T>(component: T, componentDef: ComponentDef<T, string>) => void);\r\nexport declare const NULL_INJECTOR: Injector;\r\n/**\r\n * Bootstraps a Component into an existing host element and returns an instance\r\n * of the component.\r\n *\r\n * Use this function to bootstrap a component into the DOM tree. Each invocation\r\n * of this function will create a separate tree of components, injectors and\r\n * change detection cycles and lifetimes. To dynamically insert a new component\r\n * into an existing tree such that it shares the same injection, change detection\r\n * and object lifetime, use {@link ViewContainer#createComponent}.\r\n *\r\n * @param componentType Component to bootstrap\r\n * @param options Optional parameters which control bootstrapping\r\n */\r\nexport declare function renderComponent<T>(componentType: ComponentType<T> | Type<T>, opts?: CreateComponentOptions): T;\r\n/**\r\n * Creates a root component and sets it up with features and host bindings. Shared by\r\n * renderComponent() and ViewContainerRef.createComponent().\r\n */\r\nexport declare function createRootComponent<T>(elementNode: LElementNode, componentDef: ComponentDef<T, string>, rootView: LViewData, rootContext: RootContext, hostFeatures: HostFeature[] | null): any;\r\nexport declare function createRootContext(scheduler: (workFn: () => void) => void): RootContext;\r\n/**\r\n * Used to enable lifecycle hooks on the root component.\r\n *\r\n * Include this feature when calling `renderComponent` if the root component\r\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\r\n * be called properly.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * renderComponent(AppComponent, {features: [RootLifecycleHooks]});\r\n * ```\r\n */\r\nexport declare function LifecycleHooksFeature(component: any, def: ComponentDefInternal<any>): void;\r\n/**\r\n * Retrieve the host element of the component.\r\n *\r\n * Use this function to retrieve the host element of the component. The host\r\n * element is the element which the component is associated with.\r\n *\r\n * @param component Component for which the host element should be retrieved.\r\n */\r\nexport declare function getHostElement<T>(component: T): HTMLElement;\r\n/**\r\n * Retrieves the rendered text for a given component.\r\n *\r\n * This function retrieves the host element of a component and\r\n * and then returns the `textContent` for that element. This implies\r\n * that the text returned will include re-projected content of\r\n * the component as well.\r\n *\r\n * @param component The component to return the content text for.\r\n */\r\nexport declare function getRenderedText(component: any): string;\r\n/**\r\n * Wait on component until it is rendered.\r\n *\r\n * This function returns a `Promise` which is resolved when the component's\r\n * change detection is executed. This is determined by finding the scheduler\r\n * associated with the `component`'s render tree and waiting until the scheduler\r\n * flushes. If nothing is scheduled, the function returns a resolved promise.\r\n *\r\n * Example:\r\n * ```\r\n * await whenRendered(myComponent);\r\n * ```\r\n *\r\n * @param component Component to wait upon\r\n * @returns Promise which resolves when the component is rendered.\r\n */\r\nexport declare function whenRendered(component: any): Promise<null>;\r\nexport {};\r\n",
  "/node_modules/@angular/core/src/render3/component_ref.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ChangeDetectorRef as ViewEngine_ChangeDetectorRef } from '../change_detection/change_detector_ref';\r\nimport { InjectionToken } from '../di/injection_token';\r\nimport { Injector } from '../di/injector';\r\nimport { ComponentFactory as viewEngine_ComponentFactory, ComponentRef as viewEngine_ComponentRef } from '../linker/component_factory';\r\nimport { ComponentFactoryResolver as viewEngine_ComponentFactoryResolver } from '../linker/component_factory_resolver';\r\nimport { ElementRef as viewEngine_ElementRef } from '../linker/element_ref';\r\nimport { NgModuleRef as viewEngine_NgModuleRef } from '../linker/ng_module_factory';\r\nimport { RendererFactory2 } from '../render/api';\r\nimport { Type } from '../type';\r\nimport { ComponentDefInternal } from './interfaces/definition';\r\nimport { RElement } from './interfaces/renderer';\r\nimport { LViewData, RootContext } from './interfaces/view';\r\nimport { ViewRef } from './view_ref';\r\nexport declare class ComponentFactoryResolver extends viewEngine_ComponentFactoryResolver {\r\n    resolveComponentFactory<T>(component: Type<T>): viewEngine_ComponentFactory<T>;\r\n}\r\n/**\r\n * Default {@link RootContext} for all components rendered with {@link renderComponent}.\r\n */\r\nexport declare const ROOT_CONTEXT: InjectionToken<RootContext>;\r\n/**\r\n * A change detection scheduler token for {@link RootContext}. This token is the default value used\r\n * for the default `RootContext` found in the {@link ROOT_CONTEXT} token.\r\n */\r\nexport declare const SCHEDULER: InjectionToken<(fn: () => void) => void>;\r\n/**\r\n * A function used to wrap the `RendererFactory2`.\r\n * Used in tests to change the `RendererFactory2` into a `DebugRendererFactory2`.\r\n */\r\nexport declare const WRAP_RENDERER_FACTORY2: InjectionToken<(rf: RendererFactory2) => RendererFactory2>;\r\n/**\r\n * Render3 implementation of {@link viewEngine_ComponentFactory}.\r\n */\r\nexport declare class ComponentFactory<T> extends viewEngine_ComponentFactory<T> {\r\n    private componentDef;\r\n    selector: string;\r\n    componentType: Type<any>;\r\n    ngContentSelectors: string[];\r\n    readonly inputs: {\r\n        propName: string;\r\n        templateName: string;\r\n    }[];\r\n    readonly outputs: {\r\n        propName: string;\r\n        templateName: string;\r\n    }[];\r\n    constructor(componentDef: ComponentDefInternal<any>);\r\n    create(injector: Injector, projectableNodes?: any[][] | undefined, rootSelectorOrNode?: any, ngModule?: viewEngine_NgModuleRef<any> | undefined): viewEngine_ComponentRef<T>;\r\n}\r\n/**\r\n * Represents an instance of a Component created via a {@link ComponentFactory}.\r\n *\r\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\r\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\r\n * method.\r\n *\r\n */\r\nexport declare class ComponentRef<T> extends viewEngine_ComponentRef<T> {\r\n    destroyCbs: (() => void)[] | null;\r\n    location: viewEngine_ElementRef<any>;\r\n    injector: Injector;\r\n    instance: T;\r\n    hostView: ViewRef<T>;\r\n    changeDetectorRef: ViewEngine_ChangeDetectorRef;\r\n    componentType: Type<T>;\r\n    constructor(componentType: Type<T>, instance: T, rootView: LViewData, injector: Injector, hostNode: RElement);\r\n    destroy(): void;\r\n    onDestroy(callback: () => void): void;\r\n}\r\n",
  "/node_modules/@angular/core/src/render3/context_discovery.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport './ng_dev_mode';\r\nimport { LElementNode } from './interfaces/node';\r\nimport { RElement } from './interfaces/renderer';\r\nimport { LViewData } from './interfaces/view';\r\n/**\r\n * This property will be monkey-patched on elements, components and directives\r\n */\r\nexport declare const MONKEY_PATCH_KEY_NAME = \"__ngContext__\";\r\n/**\r\n * The internal view context which is specific to a given DOM element, directive or\r\n * component instance. Each value in here (besides the LViewData and element node details)\r\n * can be present, null or undefined. If undefined then it implies the value has not been\r\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\r\n *\r\n * Each value will get filled when the respective value is examined within the getContext\r\n * function. The component, element and each directive instance will share the same instance\r\n * of the context.\r\n */\r\nexport interface LContext {\r\n    /** The component\\'s view data */\r\n    lViewData: LViewData;\r\n    /** The index instance of the LNode */\r\n    lNodeIndex: number;\r\n    /** The instance of the DOM node that is attached to the lNode */\r\n    native: RElement;\r\n    /** The instance of the Component node */\r\n    component: {} | null | undefined;\r\n    /** The list of indices for the active directives that exist on this element */\r\n    directiveIndices: number[] | null | undefined;\r\n    /** The list of active directives that exist on this element */\r\n    directives: Array<{}> | null | undefined;\r\n}\r\n/** Returns the matching `LContext` data for a given DOM node, directive or component instance.\r\n *\r\n * This function will examine the provided DOM element, component, or directive instance\\'s\r\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\r\n * value will be that of the newly created `LContext`.\r\n *\r\n * If the monkey-patched value is the `LViewData` instance then the context value for that\r\n * target will be created and the monkey-patch reference will be updated. Therefore when this\r\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\r\n * directive\\'s monkey-patch values.\r\n *\r\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\r\n * is found which contains a monkey-patch reference. When that occurs then the provided element\r\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\r\n * detected for a component/directive instance then it will throw an error (all components and\r\n * directives should be automatically monkey-patched by ivy).\r\n */\r\nexport declare function getContext(target: any): LContext | null;\r\n/**\r\n * A utility function for retrieving the matching lElementNode\r\n * from a given DOM element, component or directive.\r\n */\r\nexport declare function getLElementNode(target: any): LElementNode | null;\r\nexport declare function getLElementFromRootComponent(rootComponentInstance: {}): LElementNode | null;\r\n/**\r\n * A simplified lookup function for finding the LElementNode from a component instance.\r\n *\r\n * This function exists for tree-shaking purposes to avoid having to pull in everything\r\n * that `getContext` has in the event that an Angular application doesn't need to have\r\n * any programmatic access to an element's context (only change detection uses this function).\r\n */\r\nexport declare function getLElementFromComponent(componentInstance: {}): LElementNode | null;\r\n/**\r\n * Assigns the given data to the given target (which could be a component,\r\n * directive or DOM node instance) using monkey-patching.\r\n */\r\nexport declare function attachPatchData(target: any, data: LViewData | LContext): void;\r\n/**\r\n * Returns the monkey-patch value data present on the target (which could be\r\n * a component, directive or a DOM node).\r\n */\r\nexport declare function readPatchedData(target: any): LViewData | LContext | null;\r\nexport declare function readPatchedLViewData(target: any): LViewData | null;\r\nexport declare function isComponentInstance(instance: any): boolean;\r\nexport declare function isDirectiveInstance(instance: any): boolean;\r\n",
  "/node_modules/@angular/core/src/render3/debug.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Renderer2, RendererType2 } from '../render/api';\r\nimport { DebugRendererFactory2 } from '../view/services';\r\n/**\r\n * Adapts the DebugRendererFactory2 to create a DebugRenderer2 specific for IVY.\r\n *\r\n * The created DebugRenderer know how to create a Debug Context specific to IVY.\r\n */\r\nexport declare class Render3DebugRendererFactory2 extends DebugRendererFactory2 {\r\n    createRenderer(element: any, renderData: RendererType2 | null): Renderer2;\r\n}\r\n",
  "/node_modules/@angular/core/src/render3/definition.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport './ng_dev_mode';\r\nimport { ChangeDetectionStrategy } from '../change_detection/constants';\r\nimport { Provider } from '../di/provider';\r\nimport { NgModuleDef, NgModuleDefInternal } from '../metadata/ng_module';\r\nimport { ViewEncapsulation } from '../metadata/view';\r\nimport { Type } from '../type';\r\nimport { BaseDef, ComponentDefFeature, ComponentDefInternal, ComponentQuery, ComponentTemplate, ComponentType, DirectiveDefFeature, DirectiveDefInternal, DirectiveType, DirectiveTypesOrFactory, PipeDefInternal, PipeType, PipeTypesOrFactory } from './interfaces/definition';\r\nimport { CssSelectorList, SelectorFlags } from './interfaces/projection';\r\nexport declare const EMPTY: {};\r\nexport declare const EMPTY_ARRAY: any[];\r\n/**\r\n * Create a component definition object.\r\n *\r\n *\r\n * # Example\r\n * ```\r\n * class MyDirective {\r\n *   // Generated by Angular Template Compiler\r\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\r\n *   static ngComponentDef = defineComponent({\r\n *     ...\r\n *   });\r\n * }\r\n * ```\r\n */\r\nexport declare function defineComponent<T>(componentDefinition: {\r\n    /**\r\n     * Directive type, needed to configure the injector.\r\n     */\r\n    type: Type<T>;\r\n    /** The selectors that will be used to match nodes to this component. */\r\n    selectors: CssSelectorList;\r\n    /**\r\n     * Factory method used to create an instance of directive.\r\n     */\r\n    factory: () => T;\r\n    /**\r\n     * The number of nodes, local refs, and pipes in this component template.\r\n     *\r\n     * Used to calculate the length of this component's LViewData array, so we\r\n     * can pre-fill the array and set the binding start index.\r\n     */\r\n    consts: number;\r\n    /**\r\n     * The number of bindings in this component template (including pure fn bindings).\r\n     *\r\n     * Used to calculate the length of this component's LViewData array, so we\r\n     * can pre-fill the array and set the host binding start index.\r\n     */\r\n    vars: number;\r\n    /**\r\n     * The number of host bindings (including pure fn bindings) in this component.\r\n     *\r\n     * Used to calculate the length of the LViewData array for the *parent* component\r\n     * of this component.\r\n     */\r\n    hostVars?: number;\r\n    /**\r\n     * Static attributes to set on host element.\r\n     *\r\n     * Even indices: attribute name\r\n     * Odd indices: attribute value\r\n     */\r\n    attributes?: string[];\r\n    /**\r\n     * A map of input names.\r\n     *\r\n     * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\r\n     *\r\n     * Given:\r\n     * ```\r\n     * class MyComponent {\r\n     *   @Input()\r\n     *   publicInput1: string;\r\n     *\r\n     *   @Input('publicInput2')\r\n     *   declaredInput2: string;\r\n     * }\r\n     * ```\r\n     *\r\n     * is described as:\r\n     * ```\r\n     * {\r\n     *   publicInput1: 'publicInput1',\r\n     *   declaredInput2: ['declaredInput2', 'publicInput2'],\r\n     * }\r\n     * ```\r\n     *\r\n     * Which the minifier may translate to:\r\n     * ```\r\n     * {\r\n     *   minifiedPublicInput1: 'publicInput1',\r\n     *   minifiedDeclaredInput2: [ 'publicInput2', 'declaredInput2'],\r\n     * }\r\n     * ```\r\n     *\r\n     * This allows the render to re-construct the minified, public, and declared names\r\n     * of properties.\r\n     *\r\n     * NOTE:\r\n     *  - Because declared and public name are usually same we only generate the array\r\n     *    `['declared', 'public']` format when they differ.\r\n     *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\r\n     *    inconsistent behavior in that it uses declared names rather than minified or public. For\r\n     *    this reason `NgOnChanges` will be deprecated and removed in future version and this\r\n     *    API will be simplified to be consistent with `output`.\r\n     */\r\n    inputs?: {\r\n        [P in keyof T]?: string | [string, string];\r\n    };\r\n    /**\r\n     * A map of output names.\r\n     *\r\n     * The format is in: `{[actualPropertyName: string]:string}`.\r\n     *\r\n     * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\r\n     *\r\n     * This allows the render to re-construct the minified and non-minified names\r\n     * of properties.\r\n     */\r\n    outputs?: {\r\n        [P in keyof T]?: string;\r\n    };\r\n    /**\r\n     * Function executed by the parent template to allow child directive to apply host bindings.\r\n     */\r\n    hostBindings?: (directiveIndex: number, elementIndex: number) => void;\r\n    /**\r\n     * Function to create instances of content queries associated with a given directive.\r\n     */\r\n    contentQueries?: (() => void);\r\n    /** Refreshes content queries associated with directives in a given view */\r\n    contentQueriesRefresh?: ((directiveIndex: number, queryIndex: number) => void);\r\n    /**\r\n     * Defines the name that can be used in the template to assign this directive to a variable.\r\n     *\r\n     * See: {@link Directive.exportAs}\r\n     */\r\n    exportAs?: string;\r\n    /**\r\n     * Template function use for rendering DOM.\r\n     *\r\n     * This function has following structure.\r\n     *\r\n     * ```\r\n     * function Template<T>(ctx:T, creationMode: boolean) {\r\n     *   if (creationMode) {\r\n     *     // Contains creation mode instructions.\r\n     *   }\r\n     *   // Contains binding update instructions\r\n     * }\r\n     * ```\r\n     *\r\n     * Common instructions are:\r\n     * Creation mode instructions:\r\n     *  - `elementStart`, `elementEnd`\r\n     *  - `text`\r\n     *  - `container`\r\n     *  - `listener`\r\n     *\r\n     * Binding update instructions:\r\n     * - `bind`\r\n     * - `elementAttribute`\r\n     * - `elementProperty`\r\n     * - `elementClass`\r\n     * - `elementStyle`\r\n     *\r\n     */\r\n    template: ComponentTemplate<T>;\r\n    /**\r\n     * Additional set of instructions specific to view query processing. This could be seen as a\r\n     * set of instruction to be inserted into the template function.\r\n     *\r\n     * Query-related instructions need to be pulled out to a specific function as a timing of\r\n     * execution is different as compared to all other instructions (after change detection hooks but\r\n     * before view hooks).\r\n     */\r\n    viewQuery?: ComponentQuery<T> | null;\r\n    /**\r\n     * A list of optional features to apply.\r\n     *\r\n     * See: {@link NgOnChangesFeature}, {@link PublicFeature}\r\n     */\r\n    features?: ComponentDefFeature[];\r\n    /**\r\n     * Defines template and style encapsulation options available for Component's {@link Component}.\r\n     */\r\n    encapsulation?: ViewEncapsulation;\r\n    /**\r\n     * Defines arbitrary developer-defined data to be stored on a renderer instance.\r\n     * This is useful for renderers that delegate to other renderers.\r\n     *\r\n     * see: animation\r\n     */\r\n    data?: {\r\n        [kind: string]: any;\r\n    };\r\n    /**\r\n     * A set of styles that the component needs to be present for component to render correctly.\r\n     */\r\n    styles?: string[];\r\n    /**\r\n     * The strategy that the default change detector uses to detect changes.\r\n     * When set, takes effect the next time change detection is triggered.\r\n     */\r\n    changeDetection?: ChangeDetectionStrategy;\r\n    /**\r\n     * Defines the set of injectable objects that are visible to a Directive and its light DOM\r\n     * children.\r\n     */\r\n    providers?: Provider[];\r\n    /**\r\n     * Defines the set of injectable objects that are visible to its view DOM children.\r\n     */\r\n    viewProviders?: Provider[];\r\n    /**\r\n     * Registry of directives and components that may be found in this component's view.\r\n     *\r\n     * The property is either an array of `DirectiveDef`s or a function which returns the array of\r\n     * `DirectiveDef`s. The function is necessary to be able to support forward declarations.\r\n     */\r\n    directives?: DirectiveTypesOrFactory | null;\r\n    /**\r\n     * Registry of pipes that may be found in this component's view.\r\n     *\r\n     * The property is either an array of `PipeDefs`s or a function which returns the array of\r\n     * `PipeDefs`s. The function is necessary to be able to support forward declarations.\r\n     */\r\n    pipes?: PipeTypesOrFactory | null;\r\n    /**\r\n     * Registry of the animation triggers present on the component that will be used by the view.\r\n     */\r\n    animations?: any[] | null;\r\n}): never;\r\nexport declare function extractDirectiveDef(type: DirectiveType<any> & ComponentType<any>): DirectiveDefInternal<any> | ComponentDefInternal<any>;\r\nexport declare function extractPipeDef(type: PipeType<any>): PipeDefInternal<any>;\r\nexport declare function defineNgModule<T>(def: {\r\n    type: T;\r\n} & Partial<NgModuleDef<T, any, any, any>>): never;\r\n/**\r\n * Create a base definition\r\n *\r\n * # Example\r\n * ```\r\n * class ShouldBeInherited {\r\n *   static ngBaseDef = defineBase({\r\n *      ...\r\n *   })\r\n * }\r\n * @param baseDefinition The base definition parameters\r\n */\r\nexport declare function defineBase<T>(baseDefinition: {\r\n    /**\r\n     * A map of input names.\r\n     *\r\n     * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\r\n     *\r\n     * Given:\r\n     * ```\r\n     * class MyComponent {\r\n     *   @Input()\r\n     *   publicInput1: string;\r\n     *\r\n     *   @Input('publicInput2')\r\n     *   declaredInput2: string;\r\n     * }\r\n     * ```\r\n     *\r\n     * is described as:\r\n     * ```\r\n     * {\r\n     *   publicInput1: 'publicInput1',\r\n     *   declaredInput2: ['declaredInput2', 'publicInput2'],\r\n     * }\r\n     * ```\r\n     *\r\n     * Which the minifier may translate to:\r\n     * ```\r\n     * {\r\n     *   minifiedPublicInput1: 'publicInput1',\r\n     *   minifiedDeclaredInput2: [ 'declaredInput2', 'publicInput2'],\r\n     * }\r\n     * ```\r\n     *\r\n     * This allows the render to re-construct the minified, public, and declared names\r\n     * of properties.\r\n     *\r\n     * NOTE:\r\n     *  - Because declared and public name are usually same we only generate the array\r\n     *    `['declared', 'public']` format when they differ.\r\n     *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\r\n     *    inconsistent behavior in that it uses declared names rather than minified or public. For\r\n     *    this reason `NgOnChanges` will be deprecated and removed in future version and this\r\n     *    API will be simplified to be consistent with `outputs`.\r\n     */\r\n    inputs?: {\r\n        [P in keyof T]?: string | [string, string];\r\n    };\r\n    /**\r\n     * A map of output names.\r\n     *\r\n     * The format is in: `{[actualPropertyName: string]:string}`.\r\n     *\r\n     * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\r\n     *\r\n     * This allows the render to re-construct the minified and non-minified names\r\n     * of properties.\r\n     */\r\n    outputs?: {\r\n        [P in keyof T]?: string;\r\n    };\r\n}): BaseDef<T>;\r\n/**\r\n * Create a directive definition object.\r\n *\r\n * # Example\r\n * ```\r\n * class MyDirective {\r\n *   // Generated by Angular Template Compiler\r\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\r\n *   static ngDirectiveDef = defineDirective({\r\n *     ...\r\n *   });\r\n * }\r\n * ```\r\n */\r\nexport declare const defineDirective: <T>(directiveDefinition: {\r\n    /**\r\n     * Directive type, needed to configure the injector.\r\n     */\r\n    type: Type<T>;\r\n    /** The selectors that will be used to match nodes to this directive. */\r\n    selectors: (string | SelectorFlags)[][];\r\n    /**\r\n     * Factory method used to create an instance of directive.\r\n     */\r\n    factory: () => T;\r\n    /**\r\n     * Static attributes to set on host element.\r\n     *\r\n     * Even indices: attribute name\r\n     * Odd indices: attribute value\r\n     */\r\n    attributes?: string[];\r\n    /**\r\n     * A map of input names.\r\n     *\r\n     * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\r\n     *\r\n     * Given:\r\n     * ```\r\n     * class MyComponent {\r\n     *   @Input()\r\n     *   publicInput1: string;\r\n     *\r\n     *   @Input('publicInput2')\r\n     *   declaredInput2: string;\r\n     * }\r\n     * ```\r\n     *\r\n     * is described as:\r\n     * ```\r\n     * {\r\n     *   publicInput1: 'publicInput1',\r\n     *   declaredInput2: ['declaredInput2', 'publicInput2'],\r\n     * }\r\n     * ```\r\n     *\r\n     * Which the minifier may translate to:\r\n     * ```\r\n     * {\r\n     *   minifiedPublicInput1: 'publicInput1',\r\n     *   minifiedDeclaredInput2: [ 'publicInput2', 'declaredInput2'],\r\n     * }\r\n     * ```\r\n     *\r\n     * This allows the render to re-construct the minified, public, and declared names\r\n     * of properties.\r\n     *\r\n     * NOTE:\r\n     *  - Because declared and public name are usually same we only generate the array\r\n     *    `['declared', 'public']` format when they differ.\r\n     *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\r\n     *    inconsistent behavior in that it uses declared names rather than minified or public. For\r\n     *    this reason `NgOnChanges` will be deprecated and removed in future version and this\r\n     *    API will be simplified to be consistent with `output`.\r\n     */\r\n    inputs?: { [P in keyof T]?: string | [string, string]; };\r\n    /**\r\n     * A map of output names.\r\n     *\r\n     * The format is in: `{[actualPropertyName: string]:string}`.\r\n     *\r\n     * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\r\n     *\r\n     * This allows the render to re-construct the minified and non-minified names\r\n     * of properties.\r\n     */\r\n    outputs?: { [P in keyof T]?: string; };\r\n    /**\r\n     * A list of optional features to apply.\r\n     *\r\n     * See: {@link NgOnChangesFeature}, {@link PublicFeature}, {@link InheritDefinitionFeature}\r\n     */\r\n    features?: DirectiveDefFeature[];\r\n    /**\r\n     * The number of host bindings (including pure fn bindings) in this directive.\r\n     *\r\n     * Used to calculate the length of the LViewData array for the *parent* component\r\n     * of this directive.\r\n     */\r\n    hostVars?: number;\r\n    /**\r\n     * Function executed by the parent template to allow child directive to apply host bindings.\r\n     */\r\n    hostBindings?: (directiveIndex: number, elementIndex: number) => void;\r\n    /**\r\n     * Function to create instances of content queries associated with a given directive.\r\n     */\r\n    contentQueries?: () => void;\r\n    /** Refreshes content queries associated with directives in a given view */\r\n    contentQueriesRefresh?: (directiveIndex: number, queryIndex: number) => void;\r\n    /**\r\n     * Defines the name that can be used in the template to assign this directive to a variable.\r\n     *\r\n     * See: {@link Directive.exportAs}\r\n     */\r\n    exportAs?: string;\r\n}) => never;\r\n/**\r\n * Create a pipe definition object.\r\n *\r\n * # Example\r\n * ```\r\n * class MyPipe implements PipeTransform {\r\n *   // Generated by Angular Template Compiler\r\n *   static ngPipeDef = definePipe({\r\n *     ...\r\n *   });\r\n * }\r\n * ```\r\n * @param pipeDef Pipe definition generated by the compiler\r\n */\r\nexport declare function definePipe<T>(pipeDef: {\r\n    /** Name of the pipe. Used for matching pipes in template to pipe defs. */\r\n    name: string;\r\n    /** Pipe class reference. Needed to extract pipe lifecycle hooks. */\r\n    type: Type<T>;\r\n    /** A factory for creating a pipe instance. */\r\n    factory: () => T;\r\n    /** Whether the pipe is pure. */\r\n    pure?: boolean;\r\n}): never;\r\n/**\r\n * The following getter methods retrieve the definition form the type. Currently the retrieval\r\n * honors inheritance, but in the future we may change the rule to require that definitions are\r\n * explicit. This would require some sort of migration strategy.\r\n */\r\nexport declare function getComponentDef<T>(type: any): ComponentDefInternal<T> | null;\r\nexport declare function getDirectiveDef<T>(type: any): DirectiveDefInternal<T> | null;\r\nexport declare function getPipeDef<T>(type: any): PipeDefInternal<T> | null;\r\nexport declare function getNgModuleDef<T>(type: any): NgModuleDefInternal<T> | null;\r\n",
  "/node_modules/@angular/core/src/render3/di.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ChangeDetectorRef as viewEngine_ChangeDetectorRef } from '../change_detection/change_detector_ref';\r\nimport { InjectionToken } from '../di/injection_token';\r\nimport { InjectFlags, Injector } from '../di/injector';\r\nimport { ComponentFactoryResolver as viewEngine_ComponentFactoryResolver } from '../linker/component_factory_resolver';\r\nimport { ElementRef as viewEngine_ElementRef } from '../linker/element_ref';\r\nimport { TemplateRef as viewEngine_TemplateRef } from '../linker/template_ref';\r\nimport { ViewContainerRef as viewEngine_ViewContainerRef } from '../linker/view_container_ref';\r\nimport { Renderer2 } from '../render';\r\nimport { Type } from '../type';\r\nimport { DirectiveDefInternal } from './interfaces/definition';\r\nimport { LInjector } from './interfaces/injector';\r\nimport { LContainerNode, LElementContainerNode, LElementNode, LNodeWithLocalRefs, TNode } from './interfaces/node';\r\nimport { QueryReadType } from './interfaces/query';\r\n/**\r\n * Registers this directive as present in its node's injector by flipping the directive's\r\n * corresponding bit in the injector's bloom filter.\r\n *\r\n * @param injector The node injector in which the directive should be registered\r\n * @param type The directive to register\r\n */\r\nexport declare function bloomAdd(injector: LInjector, type: Type<any>): void;\r\nexport declare function getOrCreateNodeInjector(): LInjector;\r\n/**\r\n * Creates (or gets an existing) injector for a given element or container.\r\n *\r\n * @param node for which an injector should be retrieved / created.\r\n * @returns Node injector\r\n */\r\nexport declare function getOrCreateNodeInjectorForNode(node: LElementNode | LElementContainerNode | LContainerNode, tNode: TNode): LInjector;\r\n/**\r\n * Makes a directive public to the DI system by adding it to an injector's bloom filter.\r\n *\r\n * @param di The node injector in which a directive will be added\r\n * @param def The definition of the directive to be made public\r\n */\r\nexport declare function diPublicInInjector(di: LInjector, def: DirectiveDefInternal<any>): void;\r\n/**\r\n * Makes a directive public to the DI system by adding it to an injector's bloom filter.\r\n *\r\n * @param def The definition of the directive to be made public\r\n */\r\nexport declare function diPublic(def: DirectiveDefInternal<any>): void;\r\n/**\r\n * Returns the value associated to the given token from the injectors.\r\n *\r\n * `directiveInject` is intended to be used for directive, component and pipe factories.\r\n *  All other injection use `inject` which does not walk the node injector tree.\r\n *\r\n * Usage example (in factory function):\r\n *\r\n * class SomeDirective {\r\n *   constructor(directive: DirectiveA) {}\r\n *\r\n *   static ngDirectiveDef = defineDirective({\r\n *     type: SomeDirective,\r\n *     factory: () => new SomeDirective(directiveInject(DirectiveA))\r\n *   });\r\n * }\r\n *\r\n * @param token the type or token to inject\r\n * @param flags Injection flags\r\n * @returns the value from the injector or `null` when not found\r\n */\r\nexport declare function directiveInject<T>(token: Type<T> | InjectionToken<T>): T;\r\nexport declare function directiveInject<T>(token: Type<T> | InjectionToken<T>, flags: InjectFlags): T;\r\n/**\r\n * Creates an ElementRef and stores it on the injector.\r\n * Or, if the ElementRef already exists, retrieves the existing ElementRef.\r\n *\r\n * @returns The ElementRef instance to use\r\n */\r\nexport declare function injectElementRef(): viewEngine_ElementRef;\r\n/**\r\n * Creates a TemplateRef and stores it on the injector. Or, if the TemplateRef already\r\n * exists, retrieves the existing TemplateRef.\r\n *\r\n * @returns The TemplateRef instance to use\r\n */\r\nexport declare function injectTemplateRef<T>(): viewEngine_TemplateRef<T>;\r\n/**\r\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\r\n * already exists, retrieves the existing ViewContainerRef.\r\n *\r\n * @returns The ViewContainerRef instance to use\r\n */\r\nexport declare function injectViewContainerRef(): viewEngine_ViewContainerRef;\r\n/** Returns a ChangeDetectorRef (a.k.a. a ViewRef) */\r\nexport declare function injectChangeDetectorRef(): viewEngine_ChangeDetectorRef;\r\n/**\r\n * Creates a ComponentFactoryResolver and stores it on the injector. Or, if the\r\n * ComponentFactoryResolver\r\n * already exists, retrieves the existing ComponentFactoryResolver.\r\n *\r\n * @returns The ComponentFactoryResolver instance to use\r\n */\r\nexport declare function injectComponentFactoryResolver(): viewEngine_ComponentFactoryResolver;\r\nexport declare function injectRenderer2(): Renderer2;\r\n/**\r\n * Inject static attribute value into directive constructor.\r\n *\r\n * This method is used with `factory` functions which are generated as part of\r\n * `defineDirective` or `defineComponent`. The method retrieves the static value\r\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\r\n *  at the time of injection and can change over time.)\r\n *\r\n * # Example\r\n * Given:\r\n * ```\r\n * @Component(...)\r\n * class MyComponent {\r\n *   constructor(@Attribute('title') title: string) { ... }\r\n * }\r\n * ```\r\n * When instantiated with\r\n * ```\r\n * <my-component title=\"Hello\"></my-component>\r\n * ```\r\n *\r\n * Then factory method generated is:\r\n * ```\r\n * MyComponent.ngComponentDef = defineComponent({\r\n *   factory: () => new MyComponent(injectAttribute('title'))\r\n *   ...\r\n * })\r\n * ```\r\n *\r\n * @experimental\r\n */\r\nexport declare function injectAttribute(attrNameToInject: string): string | undefined;\r\n/**\r\n * Creates a ViewRef and stores it on the injector as ChangeDetectorRef (public alias).\r\n * Or, if it already exists, retrieves the existing instance.\r\n *\r\n * @returns The ChangeDetectorRef to use\r\n */\r\nexport declare function getOrCreateChangeDetectorRef(di: LInjector, context: any): viewEngine_ChangeDetectorRef;\r\n/**\r\n * Returns the value associated to the given token from the injectors.\r\n *\r\n * Look for the injector providing the token by walking up the node injector tree and then\r\n * the module injector tree.\r\n *\r\n * @param nodeInjector Node injector where the search should start\r\n * @param token The token to look for\r\n * @param flags Injection flags\r\n * @returns the value from the injector or `null` when not found\r\n */\r\nexport declare function getOrCreateInjectable<T>(nodeInjector: LInjector, token: Type<T> | InjectionToken<T>, flags?: InjectFlags): T | null;\r\n/**\r\n * Finds the closest injector that might have a certain directive.\r\n *\r\n * Each directive corresponds to a bit in an injector's bloom filter. Given the bloom bit to\r\n * check and a starting injector, this function traverses up injectors until it finds an\r\n * injector that contains a 1 for that bit in its bloom filter. A 1 indicates that the\r\n * injector may have that directive. It only *may* have the directive because directives begin\r\n * to share bloom filter bits after the BLOOM_SIZE is reached, and it could correspond to a\r\n * different directive sharing the bit.\r\n *\r\n * Note: We can skip checking further injectors up the tree if an injector's cbf structure\r\n * has a 0 for that bloom bit. Since cbf contains the merged value of all the parent\r\n * injectors, a 0 in the bloom bit indicates that the parents definitely do not contain\r\n * the directive and do not need to be checked.\r\n *\r\n * @param injector The starting node injector to check\r\n * @param  bloomBit The bit to check in each injector's bloom filter\r\n * @param  flags The injection flags for this injection site (e.g. Optional or SkipSelf)\r\n * @returns An injector that might have the directive\r\n */\r\nexport declare function bloomFindPossibleInjector(startInjector: LInjector, bloomBit: number, flags: InjectFlags): LInjector | null;\r\nexport declare class ReadFromInjectorFn<T> {\r\n    readonly read: (injector: LInjector, tNode: TNode, directiveIndex?: number) => T;\r\n    constructor(read: (injector: LInjector, tNode: TNode, directiveIndex?: number) => T);\r\n}\r\n/**\r\n * Creates an ElementRef for a given node injector and stores it on the injector.\r\n * Or, if the ElementRef already exists, retrieves the existing ElementRef.\r\n *\r\n * @param di The node injector where we should store a created ElementRef\r\n * @returns The ElementRef instance to use\r\n */\r\nexport declare function getOrCreateElementRef(di: LInjector): viewEngine_ElementRef;\r\nexport declare const QUERY_READ_TEMPLATE_REF: QueryReadType<viewEngine_TemplateRef<any>>;\r\nexport declare const QUERY_READ_CONTAINER_REF: QueryReadType<viewEngine_ViewContainerRef>;\r\nexport declare const QUERY_READ_ELEMENT_REF: QueryReadType<viewEngine_ElementRef<any>>;\r\nexport declare const QUERY_READ_FROM_NODE: QueryReadType<any>;\r\n/**\r\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\r\n * already exists, retrieves the existing ViewContainerRef.\r\n *\r\n * @returns The ViewContainerRef instance to use\r\n */\r\nexport declare function getOrCreateContainerRef(di: LInjector): viewEngine_ViewContainerRef;\r\nexport declare class NodeInjector implements Injector {\r\n    private _lInjector;\r\n    constructor(_lInjector: LInjector);\r\n    get(token: any): any;\r\n}\r\n/**\r\n * Creates a TemplateRef and stores it on the injector. Or, if the TemplateRef already\r\n * exists, retrieves the existing TemplateRef.\r\n *\r\n * @param di The node injector where we should store a created TemplateRef\r\n * @returns The TemplateRef instance to use\r\n */\r\nexport declare function getOrCreateTemplateRef<T>(di: LInjector): viewEngine_TemplateRef<T>;\r\nexport declare function getFactoryOf<T>(type: Type<any>): ((type?: Type<T>) => T) | null;\r\nexport declare function getInheritedFactory<T>(type: Type<any>): (type: Type<T>) => T;\r\n/**\r\n * Retrieves `TemplateRef` instance from `Injector` when a local reference is placed on the\r\n * `<ng-template>` element.\r\n */\r\nexport declare function templateRefExtractor(lNode: LNodeWithLocalRefs, tNode: TNode): viewEngine_TemplateRef<{}>;\r\n",
  "/node_modules/@angular/core/src/render3/errors.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { TNode } from './interfaces/node';\r\n/** Called when directives inject each other (creating a circular dependency) */\r\nexport declare function throwCyclicDependencyError(token: any): never;\r\n/** Called when there are multiple component selectors that match a given node */\r\nexport declare function throwMultipleComponentError(tNode: TNode): never;\r\n/** Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on. */\r\nexport declare function throwErrorIfNoChangesMode(creationMode: boolean, checkNoChangesMode: boolean, oldValue: any, currValue: any): never | void;\r\n",
  "/node_modules/@angular/core/src/render3/features/inherit_definition_feature.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ComponentDefInternal, DirectiveDefInternal } from '../interfaces/definition';\r\n/**\r\n * Merges the definition from a super class to a sub class.\r\n * @param definition The definition that is a SubClass of another directive of component\r\n */\r\nexport declare function InheritDefinitionFeature(definition: DirectiveDefInternal<any> | ComponentDefInternal<any>): void;\r\n",
  "/node_modules/@angular/core/src/render3/features/ng_onchanges_feature.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { DirectiveDefInternal } from '../interfaces/definition';\r\n/**\r\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\r\n * lifecycle hook, so it should be included in any component that implements\r\n * that hook.\r\n *\r\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\r\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\r\n * inherited properties will not be propagated to the ngOnChanges lifecycle\r\n * hook.\r\n *\r\n * Example usage:\r\n *\r\n * ```\r\n * static ngComponentDef = defineComponent({\r\n *   ...\r\n *   inputs: {name: 'publicName'},\r\n *   features: [NgOnChangesFeature]\r\n * });\r\n * ```\r\n */\r\nexport declare function NgOnChangesFeature<T>(definition: DirectiveDefInternal<T>): void;\r\n",
  "/node_modules/@angular/core/src/render3/features/public_feature.d.ts": "import { DirectiveDefInternal } from '../interfaces/definition';\r\n/**\r\n * This feature publishes the directive (or component) into the DI system, making it visible to\r\n * others for injection.\r\n *\r\n * @param definition\r\n */\r\nexport declare function PublicFeature<T>(definition: DirectiveDefInternal<T>): void;\r\n",
  "/node_modules/@angular/core/src/render3/fields.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare const NG_COMPONENT_DEF: string;\r\nexport declare const NG_DIRECTIVE_DEF: string;\r\nexport declare const NG_INJECTABLE_DEF: string;\r\nexport declare const NG_INJECTOR_DEF: string;\r\nexport declare const NG_PIPE_DEF: string;\r\nexport declare const NG_MODULE_DEF: string;\r\nexport declare const NG_BASE_DEF: string;\r\n",
  "/node_modules/@angular/core/src/render3/hooks.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { HookData, LViewData, TView } from './interfaces/view';\r\n/**\r\n * If this is the first template pass, any ngOnInit or ngDoCheck hooks will be queued into\r\n * TView.initHooks during directiveCreate.\r\n *\r\n * The directive index and hook type are encoded into one number (1st bit: type, remaining bits:\r\n * directive index), then saved in the even indices of the initHooks array. The odd indices\r\n * hold the hook functions themselves.\r\n *\r\n * @param index The index of the directive in LViewData[DIRECTIVES]\r\n * @param hooks The static hooks map on the directive def\r\n * @param tView The current TView\r\n */\r\nexport declare function queueInitHooks(index: number, onInit: (() => void) | null, doCheck: (() => void) | null, tView: TView): void;\r\n/**\r\n * Loops through the directives on a node and queues all their hooks except ngOnInit\r\n * and ngDoCheck, which are queued separately in directiveCreate.\r\n */\r\nexport declare function queueLifecycleHooks(flags: number, tView: TView): void;\r\n/**\r\n * Calls onInit and doCheck calls if they haven't already been called.\r\n *\r\n * @param currentView The current view\r\n */\r\nexport declare function executeInitHooks(currentView: LViewData, tView: TView, creationMode: boolean): void;\r\n/**\r\n * Iterates over afterViewInit and afterViewChecked functions and calls them.\r\n *\r\n * @param currentView The current view\r\n */\r\nexport declare function executeHooks(data: any[], allHooks: HookData | null, checkHooks: HookData | null, creationMode: boolean): void;\r\n/**\r\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\r\n * creation mode.\r\n *\r\n * @param currentView The current view\r\n * @param arr The array in which the hooks are found\r\n */\r\nexport declare function callHooks(data: any[], arr: HookData): void;\r\n",
  "/node_modules/@angular/core/src/render3/i18n.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { NO_CHANGE } from './instructions';\r\n/**\r\n * A list of flags to encode the i18n instructions used to translate the template.\r\n * We shift the flags by 29 so that 30 & 31 & 32 bits contains the instructions.\r\n */\r\nexport declare const enum I18nInstructions {\r\n    Text = 536870912,\r\n    Element = 1073741824,\r\n    Expression = 1610612736,\r\n    TemplateRoot = -2147483648,\r\n    Any = -1610612736,\r\n    CloseNode = -1073741824,\r\n    RemoveNode = -536870912,\r\n    /** Used to decode the number encoded with the instruction. */\r\n    IndexMask = 536870911,\r\n    /** Used to test the type of instruction. */\r\n    InstructionMask = -536870912\r\n}\r\n/**\r\n * Represents the instructions used to translate the template.\r\n * Instructions can be a placeholder index, a static text or a simple bit field (`I18nFlag`).\r\n * When the instruction is the flag `Text`, it is always followed by its text value.\r\n */\r\nexport declare type I18nInstruction = number | string;\r\n/**\r\n * Represents the instructions used to translate attributes containing expressions.\r\n * Even indexes contain static strings, while odd indexes contain the index of the expression whose\r\n * value will be concatenated into the final translation.\r\n */\r\nexport declare type I18nExpInstruction = number | string;\r\n/** Mapping of placeholder names to their absolute indexes in their templates. */\r\nexport declare type PlaceholderMap = {\r\n    [name: string]: number;\r\n};\r\n/**\r\n * Takes a translation string, the initial list of placeholders (elements and expressions) and the\r\n * indexes of their corresponding expression nodes to return a list of instructions for each\r\n * template function.\r\n *\r\n * Because embedded templates have different indexes for each placeholder, each parameter (except\r\n * the translation) is an array, where each value corresponds to a different template, by order of\r\n * appearance.\r\n *\r\n * @param translation A translation string where placeholders are represented by `{$name}`\r\n * @param elements An array containing, for each template, the maps of element placeholders and\r\n * their indexes.\r\n * @param expressions An array containing, for each template, the maps of expression placeholders\r\n * and their indexes.\r\n * @param templateRoots An array of template roots whose content should be ignored when\r\n * generating the instructions for their parent template.\r\n * @param lastChildIndex The index of the last child of the i18n node. Used when the i18n block is\r\n * an ng-container.\r\n *\r\n * @returns A list of instructions used to translate each template.\r\n */\r\nexport declare function i18nMapping(translation: string, elements: (PlaceholderMap | null)[] | null, expressions?: (PlaceholderMap | null)[] | null, templateRoots?: string[] | null, lastChildIndex?: number | null): I18nInstruction[][];\r\n/**\r\n * Takes a list of instructions generated by `i18nMapping()` to transform the template accordingly.\r\n *\r\n * @param startIndex Index of the first element to translate (for instance the first child of the\r\n * element with the i18n attribute).\r\n * @param instructions The list of instructions to apply on the current view.\r\n */\r\nexport declare function i18nApply(startIndex: number, instructions: I18nInstruction[]): void;\r\n/**\r\n * Takes a translation string and the initial list of expressions and returns a list of instructions\r\n * that will be used to translate an attribute.\r\n * Even indexes contain static strings, while odd indexes contain the index of the expression whose\r\n * value will be concatenated into the final translation.\r\n */\r\nexport declare function i18nExpMapping(translation: string, placeholders: PlaceholderMap): I18nExpInstruction[];\r\n/**\r\n * Checks if the value of an expression has changed and replaces it by its value in a translation,\r\n * or returns NO_CHANGE.\r\n *\r\n * @param instructions A list of instructions that will be used to translate an attribute.\r\n * @param v0 value checked for change.\r\n *\r\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\r\n */\r\nexport declare function i18nInterpolation1(instructions: I18nExpInstruction[], v0: any): string | NO_CHANGE;\r\n/**\r\n * Checks if the values of up to 2 expressions have changed and replaces them by their values in a\r\n * translation, or returns NO_CHANGE.\r\n *\r\n * @param instructions A list of instructions that will be used to translate an attribute.\r\n * @param v0 value checked for change.\r\n * @param v1 value checked for change.\r\n *\r\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\r\n */\r\nexport declare function i18nInterpolation2(instructions: I18nExpInstruction[], v0: any, v1: any): string | NO_CHANGE;\r\n/**\r\n * Checks if the values of up to 3 expressions have changed and replaces them by their values in a\r\n * translation, or returns NO_CHANGE.\r\n *\r\n * @param instructions A list of instructions that will be used to translate an attribute.\r\n * @param v0 value checked for change.\r\n * @param v1 value checked for change.\r\n * @param v2 value checked for change.\r\n *\r\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\r\n */\r\nexport declare function i18nInterpolation3(instructions: I18nExpInstruction[], v0: any, v1: any, v2: any): string | NO_CHANGE;\r\n/**\r\n * Checks if the values of up to 4 expressions have changed and replaces them by their values in a\r\n * translation, or returns NO_CHANGE.\r\n *\r\n * @param instructions A list of instructions that will be used to translate an attribute.\r\n * @param v0 value checked for change.\r\n * @param v1 value checked for change.\r\n * @param v2 value checked for change.\r\n * @param v3 value checked for change.\r\n *\r\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\r\n */\r\nexport declare function i18nInterpolation4(instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any): string | NO_CHANGE;\r\n/**\r\n * Checks if the values of up to 5 expressions have changed and replaces them by their values in a\r\n * translation, or returns NO_CHANGE.\r\n *\r\n * @param instructions A list of instructions that will be used to translate an attribute.\r\n * @param v0 value checked for change.\r\n * @param v1 value checked for change.\r\n * @param v2 value checked for change.\r\n * @param v3 value checked for change.\r\n * @param v4 value checked for change.\r\n *\r\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\r\n */\r\nexport declare function i18nInterpolation5(instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any): string | NO_CHANGE;\r\n/**\r\n * Checks if the values of up to 6 expressions have changed and replaces them by their values in a\r\n * translation, or returns NO_CHANGE.\r\n *\r\n * @param instructions A list of instructions that will be used to translate an attribute.\r\n * @param v0 value checked for change.\r\n * @param v1 value checked for change.\r\n * @param v2 value checked for change.\r\n * @param v3 value checked for change.\r\n * @param v4 value checked for change.\r\n * @param v5 value checked for change.\r\n *\r\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\r\n */ export declare function i18nInterpolation6(instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any, v5: any): string | NO_CHANGE;\r\n/**\r\n * Checks if the values of up to 7 expressions have changed and replaces them by their values in a\r\n * translation, or returns NO_CHANGE.\r\n *\r\n * @param instructions A list of instructions that will be used to translate an attribute.\r\n * @param v0 value checked for change.\r\n * @param v1 value checked for change.\r\n * @param v2 value checked for change.\r\n * @param v3 value checked for change.\r\n * @param v4 value checked for change.\r\n * @param v5 value checked for change.\r\n * @param v6 value checked for change.\r\n *\r\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\r\n */\r\nexport declare function i18nInterpolation7(instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any): string | NO_CHANGE;\r\n/**\r\n * Checks if the values of up to 8 expressions have changed and replaces them by their values in a\r\n * translation, or returns NO_CHANGE.\r\n *\r\n * @param instructions A list of instructions that will be used to translate an attribute.\r\n * @param v0 value checked for change.\r\n * @param v1 value checked for change.\r\n * @param v2 value checked for change.\r\n * @param v3 value checked for change.\r\n * @param v4 value checked for change.\r\n * @param v5 value checked for change.\r\n * @param v6 value checked for change.\r\n * @param v7 value checked for change.\r\n *\r\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\r\n */\r\nexport declare function i18nInterpolation8(instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any): string | NO_CHANGE;\r\n/**\r\n * Create a translated interpolation binding with a variable number of expressions.\r\n *\r\n * If there are 1 to 8 expressions then `i18nInterpolation()` should be used instead. It is faster\r\n * because there is no need to create an array of expressions and iterate over it.\r\n *\r\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\r\n */\r\nexport declare function i18nInterpolationV(instructions: I18nExpInstruction[], values: any[]): string | NO_CHANGE;\r\n",
  "/node_modules/@angular/core/src/render3/index.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { LifecycleHooksFeature, getHostElement, getRenderedText, renderComponent, whenRendered } from './component';\r\nimport { defineBase, defineComponent, defineDirective, defineNgModule, definePipe } from './definition';\r\nimport { InheritDefinitionFeature } from './features/inherit_definition_feature';\r\nimport { NgOnChangesFeature } from './features/ng_onchanges_feature';\r\nimport { PublicFeature } from './features/public_feature';\r\nimport { BaseDef, ComponentDef, ComponentDefInternal, ComponentTemplate, ComponentType, DirectiveDef, DirectiveDefFlags, DirectiveDefInternal, DirectiveType, PipeDef } from './interfaces/definition';\r\nexport { ComponentFactory, ComponentFactoryResolver, ComponentRef, WRAP_RENDERER_FACTORY2 } from './component_ref';\r\nexport { QUERY_READ_CONTAINER_REF, QUERY_READ_ELEMENT_REF, QUERY_READ_FROM_NODE, QUERY_READ_TEMPLATE_REF, directiveInject, getFactoryOf, getInheritedFactory, injectAttribute, injectChangeDetectorRef, injectComponentFactoryResolver, injectElementRef, injectRenderer2, injectTemplateRef, injectViewContainerRef, templateRefExtractor } from './di';\r\nexport { RenderFlags } from './interfaces/definition';\r\nexport { CssSelectorList } from './interfaces/projection';\r\nexport { NO_CHANGE, bind, interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV, container, containerRefreshStart, containerRefreshEnd, nextContext, element, elementAttribute, elementClassProp, elementEnd, elementProperty, elementStart, elementContainerStart, elementContainerEnd, elementStyling, elementStylingMap, elementStyleProp, elementStylingApply, getCurrentView, restoreView, listener, store, load, loadDirective, namespaceHTML, namespaceMathML, namespaceSVG, projection, projectionDef, text, textBinding, template, reference, embeddedViewStart, embeddedViewEnd, detectChanges, markDirty, tick, } from './instructions';\r\nexport { i18nApply, i18nMapping, i18nInterpolation1, i18nInterpolation2, i18nInterpolation3, i18nInterpolation4, i18nInterpolation5, i18nInterpolation6, i18nInterpolation7, i18nInterpolation8, i18nInterpolationV, i18nExpMapping, I18nInstruction, I18nExpInstruction } from './i18n';\r\nexport { NgModuleFactory, NgModuleRef, NgModuleType } from './ng_module_ref';\r\nexport { AttributeMarker } from './interfaces/node';\r\nexport { pipe, pipeBind1, pipeBind2, pipeBind3, pipeBind4, pipeBindV, } from './pipe';\r\nexport { QueryList, query, queryRefresh, } from './query';\r\nexport { registerContentQuery, loadQueryList, } from './instructions';\r\nexport { pureFunction0, pureFunction1, pureFunction2, pureFunction3, pureFunction4, pureFunction5, pureFunction6, pureFunction7, pureFunction8, pureFunctionV, } from './pure_function';\r\nexport { BaseDef, ComponentDef, ComponentDefInternal, ComponentTemplate, ComponentType, DirectiveDef, DirectiveDefFlags, DirectiveDefInternal, DirectiveType, NgOnChangesFeature, InheritDefinitionFeature, PublicFeature, PipeDef, LifecycleHooksFeature, defineComponent, defineDirective, defineNgModule, defineBase, definePipe, getHostElement, getRenderedText, renderComponent, whenRendered, };\r\n",
  "/node_modules/@angular/core/src/render3/instructions.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport './ng_dev_mode';\r\nimport { QueryList } from '../linker';\r\nimport { Sanitizer } from '../sanitization/security';\r\nimport { StyleSanitizeFn } from '../sanitization/style_sanitizer';\r\nimport { LContainer } from './interfaces/container';\r\nimport { ComponentDefInternal, ComponentQuery, ComponentTemplate, DirectiveDefInternal, DirectiveDefListOrFactory, InitialStylingFlags, PipeDefListOrFactory, RenderFlags } from './interfaces/definition';\r\nimport { LInjector } from './interfaces/injector';\r\nimport { LContainerNode, LElementNode, LNode, LProjectionNode, LTextNode, LViewNode, LocalRefExtractor, TAttributes, TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeType, TProjectionNode, TViewNode } from './interfaces/node';\r\nimport { CssSelectorList } from './interfaces/projection';\r\nimport { LQueries } from './interfaces/query';\r\nimport { RComment, RElement, RText, Renderer3, RendererFactory3 } from './interfaces/renderer';\r\nimport { CurrentMatchesList, LViewData, LViewFlags, OpaqueViewState, RootContext, TView } from './interfaces/view';\r\n/**\r\n * Function used to sanitize the value before writing it into the renderer.\r\n */\r\nexport declare type SanitizerFn = (value: any) => string;\r\n/**\r\n * Token set in currentMatches while dependencies are being resolved.\r\n *\r\n * If we visit a directive that has a value set to CIRCULAR, we know we've\r\n * already seen it, and thus have a circular dependency.\r\n */\r\nexport declare const CIRCULAR = \"__CIRCULAR__\";\r\nexport declare function getRenderer(): Renderer3;\r\nexport declare function getRendererFactory(): RendererFactory3;\r\nexport declare function getCurrentSanitizer(): Sanitizer | null;\r\n/**\r\n * Returns the current OpaqueViewState instance.\r\n *\r\n * Used in conjunction with the restoreView() instruction to save a snapshot\r\n * of the current view and restore it when listeners are invoked. This allows\r\n * walking the declaration view tree in listeners to get vars from parent views.\r\n */\r\nexport declare function getCurrentView(): OpaqueViewState;\r\n/**\r\n * Restores `contextViewData` to the given OpaqueViewState instance.\r\n *\r\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\r\n * of the current view and restore it when listeners are invoked. This allows\r\n * walking the declaration view tree in listeners to get vars from parent views.\r\n *\r\n * @param viewToRestore The OpaqueViewState instance to restore.\r\n */\r\nexport declare function restoreView(viewToRestore: OpaqueViewState): void;\r\nexport declare function getPreviousOrParentNode(): LNode | null;\r\nexport declare function getPreviousOrParentTNode(): TNode;\r\n/**\r\n * Query instructions can ask for \"current queries\" in 2 different cases:\r\n * - when creating view queries (at the root of a component view, before any node is created - in\r\n * this case currentQueries points to view queries)\r\n * - when creating content queries (i.e. this previousOrParentTNode points to a node on which we\r\n * create content queries).\r\n */\r\nexport declare function getOrCreateCurrentQueries(QueryType: {\r\n    new (parent: null, shallow: null, deep: null): LQueries;\r\n}): LQueries;\r\nexport declare function getCreationMode(): boolean;\r\n/**\r\n * Internal function that returns the current LViewData instance.\r\n *\r\n * The getCurrentView() instruction should be used for anything public.\r\n */\r\nexport declare function _getViewData(): LViewData;\r\nexport declare function getBindingRoot(): number;\r\n/**\r\n * Swap the current state with a new state.\r\n *\r\n * For performance reasons we store the state in the top level of the module.\r\n * This way we minimize the number of properties to read. Whenever a new view\r\n * is entered we have to store the state for later, and when the view is\r\n * exited the state has to be restored\r\n *\r\n * @param newView New state to become active\r\n * @param host Element to which the View is a child of\r\n * @returns the previous state;\r\n */\r\nexport declare function enterView(newView: LViewData, hostTNode: TElementNode | TViewNode | null): LViewData;\r\n/**\r\n * Used in lieu of enterView to make it clear when we are exiting a child view. This makes\r\n * the direction of traversal (up or down the view tree) a bit clearer.\r\n *\r\n * @param newView New state to become active\r\n * @param creationOnly An optional boolean to indicate that the view was processed in creation mode\r\n * only, i.e. the first update will be done later. Only possible for dynamically created views.\r\n */\r\nexport declare function leaveView(newView: LViewData, creationOnly?: boolean): void;\r\n/** Sets the host bindings for the current view. */\r\nexport declare function setHostBindings(bindings: number[] | null): void;\r\nexport declare function executeInitAndContentHooks(): void;\r\nexport declare function createLViewData<T>(renderer: Renderer3, tView: TView, context: T | null, flags: LViewFlags, sanitizer?: Sanitizer | null): LViewData;\r\n/**\r\n * Creation of LNode object is extracted to a separate function so we always create LNode object\r\n * with the same shape\r\n * (same properties assigned in the same order).\r\n */\r\nexport declare function createLNodeObject(type: TNodeType, currentView: LViewData, nodeInjector: LInjector | null, native: RText | RElement | RComment | null, state: any): LElementNode & LTextNode & LViewNode & LContainerNode & LProjectionNode;\r\n/**\r\n * A common way of creating the LNode to make sure that all of them have same shape to\r\n * keep the execution code monomorphic and fast.\r\n *\r\n * @param index The index at which the LNode should be saved (null if view, since they are not\r\n * saved).\r\n * @param type The type of LNode to create\r\n * @param native The native element for this LNode, if applicable\r\n * @param name The tag name of the associated native element, if applicable\r\n * @param attrs Any attrs for the native element, if applicable\r\n * @param data Any data that should be saved on the LNode\r\n */\r\nexport declare function createNodeAtIndex(index: number, type: TNodeType.Element, native: RElement | RText | null, name: string | null, attrs: TAttributes | null, lViewData?: LViewData | null): TElementNode;\r\nexport declare function createNodeAtIndex(index: number, type: TNodeType.View, native: null, name: null, attrs: null, lViewData: LViewData): TViewNode;\r\nexport declare function createNodeAtIndex(index: number, type: TNodeType.Container, native: RComment, name: string | null, attrs: TAttributes | null, lContainer: LContainer): TContainerNode;\r\nexport declare function createNodeAtIndex(index: number, type: TNodeType.Projection, native: null, name: null, attrs: TAttributes | null, lProjection: null): TProjectionNode;\r\nexport declare function createNodeAtIndex(index: number, type: TNodeType.ElementContainer, native: RComment, name: null, attrs: TAttributes | null, data: null): TElementContainerNode;\r\n/**\r\n * When LNodes are created dynamically after a view blueprint is created (e.g. through\r\n * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future\r\n * template passes.\r\n */\r\nexport declare function adjustBlueprintForNewNode(view: LViewData): void;\r\n/**\r\n * Resets the application state.\r\n */\r\nexport declare function resetComponentState(): void;\r\n/**\r\n *\r\n * @param hostNode Existing node to render into.\r\n * @param templateFn Template function with the instructions.\r\n * @param consts The number of nodes, local refs, and pipes in this template\r\n * @param context to pass into the template.\r\n * @param providedRendererFactory renderer factory to use\r\n * @param host The host element node to use\r\n * @param directives Directive defs that should be used for matching\r\n * @param pipes Pipe defs that should be used for matching\r\n */\r\nexport declare function renderTemplate<T>(hostNode: RElement, templateFn: ComponentTemplate<T>, consts: number, vars: number, context: T, providedRendererFactory: RendererFactory3, host: LElementNode | null, directives?: DirectiveDefListOrFactory | null, pipes?: PipeDefListOrFactory | null, sanitizer?: Sanitizer | null): LElementNode;\r\n/**\r\n * Used for creating the LViewNode of a dynamic embedded view,\r\n * either through ViewContainerRef.createEmbeddedView() or TemplateRef.createEmbeddedView().\r\n * Such lViewNode will then be renderer with renderEmbeddedTemplate() (see below).\r\n */\r\nexport declare function createEmbeddedViewAndNode<T>(tView: TView, context: T, declarationView: LViewData, renderer: Renderer3, queries?: LQueries | null): LViewData;\r\n/**\r\n * Used for rendering embedded views (e.g. dynamically created views)\r\n *\r\n * Dynamically created views must store/retrieve their TViews differently from component views\r\n * because their template functions are nested in the template functions of their hosts, creating\r\n * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor inside\r\n * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we\r\n * can't store TViews in the template function itself (as we do for comps). Instead, we store the\r\n * TView for dynamically created views on their host TNode, which only has one instance.\r\n */\r\nexport declare function renderEmbeddedTemplate<T>(viewToRender: LViewData, tView: TView, context: T, rf: RenderFlags): void;\r\n/**\r\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\r\n * Will get the next level up if level is not specified.\r\n *\r\n * This is used to save contexts of parent views so they can be bound in embedded views, or\r\n * in conjunction with reference() to bind a ref from a parent view.\r\n *\r\n * @param level The relative level of the view from which to grab context compared to contextVewData\r\n * @returns context\r\n */\r\nexport declare function nextContext<T = any>(level?: number): T;\r\nexport declare function renderComponentOrTemplate<T>(hostView: LViewData, componentOrContext: T, templateFn?: ComponentTemplate<T>): void;\r\nexport declare function namespaceSVG(): void;\r\nexport declare function namespaceMathML(): void;\r\nexport declare function namespaceHTML(): void;\r\n/**\r\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\r\n *\r\n * @param index Index of the element in the data array\r\n * @param name Name of the DOM Node\r\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\r\n * @param localRefs A set of local reference bindings on the element.\r\n */\r\nexport declare function element(index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void;\r\n/**\r\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\r\n * The instruction must later be followed by `elementContainerEnd()` call.\r\n *\r\n * @param index Index of the element in the LViewData array\r\n * @param attrs Set of attributes to be used when matching directives.\r\n * @param localRefs A set of local reference bindings on the element.\r\n *\r\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\r\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\r\n * matching purposes and setting initial inputs of directives.\r\n */\r\nexport declare function elementContainerStart(index: number, attrs?: TAttributes | null, localRefs?: string[] | null): void;\r\n/** Mark the end of the <ng-container>. */\r\nexport declare function elementContainerEnd(): void;\r\n/**\r\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\r\n *\r\n * @param index Index of the element in the LViewData array\r\n * @param name Name of the DOM Node\r\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\r\n * @param localRefs A set of local reference bindings on the element.\r\n *\r\n * Attributes and localRefs are passed as an array of strings where elements with an even index\r\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\r\n * ['id', 'warning5', 'class', 'alert']\r\n */\r\nexport declare function elementStart(index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void;\r\n/**\r\n * Creates a native element from a tag name, using a renderer.\r\n * @param name the tag name\r\n * @param overriddenRenderer Optional A renderer to override the default one\r\n * @returns the element created\r\n */\r\nexport declare function elementCreate(name: string, overriddenRenderer?: Renderer3): RElement;\r\nexport declare function resolveDirective(def: DirectiveDefInternal<any>, valueIndex: number, matches: CurrentMatchesList, tView: TView): any;\r\n/** Stores index of directive and host element so it will be queued for binding refresh during CD.\r\n */\r\nexport declare function queueHostBindingForCheck(dirIndex: number, hostVars: number): void;\r\n/** Sets the context for a ChangeDetectorRef to the given instance. */\r\nexport declare function initChangeDetectorIfExisting(injector: LInjector | null, instance: any, view: LViewData): void;\r\n/**\r\n * Creates a TView instance\r\n *\r\n * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic\r\n * @param templateFn Template function\r\n * @param consts The number of nodes, local refs, and pipes in this template\r\n * @param directives Registry of directives for this view\r\n * @param pipes Registry of pipes for this view\r\n */\r\nexport declare function createTView(viewIndex: number, templateFn: ComponentTemplate<any> | null, consts: number, vars: number, directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null, viewQuery: ComponentQuery<any> | null): TView;\r\nexport declare function createError(text: string, token: any): Error;\r\n/**\r\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\r\n *\r\n * @param elementOrSelector Render element or CSS selector to locate the element.\r\n */\r\nexport declare function locateHostElement(factory: RendererFactory3, elementOrSelector: RElement | string): RElement | null;\r\n/**\r\n * Creates the host LNode.\r\n *\r\n * @param rNode Render host element.\r\n * @param def ComponentDef\r\n *\r\n * @returns LElementNode created\r\n */\r\nexport declare function hostElement(tag: string, rNode: RElement | null, def: ComponentDefInternal<any>, sanitizer?: Sanitizer | null): LElementNode;\r\n/**\r\n * Adds an event listener to the current node.\r\n *\r\n * If an output exists on one of the node's directives, it also subscribes to the output\r\n * and saves the subscription for later cleanup.\r\n *\r\n * @param eventName Name of the event\r\n * @param listenerFn The function to be called when event emits\r\n * @param useCapture Whether or not to use capture in event listener.\r\n */\r\nexport declare function listener(eventName: string, listenerFn: (e?: any) => any, useCapture?: boolean): void;\r\n/**\r\n * Saves context for this cleanup function in LView.cleanupInstances.\r\n *\r\n * On the first template pass, saves in TView:\r\n * - Cleanup function\r\n * - Index of context we just saved in LView.cleanupInstances\r\n */\r\nexport declare function storeCleanupWithContext(view: LViewData | null, context: any, cleanupFn: Function): void;\r\n/**\r\n * Saves the cleanup function itself in LView.cleanupInstances.\r\n *\r\n * This is necessary for functions that are wrapped with their contexts, like in renderer2\r\n * listeners.\r\n *\r\n * On the first template pass, the index of the cleanup function is saved in TView.\r\n */\r\nexport declare function storeCleanupFn(view: LViewData, cleanupFn: Function): void;\r\n/** Mark the end of the element. */\r\nexport declare function elementEnd(): void;\r\n/**\r\n * Updates the value of removes an attribute on an Element.\r\n *\r\n * @param number index The index of the element in the data array\r\n * @param name name The name of the attribute.\r\n * @param value value The attribute is removed when value is `null` or `undefined`.\r\n *                  Otherwise the attribute value is set to the stringified value.\r\n * @param sanitizer An optional function used to sanitize the value.\r\n */\r\nexport declare function elementAttribute(index: number, name: string, value: any, sanitizer?: SanitizerFn): void;\r\n/**\r\n * Update a property on an Element.\r\n *\r\n * If the property name also exists as an input property on one of the element's directives,\r\n * the component property will be set instead of the element property. This check must\r\n * be conducted at runtime so child components that add new @Inputs don't have to be re-compiled.\r\n *\r\n * @param index The index of the element to update in the data array\r\n * @param propName Name of property. Because it is going to DOM, this is not subject to\r\n *        renaming as part of minification.\r\n * @param value New value to write.\r\n * @param sanitizer An optional function used to sanitize the value.\r\n */\r\nexport declare function elementProperty<T>(index: number, propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn): void;\r\n/**\r\n * Constructs a TNode object from the arguments.\r\n *\r\n * @param type The type of the node\r\n * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET\r\n * @param tagName The tag name of the node\r\n * @param attrs The attributes defined on this node\r\n * @param parent The parent of this node\r\n * @param tViews Any TViews attached to this node\r\n * @returns the TNode object\r\n */\r\nexport declare function createTNode(type: TNodeType, adjustedIndex: number, tagName: string | null, attrs: TAttributes | null, parent: TElementNode | TContainerNode | null, tViews: TView[] | null): TNode;\r\n/**\r\n * Add or remove a class in a `classList` on a DOM element.\r\n *\r\n * This instruction is meant to handle the [class.foo]=\"exp\" case\r\n *\r\n * @param index The index of the element to update in the data array\r\n * @param className Name of class to toggle. Because it is going to DOM, this is not subject to\r\n *        renaming as part of minification.\r\n * @param value A value indicating if a given class should be added or removed.\r\n */\r\nexport declare function elementClassProp<T>(index: number, stylingIndex: number, value: T | NO_CHANGE): void;\r\n/**\r\n * Assign any inline style values to the element during creation mode.\r\n *\r\n * This instruction is meant to be called during creation mode to apply all styling\r\n * (e.g. `style=\"...\"`) values to the element. This is also where the provided index\r\n * value is allocated for the styling details for its corresponding element (the element\r\n * index is the previous index value from this one).\r\n *\r\n * (Note this function calls `elementStylingApply` immediately when called.)\r\n *\r\n *\r\n * @param index Index value which will be allocated to store styling data for the element.\r\n *        (Note that this is not the element index, but rather an index value allocated\r\n *        specifically for element styling--the index must be the next index after the element\r\n *        index.)\r\n * @param classDeclarations A key/value array of CSS classes that will be registered on the element.\r\n *   Each individual style will be used on the element as long as it is not overridden\r\n *   by any classes placed on the element by multiple (`[class]`) or singular (`[class.named]`)\r\n *   bindings. If a class binding changes its value to a falsy value then the matching initial\r\n *   class value that are passed in here will be applied to the element (if matched).\r\n * @param styleDeclarations A key/value array of CSS styles that will be registered on the element.\r\n *   Each individual style will be used on the element as long as it is not overridden\r\n *   by any styles placed on the element by multiple (`[style]`) or singular (`[style.prop]`)\r\n *   bindings. If a style binding changes its value to null then the initial styling\r\n *   values that are passed in here will be applied to the element (if matched).\r\n * @param styleSanitizer An optional sanitizer function that will be used (if provided)\r\n *   to sanitize the any CSS property values that are applied to the element (during rendering).\r\n */\r\nexport declare function elementStyling<T>(classDeclarations?: (string | boolean | InitialStylingFlags)[] | null, styleDeclarations?: (string | boolean | InitialStylingFlags)[] | null, styleSanitizer?: StyleSanitizeFn | null): void;\r\n/**\r\n * Apply all styling values to the element which have been queued by any styling instructions.\r\n *\r\n * This instruction is meant to be run once one or more `elementStyle` and/or `elementStyleProp`\r\n * have been issued against the element. This function will also determine if any styles have\r\n * changed and will then skip the operation if there is nothing new to render.\r\n *\r\n * Once called then all queued styles will be flushed.\r\n *\r\n * @param index Index of the element's styling storage that will be rendered.\r\n *        (Note that this is not the element index, but rather an index value allocated\r\n *        specifically for element styling--the index must be the next index after the element\r\n *        index.)\r\n */\r\nexport declare function elementStylingApply<T>(index: number): void;\r\n/**\r\n * Queue a given style to be rendered on an Element.\r\n *\r\n * If the style value is `null` then it will be removed from the element\r\n * (or assigned a different value depending if there are any styles placed\r\n * on the element with `elementStyle` or any styles that are present\r\n * from when the element was created (with `elementStyling`).\r\n *\r\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\r\n *\r\n * @param index Index of the element's styling storage to change in the data array.\r\n *        (Note that this is not the element index, but rather an index value allocated\r\n *        specifically for element styling--the index must be the next index after the element\r\n *        index.)\r\n * @param styleIndex Index of the style property on this element. (Monotonically increasing.)\r\n * @param styleName Name of property. Because it is going to DOM this is not subject to\r\n *        renaming as part of minification.\r\n * @param value New value to write (null to remove).\r\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\r\n *        Note that when a suffix is provided then the underlying sanitizer will\r\n *        be ignored.\r\n */\r\nexport declare function elementStyleProp<T>(index: number, styleIndex: number, value: T | null, suffix?: string): void;\r\n/**\r\n * Queue a key/value map of styles to be rendered on an Element.\r\n *\r\n * This instruction is meant to handle the `[style]=\"exp\"` usage. When styles are applied to\r\n * the Element they will then be placed with respect to any styles set with `elementStyleProp`.\r\n * If any styles are set to `null` then they will be removed from the element (unless the same\r\n * style properties have been assigned to the element during creation using `elementStyling`).\r\n *\r\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\r\n *\r\n * @param index Index of the element's styling storage to change in the data array.\r\n *        (Note that this is not the element index, but rather an index value allocated\r\n *        specifically for element styling--the index must be the next index after the element\r\n *        index.)\r\n * @param classes A key/value style map of CSS classes that will be added to the given element.\r\n *        Any missing classes (that have already been applied to the element beforehand) will be\r\n *        removed (unset) from the element's list of CSS classes.\r\n * @param styles A key/value style map of the styles that will be applied to the given element.\r\n *        Any missing styles (that have already been applied to the element beforehand) will be\r\n *        removed (unset) from the element's styling.\r\n */\r\nexport declare function elementStylingMap<T>(index: number, classes: {\r\n    [key: string]: any;\r\n} | string | null, styles?: {\r\n    [styleName: string]: any;\r\n} | null): void;\r\n/**\r\n * Create static text node\r\n *\r\n * @param index Index of the node in the data array\r\n * @param value Value to write. This value will be stringified.\r\n */\r\nexport declare function text(index: number, value?: any): void;\r\n/**\r\n * Create text node with binding\r\n * Bindings should be handled externally with the proper interpolation(1-8) method\r\n *\r\n * @param index Index of the node in the data array.\r\n * @param value Stringified value to write.\r\n */\r\nexport declare function textBinding<T>(index: number, value: T | NO_CHANGE): void;\r\n/**\r\n * Create a directive and their associated content queries.\r\n *\r\n * NOTE: directives can be created in order other than the index order. They can also\r\n *       be retrieved before they are created in which case the value will be null.\r\n *\r\n * @param directive The directive instance.\r\n * @param directiveDef DirectiveDef object which contains information about the template.\r\n */\r\nexport declare function directiveCreate<T>(directiveDefIdx: number, directive: T, directiveDef: DirectiveDefInternal<T> | ComponentDefInternal<T>): T;\r\n/**\r\n * A lighter version of directiveCreate() that is used for the root component\r\n *\r\n * This version does not contain features that we don't already support at root in\r\n * current Angular. Example: local refs and inputs on root component.\r\n */\r\nexport declare function baseDirectiveCreate<T>(index: number, directive: T, directiveDef: DirectiveDefInternal<T> | ComponentDefInternal<T>, hostNode: LNode): T;\r\n/**\r\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\r\n *\r\n * @param currentView The parent view of the LContainer\r\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\r\n * @returns LContainer\r\n */\r\nexport declare function createLContainer(currentView: LViewData, isForViewContainerRef?: boolean): LContainer;\r\n/**\r\n * Creates an LContainerNode for an ng-template (dynamically-inserted view), e.g.\r\n *\r\n * <ng-template #foo>\r\n *    <div></div>\r\n * </ng-template>\r\n *\r\n * @param index The index of the container in the data array\r\n * @param templateFn Inline template\r\n * @param consts The number of nodes, local refs, and pipes for this template\r\n * @param vars The number of bindings for this template\r\n * @param tagName The name of the container element, if applicable\r\n * @param attrs The attrs attached to the container, if applicable\r\n * @param localRefs A set of local reference bindings on the element.\r\n * @param localRefExtractor A function which extracts local-refs values from the template.\r\n *        Defaults to the current element associated with the local-ref.\r\n */\r\nexport declare function template(index: number, templateFn: ComponentTemplate<any> | null, consts: number, vars: number, tagName?: string | null, attrs?: TAttributes | null, localRefs?: string[] | null, localRefExtractor?: LocalRefExtractor): void;\r\n/**\r\n * Creates an LContainerNode for inline views, e.g.\r\n *\r\n * % if (showing) {\r\n *   <div></div>\r\n * % }\r\n *\r\n * @param index The index of the container in the data array\r\n */\r\nexport declare function container(index: number): void;\r\n/**\r\n * Sets a container up to receive views.\r\n *\r\n * @param index The index of the container in the data array\r\n */\r\nexport declare function containerRefreshStart(index: number): void;\r\n/**\r\n * Marks the end of the LContainerNode.\r\n *\r\n * Marking the end of LContainerNode is the time when to child Views get inserted or removed.\r\n */\r\nexport declare function containerRefreshEnd(): void;\r\n/**\r\n * Marks the start of an embedded view.\r\n *\r\n * @param viewBlockId The ID of this view\r\n * @return boolean Whether or not this view is in creation mode\r\n */\r\nexport declare function embeddedViewStart(viewBlockId: number, consts: number, vars: number): RenderFlags;\r\n/** Marks the end of an embedded view. */\r\nexport declare function embeddedViewEnd(): void;\r\n/**\r\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\r\n *\r\n * @param adjustedElementIndex  Element index in LViewData[] (adjusted for HEADER_OFFSET)\r\n */\r\nexport declare function componentRefresh<T>(adjustedElementIndex: number): void;\r\n/** Returns a boolean for whether the view is attached */\r\nexport declare function viewAttached(view: LViewData): boolean;\r\n/**\r\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\r\n * It takes all the selectors from the entire component's template and decides where\r\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\r\n * backed by a selector).\r\n *\r\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\r\n * un-parsed form.\r\n *\r\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\r\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\r\n *\r\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\r\n * drawbacks:\r\n * - having only a textual form would require runtime parsing of CSS selectors;\r\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\r\n * template author).\r\n *\r\n * @param selectors A collection of parsed CSS selectors\r\n * @param rawSelectors A collection of CSS selectors in the raw, un-parsed form\r\n */\r\nexport declare function projectionDef(selectors?: CssSelectorList[], textSelectors?: string[]): void;\r\n/**\r\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\r\n * to the projectionDef instruction.\r\n *\r\n * @param nodeIndex\r\n * @param selectorIndex:\r\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\r\n *        - 1 based index of the selector from the {@link projectionDef}\r\n */\r\nexport declare function projection(nodeIndex: number, selectorIndex?: number, attrs?: string[]): void;\r\n/**\r\n * Adds LViewData or LContainer to the end of the current view tree.\r\n *\r\n * This structure will be used to traverse through nested views to remove listeners\r\n * and call onDestroy callbacks.\r\n *\r\n * @param currentView The view where LViewData or LContainer should be added\r\n * @param adjustedHostIndex Index of the view's host node in LViewData[], adjusted for header\r\n * @param state The LViewData or LContainer to add to the view tree\r\n * @returns The state passed in\r\n */\r\nexport declare function addToViewTree<T extends LViewData | LContainer>(currentView: LViewData, adjustedHostIndex: number, state: T): T;\r\n/** If node is an OnPush component, marks its LViewData dirty. */\r\nexport declare function markDirtyIfOnPush(node: LElementNode): void;\r\n/**\r\n * Wraps an event listener so its host view and its ancestor views will be marked dirty\r\n * whenever the event fires. Necessary to support OnPush components.\r\n */\r\nexport declare function wrapListenerWithDirtyLogic(view: LViewData, listenerFn: (e?: any) => any): (e: Event) => any;\r\n/**\r\n * Wraps an event listener so its host view and its ancestor views will be marked dirty\r\n * whenever the event fires. Also wraps with preventDefault behavior.\r\n */\r\nexport declare function wrapListenerWithDirtyAndDefault(view: LViewData, listenerFn: (e?: any) => any): EventListener;\r\n/** Marks current view and all ancestors dirty */\r\nexport declare function markViewDirty(view: LViewData): void;\r\n/**\r\n * Used to schedule change detection on the whole application.\r\n *\r\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\r\n * It is usually called indirectly by calling `markDirty` when the view needs to be\r\n * re-rendered.\r\n *\r\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\r\n * `scheduleTick` requests. The scheduling function can be overridden in\r\n * `renderComponent`'s `scheduler` option.\r\n */\r\nexport declare function scheduleTick<T>(rootContext: RootContext): void;\r\n/**\r\n * Used to perform change detection on the whole application.\r\n *\r\n * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\r\n * executes lifecycle hooks and conditionally checks components based on their\r\n * `ChangeDetectionStrategy` and dirtiness.\r\n *\r\n * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\r\n * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\r\n * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\r\n * be changed when calling `renderComponent` and providing the `scheduler` option.\r\n */\r\nexport declare function tick<T>(component: T): void;\r\n/**\r\n * Retrieve the root view from any component by walking the parent `LViewData` until\r\n * reaching the root `LViewData`.\r\n *\r\n * @param component any component\r\n */\r\nexport declare function getRootView(component: any): LViewData;\r\n/**\r\n * Synchronously perform change detection on a component (and possibly its sub-components).\r\n *\r\n * This function triggers change detection in a synchronous way on a component. There should\r\n * be very little reason to call this function directly since a preferred way to do change\r\n * detection is to {@link markDirty} the component and wait for the scheduler to call this method\r\n * at some future point in time. This is because a single user action often results in many\r\n * components being invalidated and calling change detection on each component synchronously\r\n * would be inefficient. It is better to wait until all components are marked as dirty and\r\n * then perform single change detection across all of the components\r\n *\r\n * @param component The component which the change detection should be performed on.\r\n */\r\nexport declare function detectChanges<T>(component: T): void;\r\n/**\r\n * Synchronously perform change detection on a root view and its components.\r\n *\r\n * @param lViewData The view which the change detection should be performed on.\r\n */\r\nexport declare function detectChangesInRootView(lViewData: LViewData): void;\r\n/**\r\n * Checks the change detector and its children, and throws if any changes are detected.\r\n *\r\n * This is used in development mode to verify that running change detection doesn't\r\n * introduce other changes.\r\n */\r\nexport declare function checkNoChanges<T>(component: T): void;\r\n/**\r\n * Checks the change detector on a root view and its components, and throws if any changes are\r\n * detected.\r\n *\r\n * This is used in development mode to verify that running change detection doesn't\r\n * introduce other changes.\r\n *\r\n * @param lViewData The view which the change detection should be checked on.\r\n */\r\nexport declare function checkNoChangesInRootView(lViewData: LViewData): void;\r\n/** Checks the view of the component provided. Does not gate on dirty checks or execute doCheck. */\r\nexport declare function detectChangesInternal<T>(hostView: LViewData, component: T): void;\r\n/**\r\n * Mark the component as dirty (needing change detection).\r\n *\r\n * Marking a component dirty will schedule a change detection on this\r\n * component at some point in the future. Marking an already dirty\r\n * component as dirty is a noop. Only one outstanding change detection\r\n * can be scheduled per component tree. (Two components bootstrapped with\r\n * separate `renderComponent` will have separate schedulers)\r\n *\r\n * When the root component is bootstrapped with `renderComponent`, a scheduler\r\n * can be provided.\r\n *\r\n * @param component Component to mark as dirty.\r\n */\r\nexport declare function markDirty<T>(component: T): void;\r\nexport interface NO_CHANGE {\r\n    brand: 'NO_CHANGE';\r\n}\r\n/** A special value which designates that a value has not changed. */\r\nexport declare const NO_CHANGE: NO_CHANGE;\r\n/**\r\n * Creates a single value binding.\r\n *\r\n * @param value Value to diff\r\n */\r\nexport declare function bind<T>(value: T): T | NO_CHANGE;\r\n/**\r\n * Create interpolation bindings with a variable number of expressions.\r\n *\r\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\r\n * Those are faster because there is no need to create an array of expressions and iterate over it.\r\n *\r\n * `values`:\r\n * - has static text at even indexes,\r\n * - has evaluated expressions at odd indexes.\r\n *\r\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\r\n */\r\nexport declare function interpolationV(values: any[]): string | NO_CHANGE;\r\n/**\r\n * Creates an interpolation binding with 1 expression.\r\n *\r\n * @param prefix static value used for concatenation only.\r\n * @param v0 value checked for change.\r\n * @param suffix static value used for concatenation only.\r\n */\r\nexport declare function interpolation1(prefix: string, v0: any, suffix: string): string | NO_CHANGE;\r\n/** Creates an interpolation binding with 2 expressions. */\r\nexport declare function interpolation2(prefix: string, v0: any, i0: string, v1: any, suffix: string): string | NO_CHANGE;\r\n/** Creates an interpolation binding with 3 expressions. */\r\nexport declare function interpolation3(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): string | NO_CHANGE;\r\n/** Create an interpolation binding with 4 expressions. */\r\nexport declare function interpolation4(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, suffix: string): string | NO_CHANGE;\r\n/** Creates an interpolation binding with 5 expressions. */\r\nexport declare function interpolation5(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, suffix: string): string | NO_CHANGE;\r\n/** Creates an interpolation binding with 6 expressions. */\r\nexport declare function interpolation6(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string): string | NO_CHANGE;\r\n/** Creates an interpolation binding with 7 expressions. */\r\nexport declare function interpolation7(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string | NO_CHANGE;\r\n/** Creates an interpolation binding with 8 expressions. */\r\nexport declare function interpolation8(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any, suffix: string): string | NO_CHANGE;\r\n/** Store a value in the `data` at a given `index`. */\r\nexport declare function store<T>(index: number, value: T): void;\r\n/**\r\n * Retrieves a local reference from the current contextViewData.\r\n *\r\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\r\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\r\n *\r\n * @param index The index of the local ref in contextViewData.\r\n */\r\nexport declare function reference<T>(index: number): T;\r\n/** Retrieves a value from the `directives` array. */\r\nexport declare function loadDirective<T>(index: number): T;\r\nexport declare function loadQueryList<T>(queryListIdx: number): QueryList<T>;\r\n/** Retrieves a value from current `viewData`. */\r\nexport declare function load<T>(index: number): T;\r\nexport declare function loadElement(index: number): LElementNode;\r\nexport declare function getTNode(index: number): TNode;\r\n/** Gets the current binding value. */\r\nexport declare function getBinding(bindingIndex: number): any;\r\n/** Updates binding if changed, then returns whether it was updated. */\r\nexport declare function bindingUpdated(bindingIndex: number, value: any): boolean;\r\n/** Updates binding and returns the value. */\r\nexport declare function updateBinding(bindingIndex: number, value: any): any;\r\n/** Updates 2 bindings if changed, then returns whether either was updated. */\r\nexport declare function bindingUpdated2(bindingIndex: number, exp1: any, exp2: any): boolean;\r\n/** Updates 3 bindings if changed, then returns whether any was updated. */\r\nexport declare function bindingUpdated3(bindingIndex: number, exp1: any, exp2: any, exp3: any): boolean;\r\n/** Updates 4 bindings if changed, then returns whether any was updated. */\r\nexport declare function bindingUpdated4(bindingIndex: number, exp1: any, exp2: any, exp3: any, exp4: any): boolean;\r\nexport declare function getTView(): TView;\r\n/**\r\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\r\n * refresh).\r\n */\r\nexport declare function registerContentQuery<Q>(queryList: QueryList<Q>): void;\r\nexport declare function assertPreviousIsParent(): void;\r\nexport declare function _getComponentHostLElementNode(component: any): LElementNode;\r\nexport declare const CLEAN_PROMISE: Promise<any>;\r\n",
  "/node_modules/@angular/core/src/render3/interfaces/container.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { LElementNode } from './node';\r\nimport { LQueries } from './query';\r\nimport { LViewData, NEXT, PARENT, QUERIES } from './view';\r\n/**\r\n * Below are constants for LContainer indices to help us look up LContainer members\r\n * without having to remember the specific indices.\r\n * Uglify will inline these when minifying so there shouldn't be a cost.\r\n */\r\nexport declare const ACTIVE_INDEX = 0;\r\nexport declare const VIEWS = 4;\r\nexport declare const RENDER_PARENT = 5;\r\n/**\r\n * The state associated with an LContainerNode.\r\n *\r\n * This is an array so that its structure is closer to LViewData. This helps\r\n * when traversing the view tree (which is a mix of containers and component\r\n * views), so we can jump to viewOrContainer[NEXT] in the same way regardless\r\n * of type.\r\n */\r\nexport interface LContainer extends Array<any> {\r\n    /**\r\n     * The next active index in the views array to read or write to. This helps us\r\n     * keep track of where we are in the views array.\r\n     * In the case the LContainer is created for a ViewContainerRef,\r\n     * it is set to null to identify this scenario, as indices are \"absolute\" in that case,\r\n     * i.e. provided directly by the user of the ViewContainerRef API.\r\n     */\r\n    [ACTIVE_INDEX]: number | null;\r\n    /**\r\n     * Access to the parent view is necessary so we can propagate back\r\n     * up from inside a container to parent[NEXT].\r\n     */\r\n    [PARENT]: LViewData | null;\r\n    /**\r\n     * This allows us to jump from a container to a sibling container or component\r\n     * view with the same parent, so we can remove listeners efficiently.\r\n     */\r\n    [NEXT]: LViewData | LContainer | null;\r\n    /**\r\n     * Queries active for this container - all the views inserted to / removed from\r\n     * this container are reported to queries referenced here.\r\n     */\r\n    [QUERIES]: LQueries | null;\r\n    /**\r\n     * A list of the container's currently active child views. Views will be inserted\r\n     * here as they are added and spliced from here when they are removed. We need\r\n     * to keep a record of current views so we know which views are already in the DOM\r\n     * (and don't need to be re-added) and so we can remove views from the DOM when they\r\n     * are no longer required.\r\n     */\r\n    [VIEWS]: LViewData[];\r\n    /**\r\n     * Parent Element which will contain the location where all of the Views will be\r\n     * inserted into to.\r\n     *\r\n     * If `renderParent` is `null` it is headless. This means that it is contained\r\n     * in another `LViewNode` which in turn is contained in another `LContainerNode` and\r\n     * therefore it does not yet have its own parent.\r\n     *\r\n     * If `renderParent` is not `null` then it may be:\r\n     * - same as `LContainerNode.parent` in which case it is just a normal container.\r\n     * - different from `LContainerNode.parent` in which case it has been re-projected.\r\n     *   In other words `LContainerNode.parent` is logical parent where as\r\n     *   `LContainer.projectedParent` is render parent.\r\n     *\r\n     * When views are inserted into `LContainerNode` then `renderParent` is:\r\n     * - `null`, we are in `LViewNode` keep going up a hierarchy until actual\r\n     *   `renderParent` is found.\r\n     * - not `null`, then use the `projectedParent.native` as the `RElement` to insert\r\n     *   `LViewNode`s into.\r\n     */\r\n    [RENDER_PARENT]: LElementNode | null;\r\n}\r\nexport declare const unusedValueExportToPlacateAjd = 1;\r\n",
  "/node_modules/@angular/core/src/render3/interfaces/definition.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Provider, ViewEncapsulation } from '../../core';\r\nimport { Type } from '../../type';\r\nimport { CssSelectorList } from './projection';\r\n/**\r\n * Definition of what a template rendering function should look like for a component.\r\n */\r\nexport declare type ComponentTemplate<T> = {\r\n    (rf: RenderFlags, ctx: T): void;\r\n    ngPrivateData?: never;\r\n};\r\n/**\r\n * Definition of what a query function should look like.\r\n */\r\nexport declare type ComponentQuery<T> = ComponentTemplate<T>;\r\n/**\r\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\r\n * should be executed.\r\n *\r\n * Typically, a template runs both the creation block and the update block on initialization and\r\n * subsequent runs only execute the update block. However, dynamically created views require that\r\n * the creation block be executed separately from the update block (for backwards compat).\r\n */\r\nexport declare const enum RenderFlags {\r\n    Create = 1,\r\n    Update = 2\r\n}\r\n/**\r\n * A subclass of `Type` which has a static `ngComponentDef`:`ComponentDef` field making it\r\n * consumable for rendering.\r\n */\r\nexport interface ComponentType<T> extends Type<T> {\r\n    ngComponentDef: never;\r\n}\r\n/**\r\n * A subclass of `Type` which has a static `ngDirectiveDef`:`DirectiveDef` field making it\r\n * consumable for rendering.\r\n */\r\nexport interface DirectiveType<T> extends Type<T> {\r\n    ngDirectiveDef: never;\r\n}\r\nexport declare const enum DirectiveDefFlags {\r\n    ContentQuery = 2\r\n}\r\n/**\r\n * A subclass of `Type` which has a static `ngPipeDef`:`PipeDef` field making it\r\n * consumable for rendering.\r\n */\r\nexport interface PipeType<T> extends Type<T> {\r\n    ngPipeDef: never;\r\n}\r\n/**\r\n * A version of {@link DirectiveDef} that represents the runtime type shape only, and excludes\r\n * metadata parameters.\r\n */\r\nexport declare type DirectiveDefInternal<T> = DirectiveDef<T, string>;\r\n/**\r\n * Runtime information for classes that are inherited by components or directives\r\n * that aren't defined as components or directives.\r\n *\r\n * This is an internal data structure used by the render to determine what inputs\r\n * and outputs should be inherited.\r\n *\r\n * See: {@link defineBase}\r\n */\r\nexport interface BaseDef<T> {\r\n    /**\r\n     * A dictionary mapping the inputs' minified property names to their public API names, which\r\n     * are their aliases if any, or their original unminified property names\r\n     * (as in `@Input('alias') propertyName: any;`).\r\n     */\r\n    readonly inputs: {\r\n        [P in keyof T]: string;\r\n    };\r\n    /**\r\n     * @deprecated This is only here because `NgOnChanges` incorrectly uses declared name instead of\r\n     * public or minified name.\r\n     */\r\n    readonly declaredInputs: {\r\n        [P in keyof T]: P;\r\n    };\r\n    /**\r\n     * A dictionary mapping the outputs' minified property names to their public API names, which\r\n     * are their aliases if any, or their original unminified property names\r\n     * (as in `@Output('alias') propertyName: any;`).\r\n     */\r\n    readonly outputs: {\r\n        [P in keyof T]: P;\r\n    };\r\n}\r\n/**\r\n * Runtime link information for Directives.\r\n *\r\n * This is internal data structure used by the render to link\r\n * directives into templates.\r\n *\r\n * NOTE: Always use `defineDirective` function to create this object,\r\n * never create the object directly since the shape of this object\r\n * can change between versions.\r\n *\r\n * @param Selector type metadata specifying the selector of the directive or component\r\n *\r\n * See: {@link defineDirective}\r\n */\r\nexport interface DirectiveDef<T, Selector extends string> extends BaseDef<T> {\r\n    /** Token representing the directive. Used by DI. */\r\n    type: Type<T>;\r\n    /** Function that makes a directive public to the DI system. */\r\n    diPublic: ((def: DirectiveDef<T, string>) => void) | null;\r\n    /** The selectors that will be used to match nodes to this directive. */\r\n    selectors: CssSelectorList;\r\n    /**\r\n     * Name under which the directive is exported (for use with local references in template)\r\n     */\r\n    readonly exportAs: string | null;\r\n    /**\r\n     * Factory function used to create a new directive instance.\r\n     */\r\n    factory(): T;\r\n    /**\r\n     * Function to create instances of content queries associated with a given directive.\r\n     */\r\n    contentQueries: (() => void) | null;\r\n    /** Refreshes content queries associated with directives in a given view */\r\n    contentQueriesRefresh: ((directiveIndex: number, queryIndex: number) => void) | null;\r\n    /**\r\n     * The number of host bindings (including pure fn bindings) in this directive/component.\r\n     *\r\n     * Used to calculate the length of the LViewData array for the *parent* component\r\n     * of this directive/component.\r\n     */\r\n    hostVars: number;\r\n    /** Refreshes host bindings on the associated directive. */\r\n    hostBindings: ((directiveIndex: number, elementIndex: number) => void) | null;\r\n    /**\r\n     * Static attributes to set on host element.\r\n     *\r\n     * Even indices: attribute name\r\n     * Odd indices: attribute value\r\n     */\r\n    attributes: string[] | null;\r\n    onInit: (() => void) | null;\r\n    doCheck: (() => void) | null;\r\n    afterContentInit: (() => void) | null;\r\n    afterContentChecked: (() => void) | null;\r\n    afterViewInit: (() => void) | null;\r\n    afterViewChecked: (() => void) | null;\r\n    onDestroy: (() => void) | null;\r\n    /**\r\n     * The features applied to this directive\r\n     */\r\n    features: DirectiveDefFeature[] | null;\r\n}\r\n/**\r\n * A version of {@link ComponentDef} that represents the runtime type shape only, and excludes\r\n * metadata parameters.\r\n */\r\nexport declare type ComponentDefInternal<T> = ComponentDef<T, string>;\r\n/**\r\n * Runtime link information for Components.\r\n *\r\n * This is internal data structure used by the render to link\r\n * components into templates.\r\n *\r\n * NOTE: Always use `defineComponent` function to create this object,\r\n * never create the object directly since the shape of this object\r\n * can change between versions.\r\n *\r\n * See: {@link defineComponent}\r\n */\r\nexport interface ComponentDef<T, Selector extends string> extends DirectiveDef<T, Selector> {\r\n    /**\r\n     * Runtime unique component ID.\r\n     */\r\n    id: string;\r\n    /**\r\n     * The View template of the component.\r\n     */\r\n    readonly template: ComponentTemplate<T>;\r\n    /**\r\n     * A set of styles that the component needs to be present for component to render correctly.\r\n     */\r\n    readonly styles: string[];\r\n    /**\r\n     * The number of nodes, local refs, and pipes in this component template.\r\n     *\r\n     * Used to calculate the length of the component's LViewData array, so we\r\n     * can pre-fill the array and set the binding start index.\r\n     */\r\n    consts: number;\r\n    /**\r\n     * The number of bindings in this component template (including pure fn bindings).\r\n     *\r\n     * Used to calculate the length of the component's LViewData array, so we\r\n     * can pre-fill the array and set the host binding start index.\r\n     */\r\n    vars: number;\r\n    /**\r\n     * Query-related instructions for a component.\r\n     */\r\n    viewQuery: ComponentQuery<T> | null;\r\n    /**\r\n     * The view encapsulation type, which determines how styles are applied to\r\n     * DOM elements. One of\r\n     * - `Emulated` (default): Emulate native scoping of styles.\r\n     * - `Native`: Use the native encapsulation mechanism of the renderer.\r\n     * - `ShadowDom`: Use modern [ShadowDOM](https://w3c.github.io/webcomponents/spec/shadow/) and\r\n     *   create a ShadowRoot for component's host element.\r\n     * - `None`: Do not provide any template or style encapsulation.\r\n     */\r\n    readonly encapsulation: ViewEncapsulation;\r\n    /**\r\n     * Defines arbitrary developer-defined data to be stored on a renderer instance.\r\n     * This is useful for renderers that delegate to other renderers.\r\n     */\r\n    readonly data: {\r\n        [kind: string]: any;\r\n    };\r\n    /** Whether or not this component's ChangeDetectionStrategy is OnPush */\r\n    readonly onPush: boolean;\r\n    /**\r\n     * Defines the set of injectable providers that are visible to a Directive and its content DOM\r\n     * children.\r\n     */\r\n    readonly providers: Provider[] | null;\r\n    /**\r\n     * Defines the set of injectable providers that are visible to a Directive and its view DOM\r\n     * children only.\r\n     */\r\n    readonly viewProviders: Provider[] | null;\r\n    /**\r\n     * Registry of directives and components that may be found in this view.\r\n     *\r\n     * The property is either an array of `DirectiveDef`s or a function which returns the array of\r\n     * `DirectiveDef`s. The function is necessary to be able to support forward declarations.\r\n     */\r\n    directiveDefs: DirectiveDefListOrFactory | null;\r\n    /**\r\n     * Registry of pipes that may be found in this view.\r\n     *\r\n     * The property is either an array of `PipeDefs`s or a function which returns the array of\r\n     * `PipeDefs`s. The function is necessary to be able to support forward declarations.\r\n     */\r\n    pipeDefs: PipeDefListOrFactory | null;\r\n}\r\n/**\r\n * Runtime link information for Pipes.\r\n *\r\n * This is internal data structure used by the renderer to link\r\n * pipes into templates.\r\n *\r\n * NOTE: Always use `definePipe` function to create this object,\r\n * never create the object directly since the shape of this object\r\n * can change between versions.\r\n *\r\n * See: {@link definePipe}\r\n */\r\nexport interface PipeDef<T, S extends string> {\r\n    /**\r\n     * Pipe name.\r\n     *\r\n     * Used to resolve pipe in templates.\r\n     */\r\n    name: S;\r\n    /**\r\n     * Factory function used to create a new pipe instance.\r\n     */\r\n    factory: () => T;\r\n    /**\r\n     * Whether or not the pipe is pure.\r\n     *\r\n     * Pure pipes result only depends on the pipe input and not on internal\r\n     * state of the pipe.\r\n     */\r\n    pure: boolean;\r\n    onDestroy: (() => void) | null;\r\n}\r\nexport declare type PipeDefInternal<T> = PipeDef<T, string>;\r\nexport declare type DirectiveDefFeature = <T>(directiveDef: DirectiveDef<T, string>) => void;\r\nexport declare type ComponentDefFeature = <T>(componentDef: ComponentDef<T, string>) => void;\r\n/**\r\n * Type used for directiveDefs on component definition.\r\n *\r\n * The function is necessary to be able to support forward declarations.\r\n */\r\nexport declare type DirectiveDefListOrFactory = (() => DirectiveDefList) | DirectiveDefList;\r\nexport declare type DirectiveDefList = (DirectiveDef<any, string> | ComponentDef<any, string>)[];\r\nexport declare type DirectiveTypesOrFactory = (() => DirectiveTypeList) | DirectiveTypeList;\r\nexport declare type DirectiveTypeList = (DirectiveDef<any, string> | ComponentDef<any, string> | Type<any>)[];\r\n/**\r\n * Type used for PipeDefs on component definition.\r\n *\r\n * The function is necessary to be able to support forward declarations.\r\n */\r\nexport declare type PipeDefListOrFactory = (() => PipeDefList) | PipeDefList;\r\nexport declare type PipeDefList = PipeDefInternal<any>[];\r\nexport declare type PipeTypesOrFactory = (() => DirectiveTypeList) | DirectiveTypeList;\r\nexport declare type PipeTypeList = (PipeDefInternal<any> | Type<any>)[];\r\nexport declare const unusedValueExportToPlacateAjd = 1;\r\nexport declare const enum InitialStylingFlags {\r\n    VALUES_MODE = 1\r\n}\r\n",
  "/node_modules/@angular/core/src/render3/interfaces/injector.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ChangeDetectorRef } from '../../change_detection/change_detector_ref';\r\nimport { ElementRef } from '../../linker/element_ref';\r\nimport { TemplateRef } from '../../linker/template_ref';\r\nimport { ViewContainerRef } from '../../linker/view_container_ref';\r\nimport { LContainerNode, LElementContainerNode, LElementNode, TNode } from './node';\r\nexport interface LInjector {\r\n    /**\r\n     * We need to store a reference to the injector's parent so DI can keep looking up\r\n     * the injector tree until it finds the dependency it's looking for.\r\n     */\r\n    readonly parent: LInjector | null;\r\n    /**\r\n     * Allows access to the directives array in that node's static data and to\r\n     * the node's flags (for starting directive index and directive size). Necessary\r\n     * for DI to retrieve a directive from the data array if injector indicates\r\n     * it is there.\r\n     */\r\n    readonly node: LElementNode | LElementContainerNode | LContainerNode;\r\n    readonly tNode: TNode;\r\n    /**\r\n     * The following bloom filter determines whether a directive is available\r\n     * on the associated node or not. This prevents us from searching the directives\r\n     * array at this level unless it's probable the directive is in it.\r\n     *\r\n     * - bf0: Check directive IDs 0-31  (IDs are % 128)\r\n     * - bf1: Check directive IDs 32-63\r\n     * - bf2: Check directive IDs 64-95\r\n     * - bf3: Check directive IDs 96-127\r\n     * - bf4: Check directive IDs 128-159\r\n     * - bf5: Check directive IDs 160 - 191\r\n     * - bf6: Check directive IDs 192 - 223\r\n     * - bf7: Check directive IDs 224 - 255\r\n     *\r\n     * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\r\n     */\r\n    bf0: number;\r\n    bf1: number;\r\n    bf2: number;\r\n    bf3: number;\r\n    bf4: number;\r\n    bf5: number;\r\n    bf6: number;\r\n    bf7: number;\r\n    /**\r\n     * cbf0 - cbf7 properties determine whether a directive is available through a\r\n     * parent injector. They refer to the merged values of parent bloom filters. This\r\n     * allows us to skip looking up the chain unless it's probable that directive exists\r\n     * up the chain.\r\n     */\r\n    cbf0: number;\r\n    cbf1: number;\r\n    cbf2: number;\r\n    cbf3: number;\r\n    cbf4: number;\r\n    cbf5: number;\r\n    cbf6: number;\r\n    cbf7: number;\r\n    /** Stores the TemplateRef so subsequent injections of the TemplateRef get the same instance. */\r\n    templateRef: TemplateRef<any> | null;\r\n    /** Stores the ViewContainerRef so subsequent injections of the ViewContainerRef get the same\r\n     * instance. */\r\n    viewContainerRef: ViewContainerRef | null;\r\n    /** Stores the ElementRef so subsequent injections of the ElementRef get the same instance. */\r\n    elementRef: ElementRef | null;\r\n    /**\r\n     * Stores the ChangeDetectorRef so subsequent injections of the ChangeDetectorRef get the\r\n     * same instance.\r\n     */\r\n    changeDetectorRef: ChangeDetectorRef | null;\r\n}\r\nexport declare const unusedValueExportToPlacateAjd = 1;\r\n",
  "/node_modules/@angular/core/src/render3/interfaces/node.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { StylingContext } from '../styling';\r\nimport { LContainer } from './container';\r\nimport { LInjector } from './injector';\r\nimport { RComment, RElement, RText } from './renderer';\r\nimport { LViewData, TView } from './view';\r\n/**\r\n * TNodeType corresponds to the TNode.type property. It contains information\r\n * on how to map a particular set of bits in LNode.flags to the node type.\r\n */\r\nexport declare const enum TNodeType {\r\n    Container = 0,\r\n    Projection = 1,\r\n    View = 2,\r\n    Element = 3,\r\n    ViewOrElement = 2,\r\n    ElementContainer = 4\r\n}\r\n/**\r\n * Corresponds to the TNode.flags property.\r\n */\r\nexport declare const enum TNodeFlags {\r\n    /** The number of directives on this node is encoded on the least significant bits */\r\n    DirectiveCountMask = 4095,\r\n    /** This bit is set if the node is a component */\r\n    isComponent = 4096,\r\n    /** This bit is set if the node has been projected */\r\n    isProjected = 8192,\r\n    /** This bit is set if the node has any content queries */\r\n    hasContentQuery = 16384,\r\n    /** The index of the first directive on this node is encoded on the most significant bits  */\r\n    DirectiveStartingIndexShift = 15\r\n}\r\n/**\r\n * LNode is an internal data structure which is used for the incremental DOM algorithm.\r\n * The \"L\" stands for \"Logical\" to differentiate between `RNodes` (actual rendered DOM\r\n * node) and our logical representation of DOM nodes, `LNodes`.\r\n *\r\n * The data structure is optimized for speed and size.\r\n *\r\n * In order to be fast, all subtypes of `LNode` should have the same shape.\r\n * Because size of the `LNode` matters, many fields have multiple roles depending\r\n * on the `LNode` subtype.\r\n *\r\n * See: https://en.wikipedia.org/wiki/Inline_caching#Monomorphic_inline_caching\r\n *\r\n * NOTE: This is a private data structure and should not be exported by any of the\r\n * instructions.\r\n */\r\nexport interface LNode {\r\n    /**\r\n     * The associated DOM node. Storing this allows us to:\r\n     *  - append children to their element parents in the DOM (e.g. `parent.native.appendChild(...)`)\r\n     *  - retrieve the sibling elements of text nodes whose creation / insertion has been delayed\r\n     */\r\n    readonly native: RComment | RElement | RText | null;\r\n    /**\r\n     * If regular LElementNode, LTextNode, and LProjectionNode then `data` will be null.\r\n     * If LElementNode with component, then `data` contains LViewData.\r\n     * If LViewNode, then `data` contains the LViewData.\r\n     * If LContainerNode, then `data` contains LContainer.\r\n     */\r\n    readonly data: LViewData | LContainer | null;\r\n    /**\r\n     * Each node belongs to a view.\r\n     *\r\n     * When the injector is walking up a tree, it needs access to the `directives` (part of view).\r\n     */\r\n    readonly view: LViewData;\r\n    /** The injector associated with this node. Necessary for DI. */\r\n    nodeInjector: LInjector | null;\r\n    /**\r\n     * A pointer to an LContainerNode created by directives requesting ViewContainerRef\r\n     */\r\n    dynamicLContainerNode: LContainerNode | null;\r\n}\r\n/** LNode representing an element. */\r\nexport interface LElementNode extends LNode {\r\n    /** The DOM element associated with this node. */\r\n    readonly native: RElement;\r\n    /** If Component then data has LView (light DOM) */\r\n    readonly data: LViewData | null;\r\n}\r\n/** LNode representing <ng-container>. */\r\nexport interface LElementContainerNode extends LNode {\r\n    /** The DOM comment associated with this node. */\r\n    readonly native: RComment;\r\n    readonly data: null;\r\n}\r\n/** LNode representing a #text node. */\r\nexport interface LTextNode extends LNode {\r\n    /** The text node associated with this node. */\r\n    native: RText;\r\n    readonly data: null;\r\n    dynamicLContainerNode: null;\r\n}\r\n/** Abstract node which contains root nodes of a view. */\r\nexport interface LViewNode extends LNode {\r\n    readonly native: null;\r\n    readonly data: LViewData;\r\n    dynamicLContainerNode: null;\r\n}\r\n/** Abstract node container which contains other views. */\r\nexport interface LContainerNode extends LNode {\r\n    native: RComment;\r\n    readonly data: LContainer;\r\n}\r\nexport interface LProjectionNode extends LNode {\r\n    readonly native: null;\r\n    readonly data: null;\r\n    dynamicLContainerNode: null;\r\n}\r\n/**\r\n * A set of marker values to be used in the attributes arrays. Those markers indicate that some\r\n * items are not regular attributes and the processing should be adapted accordingly.\r\n */\r\nexport declare const enum AttributeMarker {\r\n    /**\r\n     * Marker indicates that the following 3 values in the attributes array are:\r\n     * namespaceUri, attributeName, attributeValue\r\n     * in that order.\r\n     */\r\n    NamespaceURI = 0,\r\n    /**\r\n     * This marker indicates that the following attribute names were extracted from bindings (ex.:\r\n     * [foo]=\"exp\") and / or event handlers (ex. (bar)=\"doSth()\").\r\n     * Taking the above bindings and outputs as an example an attributes array could look as follows:\r\n     * ['class', 'fade in', AttributeMarker.SelectOnly, 'foo', 'bar']\r\n     */\r\n    SelectOnly = 1\r\n}\r\n/**\r\n * A combination of:\r\n * - attribute names and values\r\n * - special markers acting as flags to alter attributes processing.\r\n */\r\nexport declare type TAttributes = (string | AttributeMarker)[];\r\n/**\r\n * LNode binding data (flyweight) for a particular node that is shared between all templates\r\n * of a specific type.\r\n *\r\n * If a property is:\r\n *    - PropertyAliases: that property's data was generated and this is it\r\n *    - Null: that property's data was already generated and nothing was found.\r\n *    - Undefined: that property's data has not yet been generated\r\n *\r\n * see: https://en.wikipedia.org/wiki/Flyweight_pattern for more on the Flyweight pattern\r\n */\r\nexport interface TNode {\r\n    /** The type of the TNode. See TNodeType. */\r\n    type: TNodeType;\r\n    /**\r\n     * Index of the TNode in TView.data and corresponding LNode in LView.data.\r\n     *\r\n     * This is necessary to get from any TNode to its corresponding LNode when\r\n     * traversing the node tree.\r\n     *\r\n     * If index is -1, this is a dynamically created container node or embedded view node.\r\n     */\r\n    index: number;\r\n    /**\r\n     * This number stores two values using its bits:\r\n     *\r\n     * - the number of directives on that node (first 12 bits)\r\n     * - the starting index of the node's directives in the directives array (last 20 bits).\r\n     *\r\n     * These two values are necessary so DI can effectively search the directives associated\r\n     * with a node without searching the whole directives array.\r\n     */\r\n    flags: TNodeFlags;\r\n    /** The tag name associated with this node. */\r\n    tagName: string | null;\r\n    /**\r\n     * Attributes associated with an element. We need to store attributes to support various use-cases\r\n     * (attribute injection, content projection with selectors, directives matching).\r\n     * Attributes are stored statically because reading them from the DOM would be way too slow for\r\n     * content projection and queries.\r\n     *\r\n     * Since attrs will always be calculated first, they will never need to be marked undefined by\r\n     * other instructions.\r\n     *\r\n     * For regular attributes a name of an attribute and its value alternate in the array.\r\n     * e.g. ['role', 'checkbox']\r\n     * This array can contain flags that will indicate \"special attributes\" (attributes with\r\n     * namespaces, attributes extracted from bindings and outputs).\r\n     */\r\n    attrs: TAttributes | null;\r\n    /**\r\n     * A set of local names under which a given element is exported in a template and\r\n     * visible to queries. An entry in this array can be created for different reasons:\r\n     * - an element itself is referenced, ex.: `<div #foo>`\r\n     * - a component is referenced, ex.: `<my-cmpt #foo>`\r\n     * - a directive is referenced, ex.: `<my-cmpt #foo=\"directiveExportAs\">`.\r\n     *\r\n     * A given element might have different local names and those names can be associated\r\n     * with a directive. We store local names at even indexes while odd indexes are reserved\r\n     * for directive index in a view (or `-1` if there is no associated directive).\r\n     *\r\n     * Some examples:\r\n     * - `<div #foo>` => `[\"foo\", -1]`\r\n     * - `<my-cmpt #foo>` => `[\"foo\", myCmptIdx]`\r\n     * - `<my-cmpt #foo #bar=\"directiveExportAs\">` => `[\"foo\", myCmptIdx, \"bar\", directiveIdx]`\r\n     * - `<div #foo #bar=\"directiveExportAs\">` => `[\"foo\", -1, \"bar\", directiveIdx]`\r\n     */\r\n    localNames: (string | number)[] | null;\r\n    /** Information about input properties that need to be set once from attribute data. */\r\n    initialInputs: InitialInputData | null | undefined;\r\n    /**\r\n     * Input data for all directives on this node.\r\n     *\r\n     * - `undefined` means that the prop has not been initialized yet,\r\n     * - `null` means that the prop has been initialized but no inputs have been found.\r\n     */\r\n    inputs: PropertyAliases | null | undefined;\r\n    /**\r\n     * Output data for all directives on this node.\r\n     *\r\n     * - `undefined` means that the prop has not been initialized yet,\r\n     * - `null` means that the prop has been initialized but no outputs have been found.\r\n     */\r\n    outputs: PropertyAliases | null | undefined;\r\n    /**\r\n     * The TView or TViews attached to this node.\r\n     *\r\n     * If this TNode corresponds to an LContainerNode with inline views, the container will\r\n     * need to store separate static data for each of its view blocks (TView[]). Otherwise,\r\n     * nodes in inline views with the same index as nodes in their parent views will overwrite\r\n     * each other, as they are in the same template.\r\n     *\r\n     * Each index in this array corresponds to the static data for a certain\r\n     * view. So if you had V(0) and V(1) in a container, you might have:\r\n     *\r\n     * [\r\n     *   [{tagName: 'div', attrs: ...}, null],     // V(0) TView\r\n     *   [{tagName: 'button', attrs ...}, null]    // V(1) TView\r\n     *\r\n     * If this TNode corresponds to an LContainerNode with a template (e.g. structural\r\n     * directive), the template's TView will be stored here.\r\n     *\r\n     * If this TNode corresponds to an LElementNode, tViews will be null .\r\n     */\r\n    tViews: TView | TView[] | null;\r\n    /**\r\n     * The next sibling node. Necessary so we can propagate through the root nodes of a view\r\n     * to insert them or remove them from the DOM.\r\n     */\r\n    next: TNode | null;\r\n    /**\r\n     * First child of the current node.\r\n     *\r\n     * For component nodes, the child will always be a ContentChild (in same view).\r\n     * For embedded view nodes, the child will be in their child view.\r\n     */\r\n    child: TNode | null;\r\n    /**\r\n     * Parent node (in the same view only).\r\n     *\r\n     * We need a reference to a node's parent so we can append the node to its parent's native\r\n     * element at the appropriate time.\r\n     *\r\n     * If the parent would be in a different view (e.g. component host), this property will be null.\r\n     * It's important that we don't try to cross component boundaries when retrieving the parent\r\n     * because the parent will change (e.g. index, attrs) depending on where the component was\r\n     * used (and thus shouldn't be stored on TNode). In these cases, we retrieve the parent through\r\n     * LView.node instead (which will be instance-specific).\r\n     *\r\n     * If this is an inline view node (V), the parent will be its container.\r\n     */\r\n    parent: TElementNode | TContainerNode | null;\r\n    /**\r\n     * A pointer to a TContainerNode created by directives requesting ViewContainerRef\r\n     */\r\n    dynamicContainerNode: TNode | null;\r\n    /**\r\n     * If this node is part of an i18n block, it indicates whether this container is part of the DOM\r\n     * If this node is not part of an i18n block, this field is null.\r\n     */\r\n    detached: boolean | null;\r\n    stylingTemplate: StylingContext | null;\r\n    /**\r\n     * List of projected TNodes for a given component host element OR index into the said nodes.\r\n     *\r\n     * For easier discussion assume this example:\r\n     * `<parent>`'s view definition:\r\n     * ```\r\n     * <child id=\"c1\">content1</child>\r\n     * <child id=\"c2\"><span>content2</span></child>\r\n     * ```\r\n     * `<child>`'s view definition:\r\n     * ```\r\n     * <ng-content id=\"cont1\"></ng-content>\r\n     * ```\r\n     *\r\n     * If `Array.isArray(projection)` then `TNode` is a host element:\r\n     * - `projection` stores the content nodes which are to be projected.\r\n     *    - The nodes represent categories defined by the selector: For example:\r\n     *      `<ng-content/><ng-content select=\"abc\"/>` would represent the heads for `<ng-content/>`\r\n     *      and `<ng-content select=\"abc\"/>` respectively.\r\n     *    - The nodes we store in `projection` are heads only, we used `.next` to get their\r\n     *      siblings.\r\n     *    - The nodes `.next` is sorted/rewritten as part of the projection setup.\r\n     *    - `projection` size is equal to the number of projections `<ng-content>`. The size of\r\n     *      `c1` will be `1` because `<child>` has only one `<ng-content>`.\r\n     * - we store `projection` with the host (`c1`, `c2`) rather than the `<ng-content>` (`cont1`)\r\n     *   because the same component (`<child>`) can be used in multiple locations (`c1`, `c2`) and as\r\n     *   a result have different set of nodes to project.\r\n     * - without `projection` it would be difficult to efficiently traverse nodes to be projected.\r\n     *\r\n     * If `typeof projection == 'number'` then `TNode` is a `<ng-content>` element:\r\n     * - `projection` is an index of the host's `projection`Nodes.\r\n     *   - This would return the first head node to project:\r\n     *     `getHost(currentTNode).projection[currentTNode.projection]`.\r\n     * - When projecting nodes the parent node retrieved may be a `<ng-content>` node, in which case\r\n     *   the process is recursive in nature (not implementation).\r\n     */\r\n    projection: (TNode | null)[] | number | null;\r\n}\r\n/** Static data for an LElementNode  */\r\nexport interface TElementNode extends TNode {\r\n    /** Index in the data[] array */\r\n    index: number;\r\n    child: TElementNode | TTextNode | TElementContainerNode | TContainerNode | TProjectionNode | null;\r\n    /**\r\n     * Element nodes will have parents unless they are the first node of a component or\r\n     * embedded view (which means their parent is in a different view and must be\r\n     * retrieved using viewData[HOST_NODE]).\r\n     */\r\n    parent: TElementNode | TElementContainerNode | null;\r\n    tViews: null;\r\n    /**\r\n     * If this is a component TNode with projection, this will be an array of projected\r\n     * TNodes (see TNode.projection for more info). If it's a regular element node or a\r\n     * component without projection, it will be null.\r\n     */\r\n    projection: (TNode | null)[] | null;\r\n}\r\n/** Static data for an LTextNode  */\r\nexport interface TTextNode extends TNode {\r\n    /** Index in the data[] array */\r\n    index: number;\r\n    child: null;\r\n    /**\r\n     * Text nodes will have parents unless they are the first node of a component or\r\n     * embedded view (which means their parent is in a different view and must be\r\n     * retrieved using LView.node).\r\n     */\r\n    parent: TElementNode | TElementContainerNode | null;\r\n    tViews: null;\r\n    projection: null;\r\n}\r\n/** Static data for an LContainerNode */\r\nexport interface TContainerNode extends TNode {\r\n    /**\r\n     * Index in the data[] array.\r\n     *\r\n     * If it's -1, this is a dynamically created container node that isn't stored in\r\n     * data[] (e.g. when you inject ViewContainerRef) .\r\n     */\r\n    index: number;\r\n    child: null;\r\n    /**\r\n     * Container nodes will have parents unless:\r\n     *\r\n     * - They are the first node of a component or embedded view\r\n     * - They are dynamically created\r\n     */\r\n    parent: TElementNode | TElementContainerNode | null;\r\n    tViews: TView | TView[] | null;\r\n    projection: null;\r\n}\r\n/** Static data for an LElementContainerNode */\r\nexport interface TElementContainerNode extends TNode {\r\n    /** Index in the LViewData[] array. */\r\n    index: number;\r\n    child: TElementNode | TTextNode | TContainerNode | TElementContainerNode | TProjectionNode | null;\r\n    parent: TElementNode | TElementContainerNode | null;\r\n    tViews: null;\r\n    projection: null;\r\n}\r\n/** Static data for an LViewNode  */\r\nexport interface TViewNode extends TNode {\r\n    /** If -1, it's a dynamically created view. Otherwise, it is the view block ID. */\r\n    index: number;\r\n    child: TElementNode | TTextNode | TElementContainerNode | TContainerNode | TProjectionNode | null;\r\n    parent: TContainerNode | null;\r\n    tViews: null;\r\n    projection: null;\r\n}\r\n/** Static data for an LProjectionNode  */\r\nexport interface TProjectionNode extends TNode {\r\n    /** Index in the data[] array */\r\n    child: null;\r\n    /**\r\n     * Projection nodes will have parents unless they are the first node of a component\r\n     * or embedded view (which means their parent is in a different view and must be\r\n     * retrieved using LView.node).\r\n     */\r\n    parent: TElementNode | TElementContainerNode | null;\r\n    tViews: null;\r\n    /** Index of the projection node. (See TNode.projection for more info.) */\r\n    projection: number;\r\n}\r\n/**\r\n * This mapping is necessary so we can set input properties and output listeners\r\n * properly at runtime when property names are minified or aliased.\r\n *\r\n * Key: unminified / public input or output name\r\n * Value: array containing minified / internal name and related directive index\r\n *\r\n * The value must be an array to support inputs and outputs with the same name\r\n * on the same node.\r\n */\r\nexport declare type PropertyAliases = {\r\n    [key: string]: PropertyAliasValue;\r\n};\r\n/**\r\n * Store the runtime input or output names for all the directives.\r\n *\r\n * - Even indices: directive index\r\n * - Odd indices: minified / internal name\r\n *\r\n * e.g. [0, 'change-minified']\r\n */\r\nexport declare type PropertyAliasValue = (number | string)[];\r\n/**\r\n * This array contains information about input properties that\r\n * need to be set once from attribute data. It's ordered by\r\n * directive index (relative to element) so it's simple to\r\n * look up a specific directive's initial input data.\r\n *\r\n * Within each sub-array:\r\n *\r\n * Even indices: minified/internal input name\r\n * Odd indices: initial value\r\n *\r\n * If a directive on a node does not have any input properties\r\n * that should be set from attributes, its index is set to null\r\n * to avoid a sparse array.\r\n *\r\n * e.g. [null, ['role-min', 'button']]\r\n */\r\nexport declare type InitialInputData = (InitialInputs | null)[];\r\n/**\r\n * Used by InitialInputData to store input properties\r\n * that should be set once from attributes.\r\n *\r\n * Even indices: minified/internal input name\r\n * Odd indices: initial value\r\n *\r\n * e.g. ['role-min', 'button']\r\n */\r\nexport declare type InitialInputs = string[];\r\nexport declare const unusedValueExportToPlacateAjd = 1;\r\n/**\r\n * Type representing a set of LNodes that can have local refs (`#foo`) placed on them.\r\n */\r\nexport declare type LNodeWithLocalRefs = LContainerNode | LElementNode | LElementContainerNode;\r\n/**\r\n * Type for a function that extracts a value for a local refs.\r\n * Example:\r\n * - `<div #nativeDivEl>` - `nativeDivEl` should point to the native `<div>` element;\r\n * - `<ng-template #tplRef>` - `tplRef` should point to the `TemplateRef` instance;\r\n */\r\nexport declare type LocalRefExtractor = (lNode: LNodeWithLocalRefs, tNode: TNode) => any;\r\n",
  "/node_modules/@angular/core/src/render3/interfaces/projection.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Expresses a single CSS Selector.\r\n *\r\n * Beginning of array\r\n * - First index: element name\r\n * - Subsequent odd indices: attr keys\r\n * - Subsequent even indices: attr values\r\n *\r\n * After SelectorFlags.CLASS flag\r\n * - Class name values\r\n *\r\n * SelectorFlags.NOT flag\r\n * - Changes the mode to NOT\r\n * - Can be combined with other flags to set the element / attr / class mode\r\n *\r\n * e.g. SelectorFlags.NOT | SelectorFlags.ELEMENT\r\n *\r\n * Example:\r\n * Original: `div.foo.bar[attr1=val1][attr2]`\r\n * Parsed: ['div', 'attr1', 'val1', 'attr2', '', SelectorFlags.CLASS, 'foo', 'bar']\r\n *\r\n * Original: 'div[attr1]:not(.foo[attr2])\r\n * Parsed: [\r\n *  'div', 'attr1', '',\r\n *  SelectorFlags.NOT | SelectorFlags.ATTRIBUTE 'attr2', '', SelectorFlags.CLASS, 'foo'\r\n * ]\r\n *\r\n * See more examples in node_selector_matcher_spec.ts\r\n */\r\nexport declare type CssSelector = (string | SelectorFlags)[];\r\n/**\r\n * A list of CssSelectors.\r\n *\r\n * A directive or component can have multiple selectors. This type is used for\r\n * directive defs so any of the selectors in the list will match that directive.\r\n *\r\n * Original: 'form, [ngForm]'\r\n * Parsed: [['form'], ['', 'ngForm', '']]\r\n */\r\nexport declare type CssSelectorList = CssSelector[];\r\n/** Flags used to build up CssSelectors */\r\nexport declare const enum SelectorFlags {\r\n    /** Indicates this is the beginning of a new negative selector */\r\n    NOT = 1,\r\n    /** Mode for matching attributes */\r\n    ATTRIBUTE = 2,\r\n    /** Mode for matching tag names */\r\n    ELEMENT = 4,\r\n    /** Mode for matching class names */\r\n    CLASS = 8\r\n}\r\nexport declare const NG_PROJECT_AS_ATTR_NAME = \"ngProjectAs\";\r\nexport declare const unusedValueExportToPlacateAjd = 1;\r\n",
  "/node_modules/@angular/core/src/render3/interfaces/query.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { QueryList } from '../../linker';\r\nimport { Type } from '../../type';\r\nimport { TNode } from './node';\r\n/** Used for tracking queries (e.g. ViewChild, ContentChild). */\r\nexport interface LQueries {\r\n    /**\r\n     * The parent LQueries instance.\r\n     *\r\n     * When there is a content query, a new LQueries instance is created to avoid mutating any\r\n     * existing LQueries. After we are done searching content children, the parent property allows\r\n     * us to traverse back up to the original LQueries instance to continue to search for matches\r\n     * in the main view.\r\n     */\r\n    parent: LQueries | null;\r\n    /**\r\n     * Ask queries to prepare copy of itself. This assures that tracking new queries on content nodes\r\n     * doesn't mutate list of queries tracked on a parent node. We will clone LQueries before\r\n     * constructing content queries.\r\n     */\r\n    clone(): LQueries;\r\n    /**\r\n     * Notify `LQueries` that a new `TNode` has been created and needs to be added to query results\r\n     * if matching query predicate.\r\n     */\r\n    addNode(tNode: TNode): LQueries | null;\r\n    /**\r\n     * Notify `LQueries` that a new LContainer was added to ivy data structures. As a result we need\r\n     * to prepare room for views that might be inserted into this container.\r\n     */\r\n    container(): LQueries | null;\r\n    /**\r\n     * Notify `LQueries` that a new `LView` has been created. As a result we need to prepare room\r\n     * and collect nodes that match query predicate.\r\n     */\r\n    createView(): LQueries | null;\r\n    /**\r\n     * Notify `LQueries` that a new `LView` has been added to `LContainer`. As a result all\r\n     * the matching nodes from this view should be added to container's queries.\r\n     */\r\n    insertView(newViewIndex: number): void;\r\n    /**\r\n     * Notify `LQueries` that an `LView` has been removed from `LContainer`. As a result all\r\n     * the matching nodes from this view should be removed from container's queries.\r\n     */\r\n    removeView(): void;\r\n    /**\r\n     * Add additional `QueryList` to track.\r\n     *\r\n     * @param queryList `QueryList` to update with changes.\r\n     * @param predicate Either `Type` or selector array of [key, value] predicates.\r\n     * @param descend If true the query will recursively apply to the children.\r\n     * @param read Indicates which token should be read from DI for this query.\r\n     */\r\n    track<T>(queryList: QueryList<T>, predicate: Type<any> | string[], descend?: boolean, read?: QueryReadType<T> | Type<T>): void;\r\n}\r\nexport declare class QueryReadType<T> {\r\n    private defeatStructuralTyping;\r\n}\r\nexport declare const unusedValueExportToPlacateAjd = 1;\r\n",
  "/node_modules/@angular/core/src/render3/interfaces/renderer.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * The goal here is to make sure that the browser DOM API is the Renderer.\r\n * We do this by defining a subset of DOM API to be the renderer and than\r\n * use that time for rendering.\r\n *\r\n * At runtime we can than use the DOM api directly, in server or web-worker\r\n * it will be easy to implement such API.\r\n */\r\nimport { RendererStyleFlags2, RendererType2 } from '../../render/api';\r\nexport declare enum RendererStyleFlags3 {\r\n    Important = 1,\r\n    DashCase = 2\r\n}\r\nexport declare type Renderer3 = ObjectOrientedRenderer3 | ProceduralRenderer3;\r\n/**\r\n * Object Oriented style of API needed to create elements and text nodes.\r\n *\r\n * This is the native browser API style, e.g. operations are methods on individual objects\r\n * like HTMLElement. With this style, no additional code is needed as a facade\r\n * (reducing payload size).\r\n * */\r\nexport interface ObjectOrientedRenderer3 {\r\n    createComment(data: string): RComment;\r\n    createElement(tagName: string): RElement;\r\n    createElementNS(namespace: string, tagName: string): RElement;\r\n    createTextNode(data: string): RText;\r\n    querySelector(selectors: string): RElement | null;\r\n}\r\n/** Returns whether the `renderer` is a `ProceduralRenderer3` */\r\nexport declare function isProceduralRenderer(renderer: ProceduralRenderer3 | ObjectOrientedRenderer3): renderer is ProceduralRenderer3;\r\n/**\r\n * Procedural style of API needed to create elements and text nodes.\r\n *\r\n * In non-native browser environments (e.g. platforms such as web-workers), this is the\r\n * facade that enables element manipulation. This also facilitates backwards compatibility\r\n * with Renderer2.\r\n */\r\nexport interface ProceduralRenderer3 {\r\n    destroy(): void;\r\n    createComment(value: string): RComment;\r\n    createElement(name: string, namespace?: string | null): RElement;\r\n    createText(value: string): RText;\r\n    /**\r\n     * This property is allowed to be null / undefined,\r\n     * in which case the view engine won't call it.\r\n     * This is used as a performance optimization for production mode.\r\n     */\r\n    destroyNode?: ((node: RNode) => void) | null;\r\n    appendChild(parent: RElement, newChild: RNode): void;\r\n    insertBefore(parent: RNode, newChild: RNode, refChild: RNode | null): void;\r\n    removeChild(parent: RElement, oldChild: RNode): void;\r\n    selectRootElement(selectorOrNode: string | any): RElement;\r\n    setAttribute(el: RElement, name: string, value: string, namespace?: string | null): void;\r\n    removeAttribute(el: RElement, name: string, namespace?: string | null): void;\r\n    addClass(el: RElement, name: string): void;\r\n    removeClass(el: RElement, name: string): void;\r\n    setStyle(el: RElement, style: string, value: any, flags?: RendererStyleFlags2 | RendererStyleFlags3): void;\r\n    removeStyle(el: RElement, style: string, flags?: RendererStyleFlags2 | RendererStyleFlags3): void;\r\n    setProperty(el: RElement, name: string, value: any): void;\r\n    setValue(node: RText, value: string): void;\r\n    listen(target: RNode, eventName: string, callback: (event: any) => boolean | void): () => void;\r\n}\r\nexport interface RendererFactory3 {\r\n    createRenderer(hostElement: RElement | null, rendererType: RendererType2 | null): Renderer3;\r\n    begin?(): void;\r\n    end?(): void;\r\n}\r\nexport declare const domRendererFactory3: RendererFactory3;\r\n/** Subset of API needed for appending elements and text nodes. */\r\nexport interface RNode {\r\n    removeChild(oldChild: RNode): void;\r\n    /**\r\n     * Insert a child node.\r\n     *\r\n     * Used exclusively for adding View root nodes into ViewAnchor location.\r\n     */\r\n    insertBefore(newChild: RNode, refChild: RNode | null, isViewRoot: boolean): void;\r\n    /**\r\n     * Append a child node.\r\n     *\r\n     * Used exclusively for building up DOM which are static (ie not View roots)\r\n     */\r\n    appendChild(newChild: RNode): RNode;\r\n}\r\n/**\r\n * Subset of API needed for writing attributes, properties, and setting up\r\n * listeners on Element.\r\n */\r\nexport interface RElement extends RNode {\r\n    style: RCssStyleDeclaration;\r\n    classList: RDomTokenList;\r\n    className: string;\r\n    setAttribute(name: string, value: string): void;\r\n    removeAttribute(name: string): void;\r\n    setAttributeNS(namespaceURI: string, qualifiedName: string, value: string): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n    removeEventListener(type: string, listener?: EventListener, options?: boolean): void;\r\n    setProperty?(name: string, value: any): void;\r\n}\r\nexport interface RCssStyleDeclaration {\r\n    removeProperty(propertyName: string): string;\r\n    setProperty(propertyName: string, value: string | null, priority?: string): void;\r\n}\r\nexport interface RDomTokenList {\r\n    add(token: string): void;\r\n    remove(token: string): void;\r\n}\r\nexport interface RText extends RNode {\r\n    textContent: string | null;\r\n}\r\nexport interface RComment extends RNode {\r\n}\r\nexport declare const unusedValueExportToPlacateAjd = 1;\r\n",
  "/node_modules/@angular/core/src/render3/interfaces/view.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Injector } from '../../di/injector';\r\nimport { QueryList } from '../../linker';\r\nimport { Sanitizer } from '../../sanitization/security';\r\nimport { LContainer } from './container';\r\nimport { ComponentQuery, ComponentTemplate, DirectiveDefInternal, DirectiveDefList, PipeDefInternal, PipeDefList } from './definition';\r\nimport { TElementNode, TNode, TViewNode } from './node';\r\nimport { LQueries } from './query';\r\nimport { Renderer3 } from './renderer';\r\n/** Size of LViewData's header. Necessary to adjust for it when setting slots.  */\r\nexport declare const HEADER_OFFSET = 17;\r\nexport declare const TVIEW = 0;\r\nexport declare const PARENT = 1;\r\nexport declare const NEXT = 2;\r\nexport declare const QUERIES = 3;\r\nexport declare const FLAGS = 4;\r\nexport declare const HOST_NODE = 5;\r\nexport declare const BINDING_INDEX = 6;\r\nexport declare const DIRECTIVES = 7;\r\nexport declare const CLEANUP = 8;\r\nexport declare const CONTEXT = 9;\r\nexport declare const INJECTOR = 10;\r\nexport declare const RENDERER = 11;\r\nexport declare const SANITIZER = 12;\r\nexport declare const TAIL = 13;\r\nexport declare const CONTAINER_INDEX = 14;\r\nexport declare const CONTENT_QUERIES = 15;\r\nexport declare const DECLARATION_VIEW = 16;\r\nexport interface OpaqueViewState {\r\n    '__brand__': 'Brand for OpaqueViewState that nothing will match';\r\n}\r\n/**\r\n * `LViewData` stores all of the information needed to process the instructions as\r\n * they are invoked from the template. Each embedded view and component view has its\r\n * own `LViewData`. When processing a particular view, we set the `viewData` to that\r\n * `LViewData`. When that view is done processing, the `viewData` is set back to\r\n * whatever the original `viewData` was before (the parent `LViewData`).\r\n *\r\n * Keeping separate state for each view facilities view insertion / deletion, so we\r\n * don't have to edit the data array based on which views are present.\r\n */\r\nexport interface LViewData extends Array<any> {\r\n    /**\r\n     * The static data for this view. We need a reference to this so we can easily walk up the\r\n     * node tree in DI and get the TView.data array associated with a node (where the\r\n     * directive defs are stored).\r\n     */\r\n    [TVIEW]: TView;\r\n    /**\r\n     * The parent view is needed when we exit the view and must restore the previous\r\n     * `LViewData`. Without this, the render method would have to keep a stack of\r\n     * views as it is recursively rendering templates.\r\n     *\r\n     * This is the \"insertion\" view for embedded views. This allows us to properly\r\n     * destroy embedded views.\r\n     */\r\n    [PARENT]: LViewData | null;\r\n    /**\r\n     *\r\n     * The next sibling LViewData or LContainer.\r\n     *\r\n     * Allows us to propagate between sibling view states that aren't in the same\r\n     * container. Embedded views already have a node.next, but it is only set for\r\n     * views in the same container. We need a way to link component views and views\r\n     * across containers as well.\r\n     */\r\n    [NEXT]: LViewData | LContainer | null;\r\n    /** Queries active for this view - nodes from a view are reported to those queries. */\r\n    [QUERIES]: LQueries | null;\r\n    /** Flags for this view. See LViewFlags for more info. */\r\n    [FLAGS]: LViewFlags;\r\n    /**\r\n     * Pointer to the `TViewNode` or `TElementNode` which represents the root of the view.\r\n     *\r\n     * If `TViewNode`, this is an embedded view of a container. We need this to be able to\r\n     * efficiently find the `LViewNode` when inserting the view into an anchor.\r\n     *\r\n     * If `TElementNode`, this is the LView of a component.\r\n     *\r\n     * If null, this is the root view of an application (root component is in this view).\r\n     */\r\n    [HOST_NODE]: TViewNode | TElementNode | null;\r\n    /**\r\n     * The binding index we should access next.\r\n     *\r\n     * This is stored so that bindings can continue where they left off\r\n     * if a view is left midway through processing bindings (e.g. if there is\r\n     * a setter that creates an embedded view, like in ngIf).\r\n     */\r\n    [BINDING_INDEX]: number;\r\n    /**\r\n     * An array of directive instances in the current view.\r\n     *\r\n     * These must be stored separately from LNodes because their presence is\r\n     * unknown at compile-time and thus space cannot be reserved in data[].\r\n     */\r\n    [DIRECTIVES]: any[] | null;\r\n    /**\r\n     * When a view is destroyed, listeners need to be released and outputs need to be\r\n     * unsubscribed. This context array stores both listener functions wrapped with\r\n     * their context and output subscription instances for a particular view.\r\n     *\r\n     * These change per LView instance, so they cannot be stored on TView. Instead,\r\n     * TView.cleanup saves an index to the necessary context in this array.\r\n     */\r\n    [CLEANUP]: any[] | null;\r\n    /**\r\n     * - For dynamic views, this is the context with which to render the template (e.g.\r\n     *   `NgForContext`), or `{}` if not defined explicitly.\r\n     * - For root view of the root component the context contains change detection data.\r\n     * - For non-root components, the context is the component instance,\r\n     * - For inline views, the context is null.\r\n     */\r\n    [CONTEXT]: {} | RootContext | null;\r\n    /** An optional Module Injector to be used as fall back after Element Injectors are consulted. */\r\n    [INJECTOR]: Injector | null;\r\n    /** Renderer to be used for this view. */\r\n    [RENDERER]: Renderer3;\r\n    /** An optional custom sanitizer. */\r\n    [SANITIZER]: Sanitizer | null;\r\n    /**\r\n     * The last LViewData or LContainer beneath this LViewData in the hierarchy.\r\n     *\r\n     * The tail allows us to quickly add a new state to the end of the view list\r\n     * without having to propagate starting from the first child.\r\n     */\r\n    [TAIL]: LViewData | LContainer | null;\r\n    /**\r\n     * The index of the parent container's host node. Applicable only to embedded views that\r\n     * have been inserted dynamically. Will be -1 for component views and inline views.\r\n     *\r\n     * This is necessary to jump from dynamically created embedded views to their parent\r\n     * containers because their parent cannot be stored on the TViewNode (views may be inserted\r\n     * in multiple containers, so the parent cannot be shared between view instances).\r\n     */\r\n    [CONTAINER_INDEX]: number;\r\n    /**\r\n     * Stores QueryLists associated with content queries of a directive. This data structure is\r\n     * filled-in as part of a directive creation process and is later used to retrieve a QueryList to\r\n     * be refreshed.\r\n     */\r\n    [CONTENT_QUERIES]: QueryList<any>[] | null;\r\n    /**\r\n     * View where this view's template was declared.\r\n     *\r\n     * Only applicable for dynamically created views. Will be null for inline/component views.\r\n     *\r\n     * The template for a dynamically created view may be declared in a different view than\r\n     * it is inserted. We already track the \"insertion view\" (view where the template was\r\n     * inserted) in LViewData[PARENT], but we also need access to the \"declaration view\"\r\n     * (view where the template was declared). Otherwise, we wouldn't be able to call the\r\n     * view's template function with the proper contexts. Context should be inherited from\r\n     * the declaration view tree, not the insertion view tree.\r\n     *\r\n     * Example (AppComponent template):\r\n     *\r\n     * <ng-template #foo></ng-template>       <-- declared here -->\r\n     * <some-comp [tpl]=\"foo\"></some-comp>    <-- inserted inside this component -->\r\n     *\r\n     * The <ng-template> above is declared in the AppComponent template, but it will be passed into\r\n     * SomeComp and inserted there. In this case, the declaration view would be the AppComponent,\r\n     * but the insertion view would be SomeComp. When we are removing views, we would want to\r\n     * traverse through the insertion view to clean up listeners. When we are calling the\r\n     * template function during change detection, we need the declaration view to get inherited\r\n     * context.\r\n     */\r\n    [DECLARATION_VIEW]: LViewData | null;\r\n}\r\n/** Flags associated with an LView (saved in LViewData[FLAGS]) */\r\nexport declare const enum LViewFlags {\r\n    /**\r\n     * Whether or not the view is in creationMode.\r\n     *\r\n     * This must be stored in the view rather than using `data` as a marker so that\r\n     * we can properly support embedded views. Otherwise, when exiting a child view\r\n     * back into the parent view, `data` will be defined and `creationMode` will be\r\n     * improperly reported as false.\r\n     */\r\n    CreationMode = 1,\r\n    /** Whether this view has default change detection strategy (checks always) or onPush */\r\n    CheckAlways = 2,\r\n    /** Whether or not this view is currently dirty (needing check) */\r\n    Dirty = 4,\r\n    /** Whether or not this view is currently attached to change detection tree. */\r\n    Attached = 8,\r\n    /**\r\n     *  Whether or not the init hooks have run.\r\n     *\r\n     * If on, the init hooks haven't yet been run and should be executed by the first component that\r\n     * runs OR the first cR() instruction that runs (so inits are run for the top level view before\r\n     * any embedded views).\r\n     */\r\n    RunInit = 16,\r\n    /** Whether or not this view is destroyed. */\r\n    Destroyed = 32,\r\n    /** Whether or not this view is the root view */\r\n    IsRoot = 64\r\n}\r\n/**\r\n * The static data for an LView (shared between all templates of a\r\n * given type).\r\n *\r\n * Stored on the template function as ngPrivateData.\r\n */\r\nexport interface TView {\r\n    /**\r\n     * ID for inline views to determine whether a view is the same as the previous view\r\n     * in a certain position. If it's not, we know the new view needs to be inserted\r\n     * and the one that exists needs to be removed (e.g. if/else statements)\r\n     *\r\n     * If this is -1, then this is a component view or a dynamically created view.\r\n     */\r\n    readonly id: number;\r\n    /**\r\n     * This is a blueprint used to generate LViewData instances for this TView. Copying this\r\n     * blueprint is faster than creating a new LViewData from scratch.\r\n     */\r\n    blueprint: LViewData;\r\n    /**\r\n     * The template function used to refresh the view of dynamically created views\r\n     * and components. Will be null for inline views.\r\n     */\r\n    template: ComponentTemplate<{}> | null;\r\n    /**\r\n     * A function containing query-related instructions.\r\n     */\r\n    viewQuery: ComponentQuery<{}> | null;\r\n    /**\r\n     * Pointer to the `TNode` that represents the root of the view.\r\n     *\r\n     * If this is a `TNode` for an `LViewNode`, this is an embedded view of a container.\r\n     * We need this pointer to be able to efficiently find this node when inserting the view\r\n     * into an anchor.\r\n     *\r\n     * If this is a `TElementNode`, this is the view of a root component. It has exactly one\r\n     * root TNode.\r\n     *\r\n     * If this is null, this is the view of a component that is not at root. We do not store\r\n     * the host TNodes for child component views because they can potentially have several\r\n     * different host TNodes, depending on where the component is being used. These host\r\n     * TNodes cannot be shared (due to different indices, etc).\r\n     */\r\n    node: TViewNode | TElementNode | null;\r\n    /** Whether or not this template has been processed. */\r\n    firstTemplatePass: boolean;\r\n    /** Static data equivalent of LView.data[]. Contains TNodes. */\r\n    data: TData;\r\n    /**\r\n     * The binding start index is the index at which the data array\r\n     * starts to store bindings only. Saving this value ensures that we\r\n     * will begin reading bindings at the correct point in the array when\r\n     * we are in update mode.\r\n     */\r\n    bindingStartIndex: number;\r\n    /**\r\n     * The index at which the data array begins to store host bindings for components\r\n     * or directives in its template. Saving this value ensures that we can set the\r\n     * binding root and binding index correctly before checking host bindings.\r\n     */\r\n    hostBindingStartIndex: number;\r\n    /**\r\n     * Index of the host node of the first LView or LContainer beneath this LView in\r\n     * the hierarchy.\r\n     *\r\n     * Necessary to store this so views can traverse through their nested views\r\n     * to remove listeners and call onDestroy callbacks.\r\n     *\r\n     * For embedded views, we store the index of an LContainer's host rather than the first\r\n     * LView to avoid managing splicing when views are added/removed.\r\n     */\r\n    childIndex: number;\r\n    /**\r\n     * A reference to the first child node located in the view.\r\n     */\r\n    firstChild: TNode | null;\r\n    /**\r\n     * Selector matches for a node are temporarily cached on the TView so the\r\n     * DI system can eagerly instantiate directives on the same node if they are\r\n     * created out of order. They are overwritten after each node.\r\n     *\r\n     * <div dirA dirB></div>\r\n     *\r\n     * e.g. DirA injects DirB, but DirA is created first. DI should instantiate\r\n     * DirB when it finds that it's on the same node, but not yet created.\r\n     *\r\n     * Even indices: Directive defs\r\n     * Odd indices:\r\n     *   - Null if the associated directive hasn't been instantiated yet\r\n     *   - Directive index, if associated directive has been created\r\n     *   - String, temporary 'CIRCULAR' token set while dependencies are being resolved\r\n     */\r\n    currentMatches: CurrentMatchesList | null;\r\n    /**\r\n     * Directive and component defs that have already been matched to nodes on\r\n     * this view.\r\n     *\r\n     * Defs are stored at the same index in TView.directives[] as their instances\r\n     * are stored in LView.directives[]. This simplifies lookup in DI.\r\n     */\r\n    directives: DirectiveDefList | null;\r\n    /**\r\n     * Full registry of directives and components that may be found in this view.\r\n     *\r\n     * It's necessary to keep a copy of the full def list on the TView so it's possible\r\n     * to render template functions without a host component.\r\n     */\r\n    directiveRegistry: DirectiveDefList | null;\r\n    /**\r\n     * Full registry of pipes that may be found in this view.\r\n     *\r\n     * The property is either an array of `PipeDefs`s or a function which returns the array of\r\n     * `PipeDefs`s. The function is necessary to be able to support forward declarations.\r\n     *\r\n     * It's necessary to keep a copy of the full def list on the TView so it's possible\r\n     * to render template functions without a host component.\r\n     */\r\n    pipeRegistry: PipeDefList | null;\r\n    /**\r\n     * Array of ngOnInit and ngDoCheck hooks that should be executed for this view in\r\n     * creation mode.\r\n     *\r\n     * Even indices: Directive index\r\n     * Odd indices: Hook function\r\n     */\r\n    initHooks: HookData | null;\r\n    /**\r\n     * Array of ngDoCheck hooks that should be executed for this view in update mode.\r\n     *\r\n     * Even indices: Directive index\r\n     * Odd indices: Hook function\r\n     */\r\n    checkHooks: HookData | null;\r\n    /**\r\n     * Array of ngAfterContentInit and ngAfterContentChecked hooks that should be executed\r\n     * for this view in creation mode.\r\n     *\r\n     * Even indices: Directive index\r\n     * Odd indices: Hook function\r\n     */\r\n    contentHooks: HookData | null;\r\n    /**\r\n     * Array of ngAfterContentChecked hooks that should be executed for this view in update\r\n     * mode.\r\n     *\r\n     * Even indices: Directive index\r\n     * Odd indices: Hook function\r\n     */\r\n    contentCheckHooks: HookData | null;\r\n    /**\r\n     * Array of ngAfterViewInit and ngAfterViewChecked hooks that should be executed for\r\n     * this view in creation mode.\r\n     *\r\n     * Even indices: Directive index\r\n     * Odd indices: Hook function\r\n     */\r\n    viewHooks: HookData | null;\r\n    /**\r\n     * Array of ngAfterViewChecked hooks that should be executed for this view in\r\n     * update mode.\r\n     *\r\n     * Even indices: Directive index\r\n     * Odd indices: Hook function\r\n     */\r\n    viewCheckHooks: HookData | null;\r\n    /**\r\n     * Array of ngOnDestroy hooks that should be executed when this view is destroyed.\r\n     *\r\n     * Even indices: Directive index\r\n     * Odd indices: Hook function\r\n     */\r\n    destroyHooks: HookData | null;\r\n    /**\r\n     * Array of pipe ngOnDestroy hooks that should be executed when this view is destroyed.\r\n     *\r\n     * Even indices: Index of pipe in data\r\n     * Odd indices: Hook function\r\n     *\r\n     * These must be stored separately from directive destroy hooks because their contexts\r\n     * are stored in data.\r\n     */\r\n    pipeDestroyHooks: HookData | null;\r\n    /**\r\n     * When a view is destroyed, listeners need to be released and outputs need to be\r\n     * unsubscribed. This cleanup array stores both listener data (in chunks of 4)\r\n     * and output data (in chunks of 2) for a particular view. Combining the arrays\r\n     * saves on memory (70 bytes per array) and on a few bytes of code size (for two\r\n     * separate for loops).\r\n     *\r\n     * If it's a native DOM listener being stored:\r\n     * 1st index is: event name to remove\r\n     * 2nd index is: index of native element in LView.data[]\r\n     * 3rd index is: index of wrapped listener function in LView.cleanupInstances[]\r\n     * 4th index is: useCapture boolean\r\n     *\r\n     * If it's a renderer2 style listener or ViewRef destroy hook being stored:\r\n     * 1st index is: index of the cleanup function in LView.cleanupInstances[]\r\n     * 2nd index is: null\r\n     *\r\n     * If it's an output subscription or query list destroy hook:\r\n     * 1st index is: output unsubscribe function / query list destroy function\r\n     * 2nd index is: index of function context in LView.cleanupInstances[]\r\n     */\r\n    cleanup: any[] | null;\r\n    /**\r\n     * A list of element indices for child components that will need to be\r\n     * refreshed when the current view has finished its check. These indices have\r\n     * already been adjusted for the HEADER_OFFSET.\r\n     *\r\n     */\r\n    components: number[] | null;\r\n    /**\r\n     * A list of indices for child directives that have host bindings.\r\n     *\r\n     * Even indices: Directive indices\r\n     * Odd indices: Element indices\r\n     *\r\n     * Element indices are NOT adjusted for LViewData header offset because\r\n     * they will be fed into instructions that expect the raw index (e.g. elementProperty)\r\n     */\r\n    hostBindings: number[] | null;\r\n    /**\r\n     * A list of indices for child directives that have content queries.\r\n     *\r\n     * Even indices: Directive indices\r\n     * Odd indices: Starting index of content queries (stored in CONTENT_QUERIES) for this directive\r\n     */\r\n    contentQueries: number[] | null;\r\n}\r\n/**\r\n * RootContext contains information which is shared for all components which\r\n * were bootstrapped with {@link renderComponent}.\r\n */\r\nexport interface RootContext {\r\n    /**\r\n     * A function used for scheduling change detection in the future. Usually\r\n     * this is `requestAnimationFrame`.\r\n     */\r\n    scheduler: (workFn: () => void) => void;\r\n    /**\r\n     * A promise which is resolved when all components are considered clean (not dirty).\r\n     *\r\n     * This promise is overwritten every time a first call to {@link markDirty} is invoked.\r\n     */\r\n    clean: Promise<null>;\r\n    /**\r\n     * RootComponents - The components that were instantiated by the call to\r\n     * {@link renderComponent}.\r\n     */\r\n    components: {}[];\r\n}\r\n/**\r\n * Array of hooks that should be executed for a view and their directive indices.\r\n *\r\n * Even indices: Directive index\r\n * Odd indices: Hook function\r\n */\r\nexport declare type HookData = (number | (() => void))[];\r\n/**\r\n * Static data that corresponds to the instance-specific data array on an LView.\r\n *\r\n * Each node's static data is stored in tData at the same index that it's stored\r\n * in the data array. Each pipe's definition is stored here at the same index\r\n * as its pipe instance in the data array. Any nodes that do not have static\r\n * data store a null value in tData to avoid a sparse array.\r\n */\r\nexport declare type TData = (TNode | PipeDefInternal<any> | null)[];\r\n/** Type for TView.currentMatches */\r\nexport declare type CurrentMatchesList = [DirectiveDefInternal<any>, (string | number | null)];\r\nexport declare const unusedValueExportToPlacateAjd = 1;\r\n",
  "/node_modules/@angular/core/src/render3/jit/directive.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Component, Directive } from '../../metadata/directives';\r\nimport { Type } from '../../type';\r\n/**\r\n * Compile an Angular component according to its decorator metadata, and patch the resulting\r\n * ngComponentDef onto the component type.\r\n *\r\n * Compilation may be asynchronous (due to the need to resolve URLs for the component template or\r\n * other resources, for example). In the event that compilation is not immediate, `compileComponent`\r\n * will enqueue resource resolution into a global queue and will fail to return the `ngComponentDef`\r\n * until the global queue has been resolved with a call to `resolveComponentResources`.\r\n */\r\nexport declare function compileComponent(type: Type<any>, metadata: Component): void;\r\n/**\r\n * Compile an Angular directive according to its decorator metadata, and patch the resulting\r\n * ngDirectiveDef onto the component type.\r\n *\r\n * In the event that compilation is not immediate, `compileDirective` will return a `Promise` which\r\n * will resolve when compilation completes and the directive becomes usable.\r\n */\r\nexport declare function compileDirective(type: Type<any>, directive: Directive): void;\r\nexport declare function extendsDirectlyFromObject(type: Type<any>): boolean;\r\n",
  "/node_modules/@angular/core/src/render3/jit/environment.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\r\n *\r\n * This should be kept up to date with the public exports of @angular/core.\r\n */\r\nexport declare const angularCoreEnv: {\r\n    [name: string]: Function;\r\n};\r\n",
  "/node_modules/@angular/core/src/render3/jit/fields.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare const NG_COMPONENT_DEF: any;\r\nexport declare const NG_DIRECTIVE_DEF: any;\r\nexport declare const NG_INJECTABLE_DEF: any;\r\nexport declare const NG_INJECTOR_DEF: any;\r\nexport declare const NG_PIPE_DEF: any;\r\nexport declare const NG_MODULE_DEF: any;\r\n",
  "/node_modules/@angular/core/src/render3/jit/injectable.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Injectable } from '../../di/injectable';\r\nimport { Type } from '../../type';\r\n/**\r\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\r\n * `ngInjectableDef` onto the injectable type.\r\n */\r\nexport declare function compileInjectable(type: Type<any>, srcMeta?: Injectable): void;\r\n",
  "/node_modules/@angular/core/src/render3/jit/module.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { NgModule, NgModuleTransitiveScopes } from '../../metadata/ng_module';\r\nimport { Type } from '../../type';\r\nimport { ComponentDefInternal } from '../interfaces/definition';\r\n/**\r\n * Compiles a module in JIT mode.\r\n *\r\n * This function automatically gets called when a class has a `@NgModule` decorator.\r\n */\r\nexport declare function compileNgModule(moduleType: Type<any>, ngModule: NgModule): void;\r\n/**\r\n * Compiles and adds the `ngModuleDef` and `ngInjectorDef` properties to the module class.\r\n */\r\nexport declare function compileNgModuleDefs(moduleType: Type<any>, ngModule: NgModule): void;\r\n/**\r\n * Patch the definition of a component with directives and pipes from the compilation scope of\r\n * a given module.\r\n */\r\nexport declare function patchComponentDefWithScope<C>(componentDef: ComponentDefInternal<C>, transitiveScopes: NgModuleTransitiveScopes): void;\r\n/**\r\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\r\n *\r\n * This operation is memoized and the result is cached on the module's definition. It can be called\r\n * on modules with components that have not fully compiled yet, but the result should not be used\r\n * until they have.\r\n */\r\nexport declare function transitiveScopesFor<T>(moduleType: Type<T>): NgModuleTransitiveScopes;\r\n",
  "/node_modules/@angular/core/src/render3/jit/pipe.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Pipe } from '../../metadata/directives';\r\nimport { Type } from '../../type';\r\nexport declare function compilePipe(type: Type<any>, meta: Pipe): void;\r\n",
  "/node_modules/@angular/core/src/render3/jit/util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { R3DependencyMetadata } from '@angular/compiler';\r\nimport { ReflectionCapabilities } from '../../reflection/reflection_capabilities';\r\nimport { Type } from '../../type';\r\nexport declare function getReflect(): ReflectionCapabilities;\r\nexport declare function reflectDependencies(type: Type<any>): R3DependencyMetadata[];\r\nexport declare function convertDependencies(deps: any[]): R3DependencyMetadata[];\r\n",
  "/node_modules/@angular/core/src/render3/ng_dev_mode.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\ndeclare global {\r\n    const ngDevMode: null | NgDevModePerfCounters;\r\n    interface NgDevModePerfCounters {\r\n        firstTemplatePass: number;\r\n        tNode: number;\r\n        tView: number;\r\n        rendererCreateTextNode: number;\r\n        rendererSetText: number;\r\n        rendererCreateElement: number;\r\n        rendererAddEventListener: number;\r\n        rendererSetAttribute: number;\r\n        rendererRemoveAttribute: number;\r\n        rendererSetProperty: number;\r\n        rendererSetClassName: number;\r\n        rendererAddClass: number;\r\n        rendererRemoveClass: number;\r\n        rendererSetStyle: number;\r\n        rendererRemoveStyle: number;\r\n        rendererDestroy: number;\r\n        rendererDestroyNode: number;\r\n        rendererMoveNode: number;\r\n        rendererRemoveNode: number;\r\n        rendererCreateComment: number;\r\n    }\r\n}\r\nexport declare function ngDevModeResetPerfCounters(): NgDevModePerfCounters;\r\n",
  "/node_modules/@angular/core/src/render3/ng_module_ref.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Injector } from '../di/injector';\r\nimport { StaticProvider } from '../di/provider';\r\nimport { ComponentFactoryResolver as viewEngine_ComponentFactoryResolver } from '../linker/component_factory_resolver';\r\nimport { InternalNgModuleRef, NgModuleFactory as viewEngine_NgModuleFactory, NgModuleRef as viewEngine_NgModuleRef } from '../linker/ng_module_factory';\r\nimport { NgModuleDefInternal } from '../metadata/ng_module';\r\nimport { Type } from '../type';\r\nexport interface NgModuleType {\r\n    ngModuleDef: NgModuleDefInternal<any>;\r\n}\r\nexport declare const COMPONENT_FACTORY_RESOLVER: StaticProvider;\r\nexport declare class NgModuleRef<T> extends viewEngine_NgModuleRef<T> implements InternalNgModuleRef<T> {\r\n    _bootstrapComponents: Type<any>[];\r\n    injector: Injector;\r\n    componentFactoryResolver: viewEngine_ComponentFactoryResolver;\r\n    instance: T;\r\n    destroyCbs: (() => void)[] | null;\r\n    constructor(ngModuleType: Type<T>, parentInjector: Injector | null);\r\n    destroy(): void;\r\n    onDestroy(callback: () => void): void;\r\n}\r\nexport declare class NgModuleFactory<T> extends viewEngine_NgModuleFactory<T> {\r\n    moduleType: Type<T>;\r\n    constructor(moduleType: Type<T>);\r\n    create(parentInjector: Injector | null): viewEngine_NgModuleRef<T>;\r\n}\r\n",
  "/node_modules/@angular/core/src/render3/node_assert.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { TNode, TNodeType } from './interfaces/node';\r\nexport declare function assertNodeType(tNode: TNode, type: TNodeType): void;\r\nexport declare function assertNodeOfPossibleTypes(tNode: TNode, ...types: TNodeType[]): void;\r\n",
  "/node_modules/@angular/core/src/render3/node_manipulation.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { LContainer } from './interfaces/container';\r\nimport { LContainerNode, LElementContainerNode, LElementNode, LTextNode, TContainerNode, TNode, TViewNode } from './interfaces/node';\r\nimport { RComment, RNode, RText, Renderer3 } from './interfaces/renderer';\r\nimport { LViewData } from './interfaces/view';\r\n/** Retrieves the parent LNode of a given node. */\r\nexport declare function getParentLNode(tNode: TNode, currentView: LViewData): LElementNode | LElementContainerNode | LContainerNode | null;\r\n/**\r\n * Gets the host LElementNode given a view. Will return null if the host element is an\r\n * LViewNode, since they are being phased out.\r\n */\r\nexport declare function getHostElementNode(currentView: LViewData): LElementNode | null;\r\n/**\r\n * Gets the parent LNode if it's not a view. If it's a view, it will instead return the view's\r\n * parent container node.\r\n */\r\nexport declare function getParentOrContainerNode(tNode: TNode, currentView: LViewData): LElementNode | LElementContainerNode | LContainerNode | null;\r\nexport declare function getContainerNode(tNode: TNode, embeddedView: LViewData): LContainerNode | null;\r\n/**\r\n * Retrieves render parent LElementNode for a given view.\r\n * Might be null if a view is not yet attached to any container.\r\n */\r\nexport declare function getContainerRenderParent(tViewNode: TViewNode, view: LViewData): LElementNode | null;\r\n/**\r\n * Given a current view, finds the nearest component's host (LElement).\r\n *\r\n * @param lViewData LViewData for which we want a host element node\r\n * @returns The host node\r\n */\r\nexport declare function findComponentView(lViewData: LViewData): LViewData;\r\nexport declare function createTextNode(value: any, renderer: Renderer3): RText;\r\n/**\r\n * Adds or removes all DOM elements associated with a view.\r\n *\r\n * Because some root nodes of the view may be containers, we sometimes need\r\n * to propagate deeply into the nested containers to remove all elements in the\r\n * views beneath it.\r\n *\r\n * @param viewToWalk The view from which elements should be added or removed\r\n * @param insertMode Whether or not elements should be added (if false, removing)\r\n * @param beforeNode The node before which elements should be added, if insert mode\r\n */\r\nexport declare function addRemoveViewFromContainer(viewToWalk: LViewData, insertMode: true, beforeNode: RNode | null): void;\r\nexport declare function addRemoveViewFromContainer(viewToWalk: LViewData, insertMode: false): void;\r\n/**\r\n * Traverses down and up the tree of views and containers to remove listeners and\r\n * call onDestroy callbacks.\r\n *\r\n * Notes:\r\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\r\n *  - Must process containers instead of their views to avoid splicing\r\n *  when views are destroyed and re-added.\r\n *  - Using a while loop because it's faster than recursion\r\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\r\n *\r\n *  @param rootView The view to destroy\r\n */\r\nexport declare function destroyViewTree(rootView: LViewData): void;\r\n/**\r\n * Inserts a view into a container.\r\n *\r\n * This adds the view to the container's array of active views in the correct\r\n * position. It also adds the view's elements to the DOM if the container isn't a\r\n * root node of another view (in that case, the view's elements will be added when\r\n * the container's parent view is added later).\r\n *\r\n * @param container The container into which the view should be inserted\r\n * @param viewNode The view to insert\r\n * @param index The index at which to insert the view\r\n * @returns The inserted view\r\n */\r\nexport declare function insertView(container: LContainerNode, lView: LViewData, index: number, containerIndex: number): void;\r\n/**\r\n * Detaches a view from a container.\r\n *\r\n * This method splices the view from the container's array of active views. It also\r\n * removes the view's elements from the DOM.\r\n *\r\n * @param container The container from which to detach a view\r\n * @param removeIndex The index of the view to detach\r\n * @returns The detached view\r\n */\r\nexport declare function detachView(container: LContainerNode, removeIndex: number, detached: boolean): void;\r\n/**\r\n * Removes a view from a container, i.e. detaches it and then destroys the underlying LView.\r\n *\r\n * @param container The container from which to remove a view\r\n * @param removeIndex The index of the view to remove\r\n * @returns The removed view\r\n */\r\nexport declare function removeView(container: LContainerNode, tContainer: TContainerNode, removeIndex: number): void;\r\n/** Gets the child of the given LViewData */\r\nexport declare function getLViewChild(viewData: LViewData): LViewData | LContainer | null;\r\n/**\r\n * A standalone function which destroys an LView,\r\n * conducting cleanup (e.g. removing listeners, calling onDestroys).\r\n *\r\n * @param view The view to be destroyed.\r\n */\r\nexport declare function destroyLView(view: LViewData): void;\r\n/**\r\n * Determines which LViewOrLContainer to jump to when traversing back up the\r\n * tree in destroyViewTree.\r\n *\r\n * Normally, the view's parent LView should be checked, but in the case of\r\n * embedded views, the container (which is the view node's parent, but not the\r\n * LView's parent) needs to be checked for a possible next property.\r\n *\r\n * @param state The LViewOrLContainer for which we need a parent state\r\n * @param rootView The rootView, so we don't propagate too far up the view tree\r\n * @returns The correct parent LViewOrLContainer\r\n */\r\nexport declare function getParentState(state: LViewData | LContainer, rootView: LViewData): LViewData | LContainer | null;\r\nexport declare function getRenderParent(tNode: TNode, currentView: LViewData): LElementNode | null;\r\n/**\r\n * Returns whether a native element can be inserted into the given parent.\r\n *\r\n * There are two reasons why we may not be able to insert a element immediately.\r\n * - Projection: When creating a child content element of a component, we have to skip the\r\n *   insertion because the content of a component will be projected.\r\n *   `<component><content>delayed due to projection</content></component>`\r\n * - Parent container is disconnected: This can happen when we are inserting a view into\r\n *   parent container, which itself is disconnected. For example the parent container is part\r\n *   of a View which has not be inserted or is mare for projection but has not been inserted\r\n *   into destination.\r\n *\r\n\r\n *\r\n * @param parent The parent where the child will be inserted into.\r\n * @param currentView Current LView being processed.\r\n * @return boolean Whether the child should be inserted now (or delayed until later).\r\n */\r\nexport declare function canInsertNativeNode(tNode: TNode, currentView: LViewData): boolean;\r\n/**\r\n * Appends the `child` element to the `parent`.\r\n *\r\n * The element insertion might be delayed {@link canInsertNativeNode}.\r\n *\r\n * @param childEl The child that should be appended\r\n * @param childTNode The TNode of the child element\r\n * @param currentView The current LView\r\n * @returns Whether or not the child was appended\r\n */\r\nexport declare function appendChild(childEl: RNode | null, childTNode: TNode, currentView: LViewData): boolean;\r\nexport declare function getBeforeNodeForView(index: number, views: LViewData[], container: LContainerNode): RComment;\r\n/**\r\n * Removes the `child` element of the `parent` from the DOM.\r\n *\r\n * @param parentEl The parent element from which to remove the child\r\n * @param child The child that should be removed\r\n * @param currentView The current LView\r\n * @returns Whether or not the child was removed\r\n */\r\nexport declare function removeChild(tNode: TNode, child: RNode | null, currentView: LViewData): boolean;\r\n/**\r\n * Appends a projected node to the DOM, or in the case of a projected container,\r\n * appends the nodes from all of the container's active views to the DOM.\r\n *\r\n * @param projectedLNode The node to process\r\n * @param parentNode The last parent element to be processed\r\n * @param tProjectionNode\r\n * @param currentView Current LView\r\n * @param projectionView Projection view\r\n */\r\nexport declare function appendProjectedNode(projectedLNode: LElementNode | LElementContainerNode | LTextNode | LContainerNode, projectedTNode: TNode, tProjectionNode: TNode, currentView: LViewData, projectionView: LViewData): void;\r\n",
  "/node_modules/@angular/core/src/render3/node_selector_matcher.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport './ng_dev_mode';\r\nimport { TNode } from './interfaces/node';\r\nimport { CssSelector, CssSelectorList } from './interfaces/projection';\r\n/**\r\n * A utility function to match an Ivy node static data against a simple CSS selector\r\n *\r\n * @param node static data to match\r\n * @param selector\r\n * @returns true if node matches the selector.\r\n */\r\nexport declare function isNodeMatchingSelector(tNode: TNode, selector: CssSelector): boolean;\r\nexport declare function isNodeMatchingSelectorList(tNode: TNode, selector: CssSelectorList): boolean;\r\nexport declare function getProjectAsAttrValue(tNode: TNode): string | null;\r\n/**\r\n * Checks a given node against matching selectors and returns\r\n * selector index (or 0 if none matched).\r\n *\r\n * This function takes into account the ngProjectAs attribute: if present its value will be compared\r\n * to the raw (un-parsed) CSS selector instead of using standard selector matching logic.\r\n */\r\nexport declare function matchingSelectorIndex(tNode: TNode, selectors: CssSelectorList[], textSelectors: string[]): number;\r\n",
  "/node_modules/@angular/core/src/render3/pipe.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Create a pipe.\r\n *\r\n * @param index Pipe index where the pipe will be stored.\r\n * @param pipeName The name of the pipe\r\n * @returns T the instance of the pipe.\r\n */\r\nexport declare function pipe(index: number, pipeName: string): any;\r\n/**\r\n * Invokes a pipe with 1 arguments.\r\n *\r\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\r\n * the pipe only when an input to the pipe changes.\r\n *\r\n * @param index Pipe index where the pipe was stored on creation.\r\n * @param slotOffset the offset in the reserved slot space\r\n * @param v1 1st argument to {@link PipeTransform#transform}.\r\n */\r\nexport declare function pipeBind1(index: number, slotOffset: number, v1: any): any;\r\n/**\r\n * Invokes a pipe with 2 arguments.\r\n *\r\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\r\n * the pipe only when an input to the pipe changes.\r\n *\r\n * @param index Pipe index where the pipe was stored on creation.\r\n * @param slotOffset the offset in the reserved slot space\r\n * @param v1 1st argument to {@link PipeTransform#transform}.\r\n * @param v2 2nd argument to {@link PipeTransform#transform}.\r\n */\r\nexport declare function pipeBind2(index: number, slotOffset: number, v1: any, v2: any): any;\r\n/**\r\n * Invokes a pipe with 3 arguments.\r\n *\r\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\r\n * the pipe only when an input to the pipe changes.\r\n *\r\n * @param index Pipe index where the pipe was stored on creation.\r\n * @param slotOffset the offset in the reserved slot space\r\n * @param v1 1st argument to {@link PipeTransform#transform}.\r\n * @param v2 2nd argument to {@link PipeTransform#transform}.\r\n * @param v3 4rd argument to {@link PipeTransform#transform}.\r\n */\r\nexport declare function pipeBind3(index: number, slotOffset: number, v1: any, v2: any, v3: any): any;\r\n/**\r\n * Invokes a pipe with 4 arguments.\r\n *\r\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\r\n * the pipe only when an input to the pipe changes.\r\n *\r\n * @param index Pipe index where the pipe was stored on creation.\r\n * @param slotOffset the offset in the reserved slot space\r\n * @param v1 1st argument to {@link PipeTransform#transform}.\r\n * @param v2 2nd argument to {@link PipeTransform#transform}.\r\n * @param v3 3rd argument to {@link PipeTransform#transform}.\r\n * @param v4 4th argument to {@link PipeTransform#transform}.\r\n */\r\nexport declare function pipeBind4(index: number, slotOffset: number, v1: any, v2: any, v3: any, v4: any): any;\r\n/**\r\n * Invokes a pipe with variable number of arguments.\r\n *\r\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\r\n * the pipe only when an input to the pipe changes.\r\n *\r\n * @param index Pipe index where the pipe was stored on creation.\r\n * @param slotOffset the offset in the reserved slot space\r\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\r\n */\r\nexport declare function pipeBindV(index: number, slotOffset: number, values: any[]): any;\r\n",
  "/node_modules/@angular/core/src/render3/pure_function.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Bindings for pure functions are stored after regular bindings.\r\n *\r\n * |--------consts--------|----------------vars----------------|------ hostVars (dir1) ------|\r\n * ---------------------------------------------------------------------------------------------\r\n * | nodes / refs / pipes | bindings | pure function bindings  | host bindings  | host slots |\r\n * ---------------------------------------------------------------------------------------------\r\n *                        ^                                    ^\r\n *             TView.bindingStartIndex            TView.hostBindingStartIndex\r\n *\r\n * Pure function instructions are given an offset from the binding root. Adding the offset to the\r\n * binding root gives the first index where the bindings are stored. In component views, the binding\r\n * root is the bindingStartIndex. In host bindings, the binding root is the hostBindingStartIndex +\r\n * any hostVars in directives evaluated before it.\r\n */\r\n/**\r\n * If the value hasn't been saved, calls the pure function to store and return the\r\n * value. If it has been saved, returns the saved value.\r\n *\r\n * @param slotOffset the offset from binding root to the reserved slot\r\n * @param pureFn Function that returns a value\r\n * @param thisArg Optional calling context of pureFn\r\n * @returns value\r\n */\r\nexport declare function pureFunction0<T>(slotOffset: number, pureFn: () => T, thisArg?: any): T;\r\n/**\r\n * If the value of the provided exp has changed, calls the pure function to return\r\n * an updated value. Or if the value has not changed, returns cached value.\r\n *\r\n * @param slotOffset the offset from binding root to the reserved slot\r\n * @param pureFn Function that returns an updated value\r\n * @param exp Updated expression value\r\n * @param thisArg Optional calling context of pureFn\r\n * @returns Updated or cached value\r\n */\r\nexport declare function pureFunction1(slotOffset: number, pureFn: (v: any) => any, exp: any, thisArg?: any): any;\r\n/**\r\n * If the value of any provided exp has changed, calls the pure function to return\r\n * an updated value. Or if no values have changed, returns cached value.\r\n *\r\n * @param slotOffset the offset from binding root to the reserved slot\r\n * @param pureFn\r\n * @param exp1\r\n * @param exp2\r\n * @param thisArg Optional calling context of pureFn\r\n * @returns Updated or cached value\r\n */\r\nexport declare function pureFunction2(slotOffset: number, pureFn: (v1: any, v2: any) => any, exp1: any, exp2: any, thisArg?: any): any;\r\n/**\r\n * If the value of any provided exp has changed, calls the pure function to return\r\n * an updated value. Or if no values have changed, returns cached value.\r\n *\r\n * @param slotOffset the offset from binding root to the reserved slot\r\n * @param pureFn\r\n * @param exp1\r\n * @param exp2\r\n * @param exp3\r\n * @param thisArg Optional calling context of pureFn\r\n * @returns Updated or cached value\r\n */\r\nexport declare function pureFunction3(slotOffset: number, pureFn: (v1: any, v2: any, v3: any) => any, exp1: any, exp2: any, exp3: any, thisArg?: any): any;\r\n/**\r\n * If the value of any provided exp has changed, calls the pure function to return\r\n * an updated value. Or if no values have changed, returns cached value.\r\n *\r\n * @param slotOffset the offset from binding root to the reserved slot\r\n * @param pureFn\r\n * @param exp1\r\n * @param exp2\r\n * @param exp3\r\n * @param exp4\r\n * @param thisArg Optional calling context of pureFn\r\n * @returns Updated or cached value\r\n */\r\nexport declare function pureFunction4(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, thisArg?: any): any;\r\n/**\r\n * If the value of any provided exp has changed, calls the pure function to return\r\n * an updated value. Or if no values have changed, returns cached value.\r\n *\r\n * @param slotOffset the offset from binding root to the reserved slot\r\n * @param pureFn\r\n * @param exp1\r\n * @param exp2\r\n * @param exp3\r\n * @param exp4\r\n * @param exp5\r\n * @param thisArg Optional calling context of pureFn\r\n * @returns Updated or cached value\r\n */\r\nexport declare function pureFunction5(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, thisArg?: any): any;\r\n/**\r\n * If the value of any provided exp has changed, calls the pure function to return\r\n * an updated value. Or if no values have changed, returns cached value.\r\n *\r\n * @param slotOffset the offset from binding root to the reserved slot\r\n * @param pureFn\r\n * @param exp1\r\n * @param exp2\r\n * @param exp3\r\n * @param exp4\r\n * @param exp5\r\n * @param exp6\r\n * @param thisArg Optional calling context of pureFn\r\n * @returns Updated or cached value\r\n */\r\nexport declare function pureFunction6(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, thisArg?: any): any;\r\n/**\r\n * If the value of any provided exp has changed, calls the pure function to return\r\n * an updated value. Or if no values have changed, returns cached value.\r\n *\r\n * @param slotOffset the offset from binding root to the reserved slot\r\n * @param pureFn\r\n * @param exp1\r\n * @param exp2\r\n * @param exp3\r\n * @param exp4\r\n * @param exp5\r\n * @param exp6\r\n * @param exp7\r\n * @param thisArg Optional calling context of pureFn\r\n * @returns Updated or cached value\r\n */\r\nexport declare function pureFunction7(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, exp7: any, thisArg?: any): any;\r\n/**\r\n * If the value of any provided exp has changed, calls the pure function to return\r\n * an updated value. Or if no values have changed, returns cached value.\r\n *\r\n * @param slotOffset the offset from binding root to the reserved slot\r\n * @param pureFn\r\n * @param exp1\r\n * @param exp2\r\n * @param exp3\r\n * @param exp4\r\n * @param exp5\r\n * @param exp6\r\n * @param exp7\r\n * @param exp8\r\n * @param thisArg Optional calling context of pureFn\r\n * @returns Updated or cached value\r\n */\r\nexport declare function pureFunction8(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, exp7: any, exp8: any, thisArg?: any): any;\r\n/**\r\n * pureFunction instruction that can support any number of bindings.\r\n *\r\n * If the value of any provided exp has changed, calls the pure function to return\r\n * an updated value. Or if no values have changed, returns cached value.\r\n *\r\n * @param slotOffset the offset from binding root to the reserved slot\r\n * @param pureFn A pure function that takes binding values and builds an object or array\r\n * containing those values.\r\n * @param exps An array of binding values\r\n * @param thisArg Optional calling context of pureFn\r\n * @returns Updated or cached value\r\n */\r\nexport declare function pureFunctionV(slotOffset: number, pureFn: (...v: any[]) => any, exps: any[], thisArg?: any): any;\r\n",
  "/node_modules/@angular/core/src/render3/query.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { QueryList as viewEngine_QueryList } from '../linker/query_list';\r\nimport { Type } from '../type';\r\nimport { TNode } from './interfaces/node';\r\nimport { LQueries, QueryReadType } from './interfaces/query';\r\n/**\r\n * A predicate which determines if a given element/directive should be included in the query\r\n * results.\r\n */\r\nexport interface QueryPredicate<T> {\r\n    /**\r\n     * If looking for directives then it contains the directive type.\r\n     */\r\n    type: Type<T> | null;\r\n    /**\r\n     * If selector then contains local names to query for.\r\n     */\r\n    selector: string[] | null;\r\n    /**\r\n     * Indicates which token should be read from DI for this query.\r\n     */\r\n    read: QueryReadType<T> | Type<T> | null;\r\n}\r\n/**\r\n * An object representing a query, which is a combination of:\r\n * - query predicate to determines if a given element/directive should be included in the query\r\n * - values collected based on a predicate\r\n * - `QueryList` to which collected values should be reported\r\n */\r\nexport interface LQuery<T> {\r\n    /**\r\n     * Next query. Used when queries are stored as a linked list in `LQueries`.\r\n     */\r\n    next: LQuery<any> | null;\r\n    /**\r\n     * Destination to which the value should be added.\r\n     */\r\n    list: QueryList<T>;\r\n    /**\r\n     * A predicate which determines if a given element/directive should be included in the query\r\n     * results.\r\n     */\r\n    predicate: QueryPredicate<T>;\r\n    /**\r\n     * Values which have been located.\r\n     *\r\n     * This is what builds up the `QueryList._valuesTree`.\r\n     */\r\n    values: any[];\r\n    /**\r\n     * A pointer to an array that stores collected values from views. This is necessary so we know a\r\n     * container into which to insert nodes collected from views.\r\n     */\r\n    containerValues: any[] | null;\r\n}\r\nexport declare class LQueries_ implements LQueries {\r\n    parent: LQueries_ | null;\r\n    private shallow;\r\n    private deep;\r\n    constructor(parent: LQueries_ | null, shallow: LQuery<any> | null, deep: LQuery<any> | null);\r\n    track<T>(queryList: viewEngine_QueryList<T>, predicate: Type<T> | string[], descend?: boolean, read?: QueryReadType<T> | Type<T>): void;\r\n    clone(): LQueries;\r\n    container(): LQueries | null;\r\n    createView(): LQueries | null;\r\n    insertView(index: number): void;\r\n    addNode(tNode: TNode): LQueries | null;\r\n    removeView(): void;\r\n}\r\nexport declare type QueryList<T> = viewEngine_QueryList<T>;\r\nexport declare const QueryList: typeof viewEngine_QueryList;\r\n/**\r\n * Creates and returns a QueryList.\r\n *\r\n * @param memoryIndex The index in memory where the QueryList should be saved. If null,\r\n * this is is a content query and the QueryList will be saved later through directiveCreate.\r\n * @param predicate The type for which the query will search\r\n * @param descend Whether or not to descend into children\r\n * @param read What to save in the query\r\n * @returns QueryList<T>\r\n */\r\nexport declare function query<T>(memoryIndex: number | null, predicate: Type<any> | string[], descend?: boolean, read?: QueryReadType<T> | Type<T>): QueryList<T>;\r\n/**\r\n * Refreshes a query by combining matches from all active views and removing matches from deleted\r\n * views.\r\n * Returns true if a query got dirty during change detection, false otherwise.\r\n */\r\nexport declare function queryRefresh(queryList: QueryList<any>): boolean;\r\n",
  "/node_modules/@angular/core/src/render3/styling.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { StyleSanitizeFn } from '../sanitization/style_sanitizer';\r\nimport { InitialStylingFlags } from './interfaces/definition';\r\nimport { LElementNode } from './interfaces/node';\r\nimport { Renderer3 } from './interfaces/renderer';\r\n/**\r\n * The styling context acts as a styling manifest (shaped as an array) for determining which\r\n * styling properties have been assigned via the provided `updateStylingMap`, `updateStyleProp`\r\n * and `updateClassProp` functions. There are also two initialization functions\r\n * `allocStylingContext` and `createStylingContextTemplate` which are used to initialize\r\n * and/or clone the context.\r\n *\r\n * The context is an array where the first two cells are used for static data (initial styling)\r\n * and dirty flags / index offsets). The remaining set of cells is used for multi (map) and single\r\n * (prop) style values.\r\n *\r\n * each value from here onwards is mapped as so:\r\n * [i] = mutation/type flag for the style/class value\r\n * [i + 1] = prop string (or null incase it has been removed)\r\n * [i + 2] = value string (or null incase it has been removed)\r\n *\r\n * There are three types of styling types stored in this context:\r\n *   initial: any styles that are passed in once the context is created\r\n *            (these are stored in the first cell of the array and the first\r\n *             value of this array is always `null` even if no initial styling exists.\r\n *             the `null` value is there so that any new styles have a parent to point\r\n *             to. This way we can always assume that there is a parent.)\r\n *\r\n *   single: any styles that are updated using `updateStyleProp` or `updateClassProp` (fixed set)\r\n *\r\n *   multi: any styles that are updated using `updateStylingMap` (dynamic set)\r\n *\r\n * Note that context is only used to collect style information. Only when `renderStyling`\r\n * is called is when the styling payload will be rendered (or built as a key/value map).\r\n *\r\n * When the context is created, depending on what initial styling values are passed in, the\r\n * context itself will be pre-filled with slots based on the initial style properties. Say\r\n * for example we have a series of initial styles that look like so:\r\n *\r\n *   style=\"width:100px; height:200px;\"\r\n *   class=\"foo\"\r\n *\r\n * Then the initial state of the context (once initialized) will look like so:\r\n *\r\n * ```\r\n * context = [\r\n *   element,\r\n *   styleSanitizer | null,\r\n *   [null, '100px', '200px', true],  // property names are not needed since they have already been\r\n * written to DOM.\r\n *\r\n *   configMasterVal,\r\n *   1, // this instructs how many `style` values there are so that class index values can be\r\n * offsetted\r\n *   'last class string applied',\r\n *\r\n *   // 6\r\n *   'width',\r\n *   pointers(1, 15);  // Point to static `width`: `100px` and multi `width`.\r\n *   null,\r\n *\r\n *   // 9\r\n *   'height',\r\n *   pointers(2, 18); // Point to static `height`: `200px` and multi `height`.\r\n *   null,\r\n *\r\n *   // 12\r\n *   'foo',\r\n *   pointers(1, 21);  // Point to static `foo`: `true` and multi `foo`.\r\n *   null,\r\n *\r\n *   // 15\r\n *   'width',\r\n *   pointers(1, 6);  // Point to static `width`: `100px` and single `width`.\r\n *   null,\r\n *\r\n *   // 18\r\n *   'height',\r\n *   pointers(2, 9);  // Point to static `height`: `200px` and single `height`.\r\n *   null,\r\n *\r\n *   // 21\r\n *   'foo',\r\n *   pointers(3, 12);  // Point to static `foo`: `true` and single `foo`.\r\n *   null,\r\n * ]\r\n *\r\n * function pointers(staticIndex: number, dynamicIndex: number) {\r\n *   // combine the two indices into a single word.\r\n *   return (staticIndex << StylingFlags.BitCountSize) |\r\n *     (dynamicIndex << (StylingIndex.BitCountSize + StylingFlags.BitCountSize));\r\n * }\r\n * ```\r\n *\r\n * The values are duplicated so that space is set aside for both multi ([style] and [class])\r\n * and single ([style.prop] or [class.named]) values. The respective config values\r\n * (configValA, configValB, etc...) are a combination of the StylingFlags with two index\r\n * values: the `initialIndex` (which points to the index location of the style value in\r\n * the initial styles array in slot 0) and the `dynamicIndex` (which points to the\r\n * matching single/multi index position in the context array for the same prop).\r\n *\r\n * This means that every time `updateStyleProp` or `updateClassProp` are called then they\r\n * must be called using an index value (not a property string) which references the index\r\n * value of the initial style prop/class when the context was created. This also means that\r\n * `updateStyleProp` or `updateClassProp` cannot be called with a new property (only\r\n * `updateStylingMap` can include new CSS properties that will be added to the context).\r\n */\r\nexport interface StylingContext extends Array<InitialStyles | number | string | boolean | LElementNode | StyleSanitizeFn | null> {\r\n    /**\r\n     * Location of element that is used as a target for this context.\r\n     */\r\n    [0]: LElementNode | null;\r\n    /**\r\n     * The style sanitizer that is used within this context\r\n     */\r\n    [1]: StyleSanitizeFn | null;\r\n    /**\r\n     * Location of initial data shared by all instances of this style.\r\n     */\r\n    [2]: InitialStyles;\r\n    /**\r\n     * A numeric value representing the configuration status (whether the context is dirty or not)\r\n     * mixed together (using bit shifting) with a index value which tells the starting index value\r\n     * of where the multi style entries begin.\r\n     */\r\n    [3]: number;\r\n    /**\r\n     * A numeric value representing the class index offset value. Whenever a single class is\r\n     * applied (using `elementClassProp`) it should have an styling index value that doesn't\r\n     * need to take into account any style values that exist in the context.\r\n     */\r\n    [4]: number;\r\n    /**\r\n     * The last CLASS STRING VALUE that was interpreted by elementStylingMap. This is cached\r\n     * So that the algorithm can exit early incase the string has not changed.\r\n     */\r\n    [5]: string | null;\r\n}\r\n/**\r\n * The initial styles is populated whether or not there are any initial styles passed into\r\n * the context during allocation. The 0th value must be null so that index values of `0` within\r\n * the context flags can always point to a null value safely when nothing is set.\r\n *\r\n * All other entries in this array are of `string` value and correspond to the values that\r\n * were extracted from the `style=\"\"` attribute in the HTML code for the provided template.\r\n */\r\nexport interface InitialStyles extends Array<string | null | boolean> {\r\n    [0]: null;\r\n}\r\n/**\r\n * Used to set the context to be dirty or not both on the master flag (position 1)\r\n * or for each single/multi property that exists in the context.\r\n */\r\nexport declare const enum StylingFlags {\r\n    None = 0,\r\n    Dirty = 1,\r\n    Class = 2,\r\n    Sanitize = 4,\r\n    BitCountSize = 3,\r\n    BitMask = 7\r\n}\r\n/** Used as numeric pointer values to determine what cells to update in the `StylingContext` */\r\nexport declare const enum StylingIndex {\r\n    ElementPosition = 0,\r\n    StyleSanitizerPosition = 1,\r\n    InitialStylesPosition = 2,\r\n    MasterFlagPosition = 3,\r\n    ClassOffsetPosition = 4,\r\n    CachedCssClassString = 5,\r\n    SingleStylesStartPosition = 6,\r\n    FlagsOffset = 0,\r\n    PropertyOffset = 1,\r\n    ValueOffset = 2,\r\n    Size = 3,\r\n    BitCountSize = 14,\r\n    BitMask = 16383\r\n}\r\n/**\r\n * Used clone a copy of a pre-computed template of a styling context.\r\n *\r\n * A pre-computed template is designed to be computed once for a given element\r\n * (instructions.ts has logic for caching this).\r\n */\r\nexport declare function allocStylingContext(lElement: LElementNode | null, templateStyleContext: StylingContext): StylingContext;\r\n/**\r\n * Creates a styling context template where styling information is stored.\r\n * Any styles that are later referenced using `updateStyleProp` must be\r\n * passed in within this function. Initial values for those styles are to\r\n * be declared after all initial style properties are declared (this change in\r\n * mode between declarations and initial styles is made possible using a special\r\n * enum value found in `definition.ts`).\r\n *\r\n * @param initialStyleDeclarations a list of style declarations and initial style values\r\n *    that are used later within the styling context.\r\n *\r\n *    -> ['width', 'height', SPECIAL_ENUM_VAL, 'width', '100px']\r\n *       This implies that `width` and `height` will be later styled and that the `width`\r\n *       property has an initial value of `100px`.\r\n *\r\n * @param initialClassDeclarations a list of class declarations and initial class values\r\n *    that are used later within the styling context.\r\n *\r\n *    -> ['foo', 'bar', SPECIAL_ENUM_VAL, 'foo', true]\r\n *       This implies that `foo` and `bar` will be later styled and that the `foo`\r\n *       class will be applied to the element as an initial class since it's true\r\n */\r\nexport declare function createStylingContextTemplate(initialClassDeclarations?: (string | boolean | InitialStylingFlags)[] | null, initialStyleDeclarations?: (string | boolean | InitialStylingFlags)[] | null, styleSanitizer?: StyleSanitizeFn | null): StylingContext;\r\n/**\r\n * Sets and resolves all `multi` styling on an `StylingContext` so that they can be\r\n * applied to the element once `renderStyling` is called.\r\n *\r\n * All missing styles/class (any values that are not provided in the new `styles`\r\n * or `classes` params) will resolve to `null` within their respective positions\r\n * in the context.\r\n *\r\n * @param context The styling context that will be updated with the\r\n *    newly provided style values.\r\n * @param classes The key/value map of CSS class names that will be used for the update.\r\n * @param styles The key/value map of CSS styles that will be used for the update.\r\n */\r\nexport declare function updateStylingMap(context: StylingContext, classes: {\r\n    [key: string]: any;\r\n} | string | null, styles?: {\r\n    [key: string]: any;\r\n} | null): void;\r\n/**\r\n * Sets and resolves a single styling property/value on the provided `StylingContext` so\r\n * that they can be applied to the element once `renderStyling` is called.\r\n *\r\n * Note that prop-level styling values are considered higher priority than any styling that\r\n * has been applied using `updateStylingMap`, therefore, when styling values are rendered\r\n * then any styles/classes that have been applied using this function will be considered first\r\n * (then multi values second and then initial values as a backup).\r\n *\r\n * @param context The styling context that will be updated with the\r\n *    newly provided style value.\r\n * @param index The index of the property which is being updated.\r\n * @param value The CSS style value that will be assigned\r\n */\r\nexport declare function updateStyleProp(context: StylingContext, index: number, value: string | boolean | null): void;\r\n/**\r\n * This method will toggle the referenced CSS class (by the provided index)\r\n * within the given context.\r\n *\r\n * @param context The styling context that will be updated with the\r\n *    newly provided class value.\r\n * @param index The index of the CSS class which is being updated.\r\n * @param addOrRemove Whether or not to add or remove the CSS class\r\n */\r\nexport declare function updateClassProp(context: StylingContext, index: number, addOrRemove: boolean): void;\r\n/**\r\n * Renders all queued styling using a renderer onto the given element.\r\n *\r\n * This function works by rendering any styles (that have been applied\r\n * using `updateStylingMap`) and any classes (that have been applied using\r\n * `updateStyleProp`) onto the provided element using the provided renderer.\r\n * Just before the styles/classes are rendered a final key/value style map\r\n * will be assembled (if `styleStore` or `classStore` are provided).\r\n *\r\n * @param lElement the element that the styles will be rendered on\r\n * @param context The styling context that will be used to determine\r\n *      what styles will be rendered\r\n * @param renderer the renderer that will be used to apply the styling\r\n * @param styleStore if provided, the updated style values will be applied\r\n *    to this key/value map instead of being renderered via the renderer.\r\n * @param classStore if provided, the updated class values will be applied\r\n *    to this key/value map instead of being renderered via the renderer.\r\n */\r\nexport declare function renderStyling(context: StylingContext, renderer: Renderer3, styleStore?: {\r\n    [key: string]: any;\r\n}, classStore?: {\r\n    [key: string]: boolean;\r\n}): void;\r\nexport declare function isContextDirty(context: StylingContext): boolean;\r\nexport declare function setContextDirty(context: StylingContext, isDirtyYes: boolean): void;\r\n",
  "/node_modules/@angular/core/src/render3/util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { LElementNode, TNode } from './interfaces/node';\r\nimport { LViewData, TData } from './interfaces/view';\r\n/**\r\n * Returns whether the values are different from a change detection stand point.\r\n *\r\n * Constraints are relaxed in checkNoChanges mode. See `devModeEqual` for details.\r\n */\r\nexport declare function isDifferent(a: any, b: any, checkNoChangesMode: boolean): boolean;\r\nexport declare function stringify(value: any): string;\r\n/**\r\n *  Function that throws a \"not implemented\" error so it's clear certain\r\n *  behaviors/methods aren't yet ready.\r\n *\r\n * @returns Not implemented error\r\n */\r\nexport declare function notImplemented(): Error;\r\n/**\r\n * Flattens an array in non-recursive way. Input arrays are not modified.\r\n */\r\nexport declare function flatten(list: any[]): any[];\r\n/** Retrieves a value from any `LViewData` or `TData`. */\r\nexport declare function loadInternal<T>(index: number, arr: LViewData | TData): T;\r\nexport declare function assertDataInRangeInternal(index: number, arr: any[]): void;\r\n/** Retrieves an element value from the provided `viewData`.\r\n  *\r\n  * Elements that are read may be wrapped in a style context,\r\n  * therefore reading the value may involve unwrapping that.\r\n  */\r\nexport declare function loadElementInternal(index: number, arr: LViewData): LElementNode;\r\nexport declare function readElementValue(value: LElementNode | any[]): LElementNode;\r\nexport declare function isContentQueryHost(tNode: TNode): boolean;\r\nexport declare function isComponent(tNode: TNode): boolean;\r\n",
  "/node_modules/@angular/core/src/render3/view_ref.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ApplicationRef } from '../application_ref';\r\nimport { ChangeDetectorRef as viewEngine_ChangeDetectorRef } from '../change_detection/change_detector_ref';\r\nimport { ViewContainerRef as viewEngine_ViewContainerRef } from '../linker/view_container_ref';\r\nimport { EmbeddedViewRef as viewEngine_EmbeddedViewRef, InternalViewRef as viewEngine_InternalViewRef } from '../linker/view_ref';\r\nimport { TViewNode } from './interfaces/node';\r\nimport { LViewData } from './interfaces/view';\r\nexport interface viewEngine_ChangeDetectorRef_interface extends viewEngine_ChangeDetectorRef {\r\n}\r\nexport declare class ViewRef<T> implements viewEngine_EmbeddedViewRef<T>, viewEngine_InternalViewRef, viewEngine_ChangeDetectorRef_interface {\r\n    private _appRef;\r\n    private _viewContainerRef;\r\n    /**\r\n     * @internal\r\n     */\r\n    _view: LViewData;\r\n    /**\r\n     * @internal\r\n     */\r\n    _tViewNode: TViewNode | null;\r\n    context: T;\r\n    rootNodes: any[];\r\n    constructor(_view: LViewData, context: T | null);\r\n    /** @internal */\r\n    _setComponentContext(view: LViewData, context: T): void;\r\n    readonly destroyed: boolean;\r\n    destroy(): void;\r\n    onDestroy(callback: Function): void;\r\n    /**\r\n     * Marks a view and all of its ancestors dirty.\r\n     *\r\n     * It also triggers change detection by calling `scheduleTick` internally, which coalesces\r\n     * multiple `markForCheck` calls to into one change detection run.\r\n     *\r\n     * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\r\n     * checked when it needs to be re-rendered but the two normal triggers haven't marked it\r\n     * dirty (i.e. inputs haven't changed and events haven't fired in the view).\r\n     *\r\n     * <!-- TODO: Add a link to a chapter on OnPush components -->\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * @Component({\r\n     *   selector: 'my-app',\r\n     *   template: `Number of ticks: {{numberOfTicks}}`\r\n     *   changeDetection: ChangeDetectionStrategy.OnPush,\r\n     * })\r\n     * class AppComponent {\r\n     *   numberOfTicks = 0;\r\n     *\r\n     *   constructor(private ref: ChangeDetectorRef) {\r\n     *     setInterval(() => {\r\n     *       this.numberOfTicks++;\r\n     *       // the following is required, otherwise the view will not be updated\r\n     *       this.ref.markForCheck();\r\n     *     }, 1000);\r\n     *   }\r\n     * }\r\n     * ```\r\n     */\r\n    markForCheck(): void;\r\n    /**\r\n     * Detaches the view from the change detection tree.\r\n     *\r\n     * Detached views will not be checked during change detection runs until they are\r\n     * re-attached, even if they are dirty. `detach` can be used in combination with\r\n     * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\r\n     * detection checks.\r\n     *\r\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\r\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * The following example defines a component with a large list of readonly data.\r\n     * Imagine the data changes constantly, many times per second. For performance reasons,\r\n     * we want to check and update the list every five seconds. We can do that by detaching\r\n     * the component's change detector and doing a local check every five seconds.\r\n     *\r\n     * ```typescript\r\n     * class DataProvider {\r\n     *   // in a real application the returned data will be different every time\r\n     *   get data() {\r\n     *     return [1,2,3,4,5];\r\n     *   }\r\n     * }\r\n     *\r\n     * @Component({\r\n     *   selector: 'giant-list',\r\n     *   template: `\r\n     *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\r\n     *   `,\r\n     * })\r\n     * class GiantList {\r\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\r\n     *     ref.detach();\r\n     *     setInterval(() => {\r\n     *       this.ref.detectChanges();\r\n     *     }, 5000);\r\n     *   }\r\n     * }\r\n     *\r\n     * @Component({\r\n     *   selector: 'app',\r\n     *   providers: [DataProvider],\r\n     *   template: `\r\n     *     <giant-list><giant-list>\r\n     *   `,\r\n     * })\r\n     * class App {\r\n     * }\r\n     * ```\r\n     */\r\n    detach(): void;\r\n    /**\r\n     * Re-attaches a view to the change detection tree.\r\n     *\r\n     * This can be used to re-attach views that were previously detached from the tree\r\n     * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\r\n     *\r\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * The following example creates a component displaying `live` data. The component will detach\r\n     * its change detector from the main change detector tree when the component's live property\r\n     * is set to false.\r\n     *\r\n     * ```typescript\r\n     * class DataProvider {\r\n     *   data = 1;\r\n     *\r\n     *   constructor() {\r\n     *     setInterval(() => {\r\n     *       this.data = this.data * 2;\r\n     *     }, 500);\r\n     *   }\r\n     * }\r\n     *\r\n     * @Component({\r\n     *   selector: 'live-data',\r\n     *   inputs: ['live'],\r\n     *   template: 'Data: {{dataProvider.data}}'\r\n     * })\r\n     * class LiveData {\r\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\r\n     *\r\n     *   set live(value) {\r\n     *     if (value) {\r\n     *       this.ref.reattach();\r\n     *     } else {\r\n     *       this.ref.detach();\r\n     *     }\r\n     *   }\r\n     * }\r\n     *\r\n     * @Component({\r\n     *   selector: 'my-app',\r\n     *   providers: [DataProvider],\r\n     *   template: `\r\n     *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\r\n     *     <live-data [live]=\"live\"><live-data>\r\n     *   `,\r\n     * })\r\n     * class AppComponent {\r\n     *   live = true;\r\n     * }\r\n     * ```\r\n     */\r\n    reattach(): void;\r\n    /**\r\n     * Checks the view and its children.\r\n     *\r\n     * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\r\n     * local change detection checks.\r\n     *\r\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\r\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * The following example defines a component with a large list of readonly data.\r\n     * Imagine, the data changes constantly, many times per second. For performance reasons,\r\n     * we want to check and update the list every five seconds.\r\n     *\r\n     * We can do that by detaching the component's change detector and doing a local change detection\r\n     * check every five seconds.\r\n     *\r\n     * See {@link ChangeDetectorRef#detach detach} for more information.\r\n     */\r\n    detectChanges(): void;\r\n    /**\r\n     * Checks the change detector and its children, and throws if any changes are detected.\r\n     *\r\n     * This is used in development mode to verify that running change detection doesn't\r\n     * introduce other changes.\r\n     */\r\n    checkNoChanges(): void;\r\n    attachToViewContainerRef(vcRef: viewEngine_ViewContainerRef): void;\r\n    detachFromAppRef(): void;\r\n    attachToAppRef(appRef: ApplicationRef): void;\r\n}\r\n/** @internal */\r\nexport declare class RootViewRef<T> extends ViewRef<T> {\r\n    _view: LViewData;\r\n    constructor(_view: LViewData);\r\n    detectChanges(): void;\r\n    checkNoChanges(): void;\r\n}\r\n",
  "/node_modules/@angular/core/src/sanitization/bypass.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\ndeclare const BRAND = \"__SANITIZER_TRUSTED_BRAND__\";\r\nexport declare const enum BypassType {\r\n    Url = \"Url\",\r\n    Html = \"Html\",\r\n    ResourceUrl = \"ResourceUrl\",\r\n    Script = \"Script\",\r\n    Style = \"Style\"\r\n}\r\n/**\r\n * A branded trusted string used with sanitization.\r\n *\r\n * See: {@link TrustedHtmlString}, {@link TrustedResourceUrlString}, {@link TrustedScriptString},\r\n * {@link TrustedStyleString}, {@link TrustedUrlString}\r\n */\r\nexport interface TrustedString extends String {\r\n    [BRAND]: BypassType;\r\n}\r\n/**\r\n * A branded trusted string used with sanitization of `html` strings.\r\n *\r\n * See: {@link bypassSanitizationTrustHtml} and {@link htmlSanitizer}.\r\n */\r\nexport interface TrustedHtmlString extends TrustedString {\r\n    [BRAND]: BypassType.Html;\r\n}\r\n/**\r\n * A branded trusted string used with sanitization of `style` strings.\r\n *\r\n * See: {@link bypassSanitizationTrustStyle} and {@link styleSanitizer}.\r\n */\r\nexport interface TrustedStyleString extends TrustedString {\r\n    [BRAND]: BypassType.Style;\r\n}\r\n/**\r\n * A branded trusted string used with sanitization of `url` strings.\r\n *\r\n * See: {@link bypassSanitizationTrustScript} and {@link scriptSanitizer}.\r\n */\r\nexport interface TrustedScriptString extends TrustedString {\r\n    [BRAND]: BypassType.Script;\r\n}\r\n/**\r\n * A branded trusted string used with sanitization of `url` strings.\r\n *\r\n * See: {@link bypassSanitizationTrustUrl} and {@link urlSanitizer}.\r\n */\r\nexport interface TrustedUrlString extends TrustedString {\r\n    [BRAND]: BypassType.Url;\r\n}\r\n/**\r\n * A branded trusted string used with sanitization of `resourceUrl` strings.\r\n *\r\n * See: {@link bypassSanitizationTrustResourceUrl} and {@link resourceUrlSanitizer}.\r\n */\r\nexport interface TrustedResourceUrlString extends TrustedString {\r\n    [BRAND]: BypassType.ResourceUrl;\r\n}\r\nexport declare function allowSanitizationBypass(value: any, type: BypassType): boolean;\r\n/**\r\n * Mark `html` string as trusted.\r\n *\r\n * This function wraps the trusted string in `String` and brands it in a way which makes it\r\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\r\n *\r\n * @param trustedHtml `html` string which needs to be implicitly trusted.\r\n * @returns a `html` `String` which has been branded to be implicitly trusted.\r\n */\r\nexport declare function bypassSanitizationTrustHtml(trustedHtml: string): TrustedHtmlString;\r\n/**\r\n * Mark `style` string as trusted.\r\n *\r\n * This function wraps the trusted string in `String` and brands it in a way which makes it\r\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\r\n *\r\n * @param trustedStyle `style` string which needs to be implicitly trusted.\r\n * @returns a `style` `String` which has been branded to be implicitly trusted.\r\n */\r\nexport declare function bypassSanitizationTrustStyle(trustedStyle: string): TrustedStyleString;\r\n/**\r\n * Mark `script` string as trusted.\r\n *\r\n * This function wraps the trusted string in `String` and brands it in a way which makes it\r\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\r\n *\r\n * @param trustedScript `script` string which needs to be implicitly trusted.\r\n * @returns a `script` `String` which has been branded to be implicitly trusted.\r\n */\r\nexport declare function bypassSanitizationTrustScript(trustedScript: string): TrustedScriptString;\r\n/**\r\n * Mark `url` string as trusted.\r\n *\r\n * This function wraps the trusted string in `String` and brands it in a way which makes it\r\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\r\n *\r\n * @param trustedUrl `url` string which needs to be implicitly trusted.\r\n * @returns a `url` `String` which has been branded to be implicitly trusted.\r\n */\r\nexport declare function bypassSanitizationTrustUrl(trustedUrl: string): TrustedUrlString;\r\n/**\r\n * Mark `url` string as trusted.\r\n *\r\n * This function wraps the trusted string in `String` and brands it in a way which makes it\r\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\r\n *\r\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\r\n * @returns a `url` `String` which has been branded to be implicitly trusted.\r\n */\r\nexport declare function bypassSanitizationTrustResourceUrl(trustedResourceUrl: string): TrustedResourceUrlString;\r\nexport {};\r\n",
  "/node_modules/@angular/core/src/sanitization/html_sanitizer.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\r\n * the DOM in a browser environment.\r\n */\r\nexport declare function _sanitizeHtml(defaultDoc: any, unsafeHtmlInput: string): string;\r\n",
  "/node_modules/@angular/core/src/sanitization/inert_body.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * This helper class is used to get hold of an inert tree of DOM elements containing dirty HTML\r\n * that needs sanitizing.\r\n * Depending upon browser support we must use one of three strategies for doing this.\r\n * Support: Safari 10.x -> XHR strategy\r\n * Support: Firefox -> DomParser strategy\r\n * Default: InertDocument strategy\r\n */\r\nexport declare class InertBodyHelper {\r\n    private defaultDoc;\r\n    private inertBodyElement;\r\n    private inertDocument;\r\n    constructor(defaultDoc: Document);\r\n    /**\r\n     * Get an inert DOM element containing DOM created from the dirty HTML string provided.\r\n     * The implementation of this is determined in the constructor, when the class is instantiated.\r\n     */\r\n    getInertBodyElement: (html: string) => HTMLElement | null;\r\n    /**\r\n     * Use XHR to create and fill an inert body element (on Safari 10.1)\r\n     * See\r\n     * https://github.com/cure53/DOMPurify/blob/a992d3a75031cb8bb032e5ea8399ba972bdf9a65/src/purify.js#L439-L449\r\n     */\r\n    private getInertBodyElement_XHR;\r\n    /**\r\n     * Use DOMParser to create and fill an inert body element (on Firefox)\r\n     * See https://github.com/cure53/DOMPurify/releases/tag/0.6.7\r\n     *\r\n     */\r\n    private getInertBodyElement_DOMParser;\r\n    /**\r\n     * Use an HTML5 `template` element, if supported, or an inert body element created via\r\n     * `createHtmlDocument` to create and fill an inert DOM element.\r\n     * This is the default sane strategy to use if the browser does not require one of the specialised\r\n     * strategies above.\r\n     */\r\n    private getInertBodyElement_InertDocument;\r\n    /**\r\n     * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\r\n     * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.\r\n     * 'ns1:xlink:foo').\r\n     *\r\n     * This is undesirable since we don't want to allow any of these custom attributes. This method\r\n     * strips them all.\r\n     */\r\n    private stripCustomNsAttrs;\r\n}\r\n",
  "/node_modules/@angular/core/src/sanitization/sanitization.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { StyleSanitizeFn } from './style_sanitizer';\r\n/**\r\n * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing\r\n * dangerous content.\r\n *\r\n * This method parses the `html` and locates potentially dangerous content (such as urls and\r\n * javascript) and removes it.\r\n *\r\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.\r\n *\r\n * @param unsafeHtml untrusted `html`, typically from the user.\r\n * @returns `html` string which is safe to display to user, because all of the dangerous javascript\r\n * and urls have been removed.\r\n */\r\nexport declare function sanitizeHtml(unsafeHtml: any): string;\r\n/**\r\n * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing\r\n * dangerous content.\r\n *\r\n * This method parses the `style` and locates potentially dangerous content (such as urls and\r\n * javascript) and removes it.\r\n *\r\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.\r\n *\r\n * @param unsafeStyle untrusted `style`, typically from the user.\r\n * @returns `style` string which is safe to bind to the `style` properties, because all of the\r\n * dangerous javascript and urls have been removed.\r\n */\r\nexport declare function sanitizeStyle(unsafeStyle: any): string;\r\n/**\r\n * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing\r\n * dangerous\r\n * content.\r\n *\r\n * This method parses the `url` and locates potentially dangerous content (such as javascript) and\r\n * removes it.\r\n *\r\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.\r\n *\r\n * @param unsafeUrl untrusted `url`, typically from the user.\r\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\r\n * all of the dangerous javascript has been removed.\r\n */\r\nexport declare function sanitizeUrl(unsafeUrl: any): string;\r\n/**\r\n * A `url` sanitizer which only lets trusted `url`s through.\r\n *\r\n * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.\r\n *\r\n * @param unsafeResourceUrl untrusted `url`, typically from the user.\r\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\r\n * only trusted `url`s have been allowed to pass.\r\n */\r\nexport declare function sanitizeResourceUrl(unsafeResourceUrl: any): string;\r\n/**\r\n * A `script` sanitizer which only lets trusted javascript through.\r\n *\r\n * This passes only `script`s marked trusted by calling {@link bypassSanitizationTrustScript}.\r\n *\r\n * @param unsafeScript untrusted `script`, typically from the user.\r\n * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,\r\n * because only trusted `scripts`s have been allowed to pass.\r\n */\r\nexport declare function sanitizeScript(unsafeScript: any): string;\r\n/**\r\n * The default style sanitizer will handle sanitization for style properties by\r\n * sanitizing any CSS property that can include a `url` value (usually image-based properties)\r\n */\r\nexport declare const defaultStyleSanitizer: StyleSanitizeFn;\r\n",
  "/node_modules/@angular/core/src/sanitization/security.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\r\n * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\r\n * handled.\r\n *\r\n * See DomSanitizer for more details on security in Angular applications.\r\n *\r\n *\r\n */\r\nexport declare enum SecurityContext {\r\n    NONE = 0,\r\n    HTML = 1,\r\n    STYLE = 2,\r\n    SCRIPT = 3,\r\n    URL = 4,\r\n    RESOURCE_URL = 5\r\n}\r\n/**\r\n * Sanitizer is used by the views to sanitize potentially dangerous values.\r\n *\r\n *\r\n */\r\nexport declare abstract class Sanitizer {\r\n    abstract sanitize(context: SecurityContext, value: {} | string | null): string | null;\r\n}\r\n",
  "/node_modules/@angular/core/src/sanitization/style_sanitizer.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single\r\n * value) and returns a value that is safe to use in a browser environment.\r\n */\r\nexport declare function _sanitizeStyle(value: string): string;\r\n/**\r\n * Used to intercept and sanitize style values before they are written to the renderer.\r\n *\r\n * This function is designed to be called in two modes. When a value is not provided\r\n * then the function will return a boolean whether a property will be sanitized later.\r\n * If a value is provided then the sanitized version of that will be returned.\r\n */\r\nexport interface StyleSanitizeFn {\r\n    /** This mode is designed to instruct whether the property will be used for sanitization\r\n     * at a later point */\r\n    (prop: string): boolean;\r\n    /** This mode is designed to sanitize the provided value */\r\n    (prop: string, value: string): string;\r\n}\r\n",
  "/node_modules/@angular/core/src/sanitization/url_sanitizer.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare function _sanitizeUrl(url: string): string;\r\nexport declare function sanitizeSrcset(srcset: string): string;\r\n",
  "/node_modules/@angular/core/src/testability/testability.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { NgZone } from '../zone/ng_zone';\r\n/**\r\n * Testability API.\r\n * `declare` keyword causes tsickle to generate externs, so these methods are\r\n * not renamed by Closure Compiler.\r\n * @experimental\r\n */\r\nexport declare interface PublicTestability {\r\n    isStable(): boolean;\r\n    whenStable(callback: Function, timeout?: number, updateCallback?: Function): void;\r\n    findProviders(using: any, provider: string, exactMatch: boolean): any[];\r\n}\r\nexport interface PendingMacrotask {\r\n    source: string;\r\n    creationLocation: Error;\r\n    runCount?: number;\r\n    data: TaskData;\r\n}\r\nexport interface TaskData {\r\n    target?: XMLHttpRequest;\r\n    delay?: number;\r\n    isPeriodic?: boolean;\r\n}\r\nexport declare type DoneCallback = (didWork: boolean, tasks?: PendingMacrotask[]) => void;\r\nexport declare type UpdateCallback = (tasks: PendingMacrotask[]) => boolean;\r\n/**\r\n * The Testability service provides testing hooks that can be accessed from\r\n * the browser and by services such as Protractor. Each bootstrapped Angular\r\n * application on the page will have an instance of Testability.\r\n * @experimental\r\n */\r\nexport declare class Testability implements PublicTestability {\r\n    private _ngZone;\r\n    private _pendingCount;\r\n    private _isZoneStable;\r\n    /**\r\n     * Whether any work was done since the last 'whenStable' callback. This is\r\n     * useful to detect if this could have potentially destabilized another\r\n     * component while it is stabilizing.\r\n     * @internal\r\n     */\r\n    private _didWork;\r\n    private _callbacks;\r\n    private taskTrackingZone;\r\n    constructor(_ngZone: NgZone);\r\n    private _watchAngularEvents;\r\n    /**\r\n     * Increases the number of pending request\r\n     * @deprecated pending requests are now tracked with zones.\r\n     */\r\n    increasePendingRequestCount(): number;\r\n    /**\r\n     * Decreases the number of pending request\r\n     * @deprecated pending requests are now tracked with zones\r\n     */\r\n    decreasePendingRequestCount(): number;\r\n    /**\r\n     * Whether an associated application is stable\r\n     */\r\n    isStable(): boolean;\r\n    private _runCallbacksIfReady;\r\n    private getPendingTasks;\r\n    private addCallback;\r\n    /**\r\n     * Wait for the application to be stable with a timeout. If the timeout is reached before that\r\n     * happens, the callback receives a list of the macro tasks that were pending, otherwise null.\r\n     *\r\n     * @param doneCb The callback to invoke when Angular is stable or the timeout expires\r\n     *    whichever comes first.\r\n     * @param timeout Optional. The maximum time to wait for Angular to become stable. If not\r\n     *    specified, whenStable() will wait forever.\r\n     * @param updateCb Optional. If specified, this callback will be invoked whenever the set of\r\n     *    pending macrotasks changes. If this callback returns true doneCb will not be invoked\r\n     *    and no further updates will be issued.\r\n     */\r\n    whenStable(doneCb: Function, timeout?: number, updateCb?: Function): void;\r\n    /**\r\n     * Get the number of pending requests\r\n     * @deprecated pending requests are now tracked with zones\r\n     */\r\n    getPendingRequestCount(): number;\r\n    /**\r\n     * Find providers by name\r\n     * @param using The root element to search from\r\n     * @param provider The name of binding variable\r\n     * @param exactMatch Whether using exactMatch\r\n     */\r\n    findProviders(using: any, provider: string, exactMatch: boolean): any[];\r\n}\r\n/**\r\n * A global registry of {@link Testability} instances for specific elements.\r\n * @experimental\r\n */\r\nexport declare class TestabilityRegistry {\r\n    /** @internal */\r\n    _applications: Map<any, Testability>;\r\n    constructor();\r\n    /**\r\n     * Registers an application with a testability hook so that it can be tracked\r\n     * @param token token of application, root element\r\n     * @param testability Testability hook\r\n     */\r\n    registerApplication(token: any, testability: Testability): void;\r\n    /**\r\n     * Unregisters an application.\r\n     * @param token token of application, root element\r\n     */\r\n    unregisterApplication(token: any): void;\r\n    /**\r\n     * Unregisters all applications\r\n     */\r\n    unregisterAllApplications(): void;\r\n    /**\r\n     * Get a testability hook associated with the application\r\n     * @param elem root element\r\n     */\r\n    getTestability(elem: any): Testability | null;\r\n    /**\r\n     * Get all registered testabilities\r\n     */\r\n    getAllTestabilities(): Testability[];\r\n    /**\r\n     * Get all registered applications(root elements)\r\n     */\r\n    getAllRootElements(): any[];\r\n    /**\r\n     * Find testability of a node in the Tree\r\n     * @param elem node\r\n     * @param findInAncestors whether finding testability in ancestors if testability was not found in\r\n     * current node\r\n     */\r\n    findTestabilityInTree(elem: Node, findInAncestors?: boolean): Testability | null;\r\n}\r\n/**\r\n * Adapter interface for retrieving the `Testability` service associated for a\r\n * particular context.\r\n *\r\n * @experimental Testability apis are primarily intended to be used by e2e test tool vendors like\r\n * the Protractor team.\r\n */\r\nexport interface GetTestability {\r\n    addToWindow(registry: TestabilityRegistry): void;\r\n    findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean): Testability | null;\r\n}\r\n/**\r\n * Set the {@link GetTestability} implementation used by the Angular testing framework.\r\n * @experimental\r\n */\r\nexport declare function setTestabilityGetter(getter: GetTestability): void;\r\n",
  "/node_modules/@angular/core/src/type.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @description\r\n *\r\n * Represents a type that a Component or other object is instances of.\r\n *\r\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by\r\n * the `MyCustomComponent` constructor function.\r\n *\r\n *\r\n */\r\nexport declare const Type: FunctionConstructor;\r\nexport declare function isType(v: any): v is Type<any>;\r\nexport interface Type<T> extends Function {\r\n    new (...args: any[]): T;\r\n}\r\n",
  "/node_modules/@angular/core/src/util/decorators.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Type } from '../type';\r\n/**\r\n * An interface implemented by all Angular type decorators, which allows them to be used as ES7\r\n * decorators as well as\r\n * Angular DSL syntax.\r\n *\r\n * ES7 syntax:\r\n *\r\n * ```\r\n * @ng.Component({...})\r\n * class MyClass {...}\r\n * ```\r\n *\r\n */\r\nexport interface TypeDecorator {\r\n    /**\r\n     * Invoke as ES7 decorator.\r\n     */\r\n    <T extends Type<any>>(type: T): T;\r\n    (target: Object, propertyKey?: string | symbol, parameterIndex?: number): void;\r\n}\r\nexport declare const ANNOTATIONS = \"__annotations__\";\r\nexport declare const PARAMETERS = \"__parameters__\";\r\nexport declare const PROP_METADATA = \"__prop__metadata__\";\r\n/**\r\n * @suppress {globalThis}\r\n */\r\nexport declare function makeDecorator<T>(name: string, props?: (...args: any[]) => any, parentClass?: any, additionalProcessing?: (type: Type<T>) => void, typeFn?: (type: Type<T>, ...args: any[]) => void): {\r\n    new (...args: any[]): any;\r\n    (...args: any[]): any;\r\n    (...args: any[]): (cls: any) => any;\r\n};\r\nexport declare function makeParamDecorator(name: string, props?: (...args: any[]) => any, parentClass?: any): any;\r\nexport declare function makePropDecorator(name: string, props?: (...args: any[]) => any, parentClass?: any, additionalProcessing?: (target: any, name: string, ...args: any[]) => void): any;\r\n",
  "/node_modules/@angular/core/src/util/lang.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Observable } from 'rxjs';\r\n/**\r\n * Determine if the argument is shaped like a Promise\r\n */\r\nexport declare function isPromise(obj: any): obj is Promise<any>;\r\n/**\r\n * Determine if the argument is an Observable\r\n */\r\nexport declare function isObservable(obj: any | Observable<any>): obj is Observable<any>;\r\n",
  "/node_modules/@angular/core/src/util/property.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport declare function getClosureSafeProperty<T>(objWithPropertyToExtract: T): string;\r\n/**\r\n * Sets properties on a target object from a source object, but only if\r\n * the property doesn't already exist on the target object.\r\n * @param target The target to set properties on\r\n * @param source The source of the property keys and values to set\r\n */\r\nexport declare function fillProperties(target: {\r\n    [key: string]: string;\r\n}, source: {\r\n    [key: string]: string;\r\n}): void;\r\n",
  "/node_modules/@angular/core/src/util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\ndeclare const _global: {\r\n    [name: string]: any;\r\n};\r\n/**\r\n * Attention: whenever providing a new value, be sure to add an\r\n * entry into the corresponding `....externs.js` file,\r\n * so that closure won't use that global for its purposes.\r\n */\r\nexport { _global as global };\r\nexport declare function getSymbolIterator(): string | symbol;\r\nexport declare function scheduleMicroTask(fn: Function): void;\r\nexport declare function looseIdentical(a: any, b: any): boolean;\r\nexport declare function stringify(token: any): string;\r\n",
  "/node_modules/@angular/core/src/version.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @description Represents the version of Angular\r\n *\r\n *\r\n */\r\nexport declare class Version {\r\n    full: string;\r\n    readonly major: string;\r\n    readonly minor: string;\r\n    readonly patch: string;\r\n    constructor(full: string);\r\n}\r\nexport declare const VERSION: Version;\r\n",
  "/node_modules/@angular/core/src/view/element.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { RendererType2 } from '../render/api';\r\nimport { SecurityContext } from '../sanitization/security';\r\nimport { BindingFlags, ElementData, ElementHandleEventFn, NodeDef, NodeFlags, QueryValueType, ViewData, ViewDefinitionFactory } from './types';\r\nexport declare function anchorDef(flags: NodeFlags, matchedQueriesDsl: null | [string | number, QueryValueType][], ngContentIndex: null | number, childCount: number, handleEvent?: null | ElementHandleEventFn, templateFactory?: ViewDefinitionFactory): NodeDef;\r\nexport declare function elementDef(checkIndex: number, flags: NodeFlags, matchedQueriesDsl: null | [string | number, QueryValueType][], ngContentIndex: null | number, childCount: number, namespaceAndName: string | null, fixedAttrs?: null | [string, string][], bindings?: null | [BindingFlags, string, string | SecurityContext | null][], outputs?: null | ([string, string])[], handleEvent?: null | ElementHandleEventFn, componentView?: null | ViewDefinitionFactory, componentRendererType?: RendererType2 | null): NodeDef;\r\nexport declare function createElement(view: ViewData, renderHost: any, def: NodeDef): ElementData;\r\nexport declare function listenToElementOutputs(view: ViewData, compView: ViewData, def: NodeDef, el: any): void;\r\nexport declare function checkAndUpdateElementInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;\r\nexport declare function checkAndUpdateElementDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;\r\n",
  "/node_modules/@angular/core/src/view/entrypoint.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ComponentFactory } from '../linker/component_factory';\r\nimport { NgModuleFactory } from '../linker/ng_module_factory';\r\nimport { Type } from '../type';\r\nimport { NgModuleDefinitionFactory, ProviderOverride } from './types';\r\nexport declare function overrideProvider(override: ProviderOverride): void;\r\nexport declare function overrideComponentView(comp: Type<any>, componentFactory: ComponentFactory<any>): void;\r\nexport declare function clearOverrides(): void;\r\nexport declare function createNgModuleFactory(ngModuleType: Type<any>, bootstrapComponents: Type<any>[], defFactory: NgModuleDefinitionFactory): NgModuleFactory<any>;\r\n",
  "/node_modules/@angular/core/src/view/errors.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { DebugContext } from './types';\r\nexport declare function expressionChangedAfterItHasBeenCheckedError(context: DebugContext, oldValue: any, currValue: any, isFirstCheck: boolean): Error;\r\nexport declare function viewWrappedDebugError(err: any, context: DebugContext): Error;\r\nexport declare function viewDebugError(msg: string, context: DebugContext): Error;\r\nexport declare function isViewDebugError(err: Error): boolean;\r\nexport declare function viewDestroyedError(action: string): Error;\r\n",
  "/node_modules/@angular/core/src/view/index.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { anchorDef, elementDef } from './element';\r\nexport { clearOverrides, createNgModuleFactory, overrideComponentView, overrideProvider } from './entrypoint';\r\nexport { ngContentDef } from './ng_content';\r\nexport { moduleDef, moduleProvideDef } from './ng_module';\r\nexport { directiveDef, pipeDef, providerDef } from './provider';\r\nexport { pureArrayDef, pureObjectDef, purePipeDef } from './pure_expression';\r\nexport { queryDef } from './query';\r\nexport { ViewRef_, createComponentFactory, getComponentViewDefinitionFactory, nodeValue } from './refs';\r\nexport { initServicesIfNeeded } from './services';\r\nexport { textDef } from './text';\r\nexport { EMPTY_ARRAY, EMPTY_MAP, createRendererType2, elementEventFullName, inlineInterpolate, interpolate, rootRenderNodes, tokenKey, unwrapValue } from './util';\r\nexport { viewDef } from './view';\r\nexport { attachEmbeddedView, detachEmbeddedView, moveEmbeddedView } from './view_attach';\r\nexport * from './types';\r\n",
  "/node_modules/@angular/core/src/view/ng_content.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { NodeDef, ViewData } from './types';\r\nexport declare function ngContentDef(ngContentIndex: null | number, index: number): NodeDef;\r\nexport declare function appendNgContent(view: ViewData, renderHost: any, def: NodeDef): void;\r\n",
  "/node_modules/@angular/core/src/view/ng_module.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { DepDef, DepFlags, NgModuleData, NgModuleDefinition, NgModuleProviderDef, NodeFlags } from './types';\r\nexport declare function moduleProvideDef(flags: NodeFlags, token: any, value: any, deps: ([DepFlags, any] | any)[]): NgModuleProviderDef;\r\nexport declare function moduleDef(providers: NgModuleProviderDef[]): NgModuleDefinition;\r\nexport declare function initNgModule(data: NgModuleData): void;\r\nexport declare function resolveNgModuleDep(data: NgModuleData, depDef: DepDef, notFoundValue?: any): any;\r\nexport declare function callNgModuleLifecycle(ngModule: NgModuleData, lifecycles: NodeFlags): void;\r\n",
  "/node_modules/@angular/core/src/view/provider.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { BindingDef, DepDef, DepFlags, NodeDef, NodeFlags, OutputDef, QueryValueType, ViewData } from './types';\r\nexport declare function directiveDef(checkIndex: number, flags: NodeFlags, matchedQueries: null | [string | number, QueryValueType][], childCount: number, ctor: any, deps: ([DepFlags, any] | any)[], props?: null | {\r\n    [name: string]: [number, string];\r\n}, outputs?: null | {\r\n    [name: string]: string;\r\n}): NodeDef;\r\nexport declare function pipeDef(flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef;\r\nexport declare function providerDef(flags: NodeFlags, matchedQueries: null | [string | number, QueryValueType][], token: any, value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\r\nexport declare function _def(checkIndex: number, flags: NodeFlags, matchedQueriesDsl: [string | number, QueryValueType][] | null, childCount: number, token: any, value: any, deps: ([DepFlags, any] | any)[], bindings?: BindingDef[], outputs?: OutputDef[]): NodeDef;\r\nexport declare function createProviderInstance(view: ViewData, def: NodeDef): any;\r\nexport declare function createPipeInstance(view: ViewData, def: NodeDef): any;\r\nexport declare function createDirectiveInstance(view: ViewData, def: NodeDef): any;\r\nexport declare function checkAndUpdateDirectiveInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;\r\nexport declare function checkAndUpdateDirectiveDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;\r\nexport declare const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR: {};\r\nexport declare function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue?: any): any;\r\nexport declare function callLifecycleHooksChildrenFirst(view: ViewData, lifecycles: NodeFlags): void;\r\n",
  "/node_modules/@angular/core/src/view/pure_expression.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { NodeDef, PureExpressionData, ViewData } from './types';\r\nexport declare function purePipeDef(checkIndex: number, argCount: number): NodeDef;\r\nexport declare function pureArrayDef(checkIndex: number, argCount: number): NodeDef;\r\nexport declare function pureObjectDef(checkIndex: number, propToIndex: {\r\n    [p: string]: number;\r\n}): NodeDef;\r\nexport declare function createPureExpression(view: ViewData, def: NodeDef): PureExpressionData;\r\nexport declare function checkAndUpdatePureExpressionInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;\r\nexport declare function checkAndUpdatePureExpressionDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;\r\n",
  "/node_modules/@angular/core/src/view/query.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { QueryList } from '../linker/query_list';\r\nimport { NodeDef, NodeFlags, QueryBindingType, QueryValueType, ViewData } from './types';\r\nexport declare function queryDef(flags: NodeFlags, id: number, bindings: {\r\n    [propName: string]: QueryBindingType;\r\n}): NodeDef;\r\nexport declare function createQuery(): QueryList<any>;\r\nexport declare function dirtyParentQueries(view: ViewData): void;\r\nexport declare function checkAndUpdateQuery(view: ViewData, nodeDef: NodeDef): void;\r\nexport declare function getQueryValue(view: ViewData, nodeDef: NodeDef, queryValueType: QueryValueType): any;\r\n",
  "/node_modules/@angular/core/src/view/refs.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ApplicationRef } from '../application_ref';\r\nimport { ChangeDetectorRef } from '../change_detection/change_detection';\r\nimport { Injector } from '../di/injector';\r\nimport { ComponentFactory } from '../linker/component_factory';\r\nimport { NgModuleRef } from '../linker/ng_module_factory';\r\nimport { ViewContainerRef } from '../linker/view_container_ref';\r\nimport { EmbeddedViewRef, InternalViewRef } from '../linker/view_ref';\r\nimport { Renderer as RendererV1 } from '../render/api';\r\nimport { Type } from '../type';\r\nimport { ElementData, NgModuleDefinition, NodeDef, TemplateData, ViewContainerData, ViewData, ViewDefinitionFactory } from './types';\r\nexport declare function createComponentFactory(selector: string, componentType: Type<any>, viewDefFactory: ViewDefinitionFactory, inputs: {\r\n    [propName: string]: string;\r\n} | null, outputs: {\r\n    [propName: string]: string;\r\n}, ngContentSelectors: string[]): ComponentFactory<any>;\r\nexport declare function getComponentViewDefinitionFactory(componentFactory: ComponentFactory<any>): ViewDefinitionFactory;\r\nexport declare function createViewContainerData(view: ViewData, elDef: NodeDef, elData: ElementData): ViewContainerData;\r\nexport declare function createChangeDetectorRef(view: ViewData): ChangeDetectorRef;\r\nexport declare class ViewRef_ implements EmbeddedViewRef<any>, InternalViewRef {\r\n    /** @internal */\r\n    _view: ViewData;\r\n    private _viewContainerRef;\r\n    private _appRef;\r\n    constructor(_view: ViewData);\r\n    readonly rootNodes: any[];\r\n    readonly context: any;\r\n    readonly destroyed: boolean;\r\n    markForCheck(): void;\r\n    detach(): void;\r\n    detectChanges(): void;\r\n    checkNoChanges(): void;\r\n    reattach(): void;\r\n    onDestroy(callback: Function): void;\r\n    destroy(): void;\r\n    detachFromAppRef(): void;\r\n    attachToAppRef(appRef: ApplicationRef): void;\r\n    attachToViewContainerRef(vcRef: ViewContainerRef): void;\r\n}\r\nexport declare function createTemplateData(view: ViewData, def: NodeDef): TemplateData;\r\nexport declare function createInjector(view: ViewData, elDef: NodeDef): Injector;\r\nexport declare function nodeValue(view: ViewData, index: number): any;\r\nexport declare function createRendererV1(view: ViewData): RendererV1;\r\nexport declare function createNgModuleRef(moduleType: Type<any>, parent: Injector, bootstrapComponents: Type<any>[], def: NgModuleDefinition): NgModuleRef<any>;\r\n",
  "/node_modules/@angular/core/src/view/services.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Renderer2, RendererFactory2, RendererStyleFlags2, RendererType2 } from '../render/api';\r\nimport { DebugContext } from './types';\r\nexport declare function initServicesIfNeeded(): void;\r\nexport declare function getCurrentDebugContext(): DebugContext | null;\r\nexport declare class DebugRendererFactory2 implements RendererFactory2 {\r\n    private delegate;\r\n    constructor(delegate: RendererFactory2);\r\n    createRenderer(element: any, renderData: RendererType2 | null): Renderer2;\r\n    begin(): void;\r\n    end(): void;\r\n    whenRenderingDone(): Promise<any>;\r\n}\r\nexport declare class DebugRenderer2 implements Renderer2 {\r\n    private delegate;\r\n    readonly data: {\r\n        [key: string]: any;\r\n    };\r\n    /**\r\n     * Factory function used to create a `DebugContext` when a node is created.\r\n     *\r\n     * The `DebugContext` allows to retrieve information about the nodes that are useful in tests.\r\n     *\r\n     * The factory is configurable so that the `DebugRenderer2` could instantiate either a View Engine\r\n     * or a Render context.\r\n     */\r\n    debugContextFactory: () => DebugContext | null;\r\n    private readonly debugContext;\r\n    constructor(delegate: Renderer2);\r\n    destroyNode(node: any): void;\r\n    destroy(): void;\r\n    createElement(name: string, namespace?: string): any;\r\n    createComment(value: string): any;\r\n    createText(value: string): any;\r\n    appendChild(parent: any, newChild: any): void;\r\n    insertBefore(parent: any, newChild: any, refChild: any): void;\r\n    removeChild(parent: any, oldChild: any): void;\r\n    selectRootElement(selectorOrNode: string | any, preserveContent?: boolean): any;\r\n    setAttribute(el: any, name: string, value: string, namespace?: string): void;\r\n    removeAttribute(el: any, name: string, namespace?: string): void;\r\n    addClass(el: any, name: string): void;\r\n    removeClass(el: any, name: string): void;\r\n    setStyle(el: any, style: string, value: any, flags: RendererStyleFlags2): void;\r\n    removeStyle(el: any, style: string, flags: RendererStyleFlags2): void;\r\n    setProperty(el: any, name: string, value: any): void;\r\n    listen(target: 'document' | 'windows' | 'body' | any, eventName: string, callback: (event: any) => boolean): () => void;\r\n    parentNode(node: any): any;\r\n    nextSibling(node: any): any;\r\n    setValue(node: any, value: string): void;\r\n}\r\n",
  "/node_modules/@angular/core/src/view/text.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { NodeDef, TextData, ViewData } from './types';\r\nexport declare function textDef(checkIndex: number, ngContentIndex: number | null, staticText: string[]): NodeDef;\r\nexport declare function createText(view: ViewData, renderHost: any, def: NodeDef): TextData;\r\nexport declare function checkAndUpdateTextInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;\r\nexport declare function checkAndUpdateTextDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;\r\n",
  "/node_modules/@angular/core/src/view/types.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Injector } from '../di';\r\nimport { ErrorHandler } from '../error_handler';\r\nimport { ComponentFactory } from '../linker/component_factory';\r\nimport { NgModuleRef } from '../linker/ng_module_factory';\r\nimport { QueryList } from '../linker/query_list';\r\nimport { TemplateRef } from '../linker/template_ref';\r\nimport { ViewContainerRef } from '../linker/view_container_ref';\r\nimport { Renderer2, RendererFactory2, RendererType2 } from '../render/api';\r\nimport { Sanitizer, SecurityContext } from '../sanitization/security';\r\nimport { Type } from '../type';\r\n/**\r\n * Factory for ViewDefinitions/NgModuleDefinitions.\r\n * We use a function so we can reexeute it in case an error happens and use the given logger\r\n * function to log the error from the definition of the node, which is shown in all browser\r\n * logs.\r\n */\r\nexport interface DefinitionFactory<D extends Definition<any>> {\r\n    (logger: NodeLogger): D;\r\n}\r\n/**\r\n * Function to call console.error at the right source location. This is an indirection\r\n * via another function as browser will log the location that actually called\r\n * `console.error`.\r\n */\r\nexport interface NodeLogger {\r\n    (): () => void;\r\n}\r\nexport interface Definition<DF extends DefinitionFactory<any>> {\r\n    factory: DF | null;\r\n}\r\nexport interface NgModuleDefinition extends Definition<NgModuleDefinitionFactory> {\r\n    providers: NgModuleProviderDef[];\r\n    providersByKey: {\r\n        [tokenKey: string]: NgModuleProviderDef;\r\n    };\r\n    modules: any[];\r\n    isRoot: boolean;\r\n}\r\nexport interface NgModuleDefinitionFactory extends DefinitionFactory<NgModuleDefinition> {\r\n}\r\nexport interface ViewDefinition extends Definition<ViewDefinitionFactory> {\r\n    flags: ViewFlags;\r\n    updateDirectives: ViewUpdateFn;\r\n    updateRenderer: ViewUpdateFn;\r\n    handleEvent: ViewHandleEventFn;\r\n    /**\r\n     * Order: Depth first.\r\n     * Especially providers are before elements / anchors.\r\n     */\r\n    nodes: NodeDef[];\r\n    /** aggregated NodeFlags for all nodes **/\r\n    nodeFlags: NodeFlags;\r\n    rootNodeFlags: NodeFlags;\r\n    lastRenderRootNode: NodeDef | null;\r\n    bindingCount: number;\r\n    outputCount: number;\r\n    /**\r\n     * Binary or of all query ids that are matched by one of the nodes.\r\n     * This includes query ids from templates as well.\r\n     * Used as a bloom filter.\r\n     */\r\n    nodeMatchedQueries: number;\r\n}\r\nexport interface ViewDefinitionFactory extends DefinitionFactory<ViewDefinition> {\r\n}\r\nexport interface ViewUpdateFn {\r\n    (check: NodeCheckFn, view: ViewData): void;\r\n}\r\nexport interface NodeCheckFn {\r\n    (view: ViewData, nodeIndex: number, argStyle: ArgumentType.Dynamic, values: any[]): any;\r\n    (view: ViewData, nodeIndex: number, argStyle: ArgumentType.Inline, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any;\r\n}\r\nexport declare const enum ArgumentType {\r\n    Inline = 0,\r\n    Dynamic = 1\r\n}\r\nexport interface ViewHandleEventFn {\r\n    (view: ViewData, nodeIndex: number, eventName: string, event: any): boolean;\r\n}\r\n/**\r\n * Bitmask for ViewDefinition.flags.\r\n */\r\nexport declare const enum ViewFlags {\r\n    None = 0,\r\n    OnPush = 2\r\n}\r\n/**\r\n * A node definition in the view.\r\n *\r\n * Note: We use one type for all nodes so that loops that loop over all nodes\r\n * of a ViewDefinition stay monomorphic!\r\n */\r\nexport interface NodeDef {\r\n    flags: NodeFlags;\r\n    nodeIndex: number;\r\n    checkIndex: number;\r\n    parent: NodeDef | null;\r\n    renderParent: NodeDef | null;\r\n    /** this is checked against NgContentDef.index to find matched nodes */\r\n    ngContentIndex: number | null;\r\n    /** number of transitive children */\r\n    childCount: number;\r\n    /** aggregated NodeFlags for all transitive children (does not include self) **/\r\n    childFlags: NodeFlags;\r\n    /** aggregated NodeFlags for all direct children (does not include self) **/\r\n    directChildFlags: NodeFlags;\r\n    bindingIndex: number;\r\n    bindings: BindingDef[];\r\n    bindingFlags: BindingFlags;\r\n    outputIndex: number;\r\n    outputs: OutputDef[];\r\n    /**\r\n     * references that the user placed on the element\r\n     */\r\n    references: {\r\n        [refId: string]: QueryValueType;\r\n    };\r\n    /**\r\n     * ids and value types of all queries that are matched by this node.\r\n     */\r\n    matchedQueries: {\r\n        [queryId: number]: QueryValueType;\r\n    };\r\n    /** Binary or of all matched query ids of this node. */\r\n    matchedQueryIds: number;\r\n    /**\r\n     * Binary or of all query ids that are matched by one of the children.\r\n     * This includes query ids from templates as well.\r\n     * Used as a bloom filter.\r\n     */\r\n    childMatchedQueries: number;\r\n    element: ElementDef | null;\r\n    provider: ProviderDef | null;\r\n    text: TextDef | null;\r\n    query: QueryDef | null;\r\n    ngContent: NgContentDef | null;\r\n}\r\n/**\r\n * Bitmask for NodeDef.flags.\r\n * Naming convention:\r\n * - `Type...`: flags that are mutually exclusive\r\n * - `Cat...`: union of multiple `Type...` (short for category).\r\n */\r\nexport declare const enum NodeFlags {\r\n    None = 0,\r\n    TypeElement = 1,\r\n    TypeText = 2,\r\n    ProjectedTemplate = 4,\r\n    CatRenderNode = 3,\r\n    TypeNgContent = 8,\r\n    TypePipe = 16,\r\n    TypePureArray = 32,\r\n    TypePureObject = 64,\r\n    TypePurePipe = 128,\r\n    CatPureExpression = 224,\r\n    TypeValueProvider = 256,\r\n    TypeClassProvider = 512,\r\n    TypeFactoryProvider = 1024,\r\n    TypeUseExistingProvider = 2048,\r\n    LazyProvider = 4096,\r\n    PrivateProvider = 8192,\r\n    TypeDirective = 16384,\r\n    Component = 32768,\r\n    CatProviderNoDirective = 3840,\r\n    CatProvider = 20224,\r\n    OnInit = 65536,\r\n    OnDestroy = 131072,\r\n    DoCheck = 262144,\r\n    OnChanges = 524288,\r\n    AfterContentInit = 1048576,\r\n    AfterContentChecked = 2097152,\r\n    AfterViewInit = 4194304,\r\n    AfterViewChecked = 8388608,\r\n    EmbeddedViews = 16777216,\r\n    ComponentView = 33554432,\r\n    TypeContentQuery = 67108864,\r\n    TypeViewQuery = 134217728,\r\n    StaticQuery = 268435456,\r\n    DynamicQuery = 536870912,\r\n    TypeNgModule = 1073741824,\r\n    CatQuery = 201326592,\r\n    Types = 201347067\r\n}\r\nexport interface BindingDef {\r\n    flags: BindingFlags;\r\n    ns: string | null;\r\n    name: string | null;\r\n    nonMinifiedName: string | null;\r\n    securityContext: SecurityContext | null;\r\n    suffix: string | null;\r\n}\r\nexport declare const enum BindingFlags {\r\n    TypeElementAttribute = 1,\r\n    TypeElementClass = 2,\r\n    TypeElementStyle = 4,\r\n    TypeProperty = 8,\r\n    SyntheticProperty = 16,\r\n    SyntheticHostProperty = 32,\r\n    CatSyntheticProperty = 48,\r\n    Types = 15\r\n}\r\nexport interface OutputDef {\r\n    type: OutputType;\r\n    target: 'window' | 'document' | 'body' | 'component' | null;\r\n    eventName: string;\r\n    propName: string | null;\r\n}\r\nexport declare const enum OutputType {\r\n    ElementOutput = 0,\r\n    DirectiveOutput = 1\r\n}\r\nexport declare const enum QueryValueType {\r\n    ElementRef = 0,\r\n    RenderElement = 1,\r\n    TemplateRef = 2,\r\n    ViewContainerRef = 3,\r\n    Provider = 4\r\n}\r\nexport interface ElementDef {\r\n    name: string | null;\r\n    ns: string | null;\r\n    /** ns, name, value */\r\n    attrs: [string, string, string][] | null;\r\n    template: ViewDefinition | null;\r\n    componentProvider: NodeDef | null;\r\n    componentRendererType: RendererType2 | null;\r\n    componentView: ViewDefinitionFactory | null;\r\n    /**\r\n     * visible public providers for DI in the view,\r\n     * as see from this element. This does not include private providers.\r\n     */\r\n    publicProviders: {\r\n        [tokenKey: string]: NodeDef;\r\n    } | null;\r\n    /**\r\n     * same as visiblePublicProviders, but also includes private providers\r\n     * that are located on this element.\r\n     */\r\n    allProviders: {\r\n        [tokenKey: string]: NodeDef;\r\n    } | null;\r\n    handleEvent: ElementHandleEventFn | null;\r\n}\r\nexport interface ElementHandleEventFn {\r\n    (view: ViewData, eventName: string, event: any): boolean;\r\n}\r\nexport interface ProviderDef {\r\n    token: any;\r\n    value: any;\r\n    deps: DepDef[];\r\n}\r\nexport interface NgModuleProviderDef {\r\n    flags: NodeFlags;\r\n    index: number;\r\n    token: any;\r\n    value: any;\r\n    deps: DepDef[];\r\n}\r\nexport interface DepDef {\r\n    flags: DepFlags;\r\n    token: any;\r\n    tokenKey: string;\r\n}\r\n/**\r\n * Bitmask for DI flags\r\n */\r\nexport declare const enum DepFlags {\r\n    None = 0,\r\n    SkipSelf = 1,\r\n    Optional = 2,\r\n    Self = 4,\r\n    Value = 8\r\n}\r\nexport interface TextDef {\r\n    prefix: string;\r\n}\r\nexport interface QueryDef {\r\n    id: number;\r\n    filterId: number;\r\n    bindings: QueryBindingDef[];\r\n}\r\nexport interface QueryBindingDef {\r\n    propName: string;\r\n    bindingType: QueryBindingType;\r\n}\r\nexport declare const enum QueryBindingType {\r\n    First = 0,\r\n    All = 1\r\n}\r\nexport interface NgContentDef {\r\n    /**\r\n     * this index is checked against NodeDef.ngContentIndex to find the nodes\r\n     * that are matched by this ng-content.\r\n     * Note that a NodeDef with an ng-content can be reprojected, i.e.\r\n     * have a ngContentIndex on its own.\r\n     */\r\n    index: number;\r\n}\r\nexport interface NgModuleData extends Injector, NgModuleRef<any> {\r\n    _def: NgModuleDefinition;\r\n    _parent: Injector;\r\n    _providers: any[];\r\n}\r\n/**\r\n * View instance data.\r\n * Attention: Adding fields to this is performance sensitive!\r\n */\r\nexport interface ViewData {\r\n    def: ViewDefinition;\r\n    root: RootData;\r\n    renderer: Renderer2;\r\n    parentNodeDef: NodeDef | null;\r\n    parent: ViewData | null;\r\n    viewContainerParent: ViewData | null;\r\n    component: any;\r\n    context: any;\r\n    nodes: {\r\n        [key: number]: NodeData;\r\n    };\r\n    state: ViewState;\r\n    oldValues: any[];\r\n    disposables: DisposableFn[] | null;\r\n    initIndex: number;\r\n}\r\n/**\r\n * Bitmask of states\r\n */\r\nexport declare const enum ViewState {\r\n    BeforeFirstCheck = 1,\r\n    FirstCheck = 2,\r\n    Attached = 4,\r\n    ChecksEnabled = 8,\r\n    IsProjectedView = 16,\r\n    CheckProjectedView = 32,\r\n    CheckProjectedViews = 64,\r\n    Destroyed = 128,\r\n    InitState_Mask = 1792,\r\n    InitState_BeforeInit = 0,\r\n    InitState_CallingOnInit = 256,\r\n    InitState_CallingAfterContentInit = 512,\r\n    InitState_CallingAfterViewInit = 768,\r\n    InitState_AfterInit = 1024,\r\n    CatDetectChanges = 12,\r\n    CatInit = 13\r\n}\r\nexport declare function shiftInitState(view: ViewData, priorInitState: ViewState, newInitState: ViewState): boolean;\r\nexport declare function shouldCallLifecycleInitHook(view: ViewData, initState: ViewState, index: number): boolean;\r\nexport interface DisposableFn {\r\n    (): void;\r\n}\r\n/**\r\n * Node instance data.\r\n *\r\n * We have a separate type per NodeType to save memory\r\n * (TextData | ElementData | ProviderData | PureExpressionData | QueryList<any>)\r\n *\r\n * To keep our code monomorphic,\r\n * we prohibit using `NodeData` directly but enforce the use of accessors (`asElementData`, ...).\r\n * This way, no usage site can get a `NodeData` from view.nodes and then use it for different\r\n * purposes.\r\n */\r\nexport declare class NodeData {\r\n    private __brand;\r\n}\r\n/**\r\n * Data for an instantiated NodeType.Text.\r\n *\r\n * Attention: Adding fields to this is performance sensitive!\r\n */\r\nexport interface TextData {\r\n    renderText: any;\r\n}\r\n/**\r\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\r\n */\r\nexport declare function asTextData(view: ViewData, index: number): TextData;\r\n/**\r\n * Data for an instantiated NodeType.Element.\r\n *\r\n * Attention: Adding fields to this is performance sensitive!\r\n */\r\nexport interface ElementData {\r\n    renderElement: any;\r\n    componentView: ViewData;\r\n    viewContainer: ViewContainerData | null;\r\n    template: TemplateData;\r\n}\r\nexport interface ViewContainerData extends ViewContainerRef {\r\n    _embeddedViews: ViewData[];\r\n}\r\nexport interface TemplateData extends TemplateRef<any> {\r\n    _projectedViews: ViewData[];\r\n}\r\n/**\r\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\r\n */\r\nexport declare function asElementData(view: ViewData, index: number): ElementData;\r\n/**\r\n * Data for an instantiated NodeType.Provider.\r\n *\r\n * Attention: Adding fields to this is performance sensitive!\r\n */\r\nexport interface ProviderData {\r\n    instance: any;\r\n}\r\n/**\r\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\r\n */\r\nexport declare function asProviderData(view: ViewData, index: number): ProviderData;\r\n/**\r\n * Data for an instantiated NodeType.PureExpression.\r\n *\r\n * Attention: Adding fields to this is performance sensitive!\r\n */\r\nexport interface PureExpressionData {\r\n    value: any;\r\n}\r\n/**\r\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\r\n */\r\nexport declare function asPureExpressionData(view: ViewData, index: number): PureExpressionData;\r\n/**\r\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\r\n */\r\nexport declare function asQueryList(view: ViewData, index: number): QueryList<any>;\r\nexport interface RootData {\r\n    injector: Injector;\r\n    ngModule: NgModuleRef<any>;\r\n    projectableNodes: any[][];\r\n    selectorOrNode: any;\r\n    renderer: Renderer2;\r\n    rendererFactory: RendererFactory2;\r\n    errorHandler: ErrorHandler;\r\n    sanitizer: Sanitizer;\r\n}\r\nexport declare abstract class DebugContext {\r\n    abstract readonly view: ViewData;\r\n    abstract readonly nodeIndex: number | null;\r\n    abstract readonly injector: Injector;\r\n    abstract readonly component: any;\r\n    abstract readonly providerTokens: any[];\r\n    abstract readonly references: {\r\n        [key: string]: any;\r\n    };\r\n    abstract readonly context: any;\r\n    abstract readonly componentRenderElement: any;\r\n    abstract readonly renderNode: any;\r\n    abstract logError(console: Console, ...values: any[]): void;\r\n}\r\nexport declare const enum CheckType {\r\n    CheckAndUpdate = 0,\r\n    CheckNoChanges = 1\r\n}\r\nexport interface ProviderOverride {\r\n    token: any;\r\n    flags: NodeFlags;\r\n    value: any;\r\n    deps: ([DepFlags, any] | any)[];\r\n    deprecatedBehavior: boolean;\r\n}\r\nexport interface Services {\r\n    setCurrentNode(view: ViewData, nodeIndex: number): void;\r\n    createRootView(injector: Injector, projectableNodes: any[][], rootSelectorOrNode: string | any, def: ViewDefinition, ngModule: NgModuleRef<any>, context?: any): ViewData;\r\n    createEmbeddedView(parent: ViewData, anchorDef: NodeDef, viewDef: ViewDefinition, context?: any): ViewData;\r\n    createComponentView(parentView: ViewData, nodeDef: NodeDef, viewDef: ViewDefinition, hostElement: any): ViewData;\r\n    createNgModuleRef(moduleType: Type<any>, parent: Injector, bootstrapComponents: Type<any>[], def: NgModuleDefinition): NgModuleRef<any>;\r\n    overrideProvider(override: ProviderOverride): void;\r\n    overrideComponentView(compType: Type<any>, compFactory: ComponentFactory<any>): void;\r\n    clearOverrides(): void;\r\n    checkAndUpdateView(view: ViewData): void;\r\n    checkNoChangesView(view: ViewData): void;\r\n    destroyView(view: ViewData): void;\r\n    resolveDep(view: ViewData, elDef: NodeDef | null, allowPrivateServices: boolean, depDef: DepDef, notFoundValue?: any): any;\r\n    createDebugContext(view: ViewData, nodeIndex: number): DebugContext;\r\n    handleEvent: ViewHandleEventFn;\r\n    updateDirectives: (view: ViewData, checkType: CheckType) => void;\r\n    updateRenderer: (view: ViewData, checkType: CheckType) => void;\r\n    dirtyParentQueries: (view: ViewData) => void;\r\n}\r\n/**\r\n * This object is used to prevent cycles in the source files and to have a place where\r\n * debug mode can hook it. It is lazily filled when `isDevMode` is known.\r\n */\r\nexport declare const Services: Services;\r\n",
  "/node_modules/@angular/core/src/view/util.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ViewEncapsulation } from '../metadata/view';\r\nimport { RendererType2 } from '../render/api';\r\nimport { BindingDef, BindingFlags, Definition, DefinitionFactory, DepDef, DepFlags, ElementData, NodeDef, QueryValueType, ViewData } from './types';\r\nexport declare const NOOP: any;\r\nexport declare function tokenKey(token: any): string;\r\nexport declare function unwrapValue(view: ViewData, nodeIdx: number, bindingIdx: number, value: any): any;\r\nexport declare function createRendererType2(values: {\r\n    styles: (string | any[])[];\r\n    encapsulation: ViewEncapsulation;\r\n    data: {\r\n        [kind: string]: any[];\r\n    };\r\n}): RendererType2;\r\nexport declare function resolveRendererType2(type?: RendererType2 | null): RendererType2 | null;\r\nexport declare function checkBinding(view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean;\r\nexport declare function checkAndUpdateBinding(view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean;\r\nexport declare function checkBindingNoChanges(view: ViewData, def: NodeDef, bindingIdx: number, value: any): void;\r\nexport declare function markParentViewsForCheck(view: ViewData): void;\r\nexport declare function markParentViewsForCheckProjectedViews(view: ViewData, endView: ViewData): void;\r\nexport declare function dispatchEvent(view: ViewData, nodeIndex: number, eventName: string, event: any): boolean | undefined;\r\nexport declare function declaredViewContainer(view: ViewData): ElementData | null;\r\n/**\r\n * for component views, this is the host element.\r\n * for embedded views, this is the index of the parent node\r\n * that contains the view container.\r\n */\r\nexport declare function viewParentEl(view: ViewData): NodeDef | null;\r\nexport declare function renderNode(view: ViewData, def: NodeDef): any;\r\nexport declare function elementEventFullName(target: string | null, name: string): string;\r\nexport declare function isComponentView(view: ViewData): boolean;\r\nexport declare function isEmbeddedView(view: ViewData): boolean;\r\nexport declare function filterQueryId(queryId: number): number;\r\nexport declare function splitMatchedQueriesDsl(matchedQueriesDsl: [string | number, QueryValueType][] | null): {\r\n    matchedQueries: {\r\n        [queryId: string]: QueryValueType;\r\n    };\r\n    references: {\r\n        [refId: string]: QueryValueType;\r\n    };\r\n    matchedQueryIds: number;\r\n};\r\nexport declare function splitDepsDsl(deps: ([DepFlags, any] | any)[], sourceName?: string): DepDef[];\r\nexport declare function getParentRenderElement(view: ViewData, renderHost: any, def: NodeDef): any;\r\nexport declare function resolveDefinition<D extends Definition<any>>(factory: DefinitionFactory<D>): D;\r\nexport declare function rootRenderNodes(view: ViewData): any[];\r\nexport declare const enum RenderNodeAction {\r\n    Collect = 0,\r\n    AppendChild = 1,\r\n    InsertBefore = 2,\r\n    RemoveChild = 3\r\n}\r\nexport declare function visitRootRenderNodes(view: ViewData, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]): void;\r\nexport declare function visitSiblingRenderNodes(view: ViewData, action: RenderNodeAction, startIndex: number, endIndex: number, parentNode: any, nextSibling: any, target?: any[]): void;\r\nexport declare function visitProjectedRenderNodes(view: ViewData, ngContentIndex: number, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]): void;\r\nexport declare function splitNamespace(name: string): string[];\r\nexport declare function calcBindingFlags(bindings: BindingDef[]): BindingFlags;\r\nexport declare function interpolate(valueCount: number, constAndInterp: string[]): string;\r\nexport declare function inlineInterpolate(valueCount: number, c0: string, a1: any, c1: string, a2?: any, c2?: string, a3?: any, c3?: string, a4?: any, c4?: string, a5?: any, c5?: string, a6?: any, c6?: string, a7?: any, c7?: string, a8?: any, c8?: string, a9?: any, c9?: string): string;\r\nexport declare const EMPTY_ARRAY: any[];\r\nexport declare const EMPTY_MAP: {\r\n    [key: string]: any;\r\n};\r\n",
  "/node_modules/@angular/core/src/view/view.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ArgumentType, NodeDef, RootData, ViewData, ViewDefinition, ViewFlags, ViewUpdateFn } from './types';\r\nexport declare function viewDef(flags: ViewFlags, nodes: NodeDef[], updateDirectives?: null | ViewUpdateFn, updateRenderer?: null | ViewUpdateFn): ViewDefinition;\r\nexport declare function createEmbeddedView(parent: ViewData, anchorDef: NodeDef, viewDef: ViewDefinition, context?: any): ViewData;\r\nexport declare function createRootView(root: RootData, def: ViewDefinition, context?: any): ViewData;\r\nexport declare function createComponentView(parentView: ViewData, nodeDef: NodeDef, viewDef: ViewDefinition, hostElement: any): ViewData;\r\nexport declare function checkNoChangesView(view: ViewData): void;\r\nexport declare function checkAndUpdateView(view: ViewData): void;\r\nexport declare function checkAndUpdateNode(view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): boolean;\r\nexport declare function checkNoChangesNode(view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any;\r\nexport declare function destroyView(view: ViewData): void;\r\n",
  "/node_modules/@angular/core/src/view/view_attach.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ElementData, ViewData } from './types';\r\nexport declare function attachEmbeddedView(parentView: ViewData, elementData: ElementData, viewIndex: number | undefined | null, view: ViewData): void;\r\nexport declare function detachEmbeddedView(elementData: ElementData, viewIndex?: number): ViewData | null;\r\nexport declare function detachProjectedView(view: ViewData): void;\r\nexport declare function moveEmbeddedView(elementData: ElementData, oldViewIndex: number, newViewIndex: number): ViewData;\r\nexport declare function renderDetachView(view: ViewData): void;\r\n",
  "/node_modules/@angular/core/src/zone/ng_zone.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { EventEmitter } from '../event_emitter';\r\n/**\r\n * An injectable service for executing work inside or outside of the Angular zone.\r\n *\r\n * The most common use of this service is to optimize performance when starting a work consisting of\r\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\r\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\r\n * can reenter the Angular zone via {@link #run}.\r\n *\r\n * <!-- TODO: add/fix links to:\r\n *   - docs explaining zones and the use of zones in Angular and change-detection\r\n *   - link to runOutsideAngular/run (throughout this file!)\r\n *   -->\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```\r\n * import {Component, NgZone} from '@angular/core';\r\n * import {NgIf} from '@angular/common';\r\n *\r\n * @Component({\r\n *   selector: 'ng-zone-demo',\r\n *   template: `\r\n *     <h2>Demo: NgZone</h2>\r\n *\r\n *     <p>Progress: {{progress}}%</p>\r\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\r\n *\r\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\r\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\r\n *   `,\r\n * })\r\n * export class NgZoneDemo {\r\n *   progress: number = 0;\r\n *   label: string;\r\n *\r\n *   constructor(private _ngZone: NgZone) {}\r\n *\r\n *   // Loop inside the Angular zone\r\n *   // so the UI DOES refresh after each setTimeout cycle\r\n *   processWithinAngularZone() {\r\n *     this.label = 'inside';\r\n *     this.progress = 0;\r\n *     this._increaseProgress(() => console.log('Inside Done!'));\r\n *   }\r\n *\r\n *   // Loop outside of the Angular zone\r\n *   // so the UI DOES NOT refresh after each setTimeout cycle\r\n *   processOutsideOfAngularZone() {\r\n *     this.label = 'outside';\r\n *     this.progress = 0;\r\n *     this._ngZone.runOutsideAngular(() => {\r\n *       this._increaseProgress(() => {\r\n *         // reenter the Angular zone and display done\r\n *         this._ngZone.run(() => { console.log('Outside Done!'); });\r\n *       });\r\n *     });\r\n *   }\r\n *\r\n *   _increaseProgress(doneCallback: () => void) {\r\n *     this.progress += 1;\r\n *     console.log(`Current progress: ${this.progress}%`);\r\n *\r\n *     if (this.progress < 100) {\r\n *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);\r\n *     } else {\r\n *       doneCallback();\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @experimental\r\n */\r\nexport declare class NgZone {\r\n    readonly hasPendingMicrotasks: boolean;\r\n    readonly hasPendingMacrotasks: boolean;\r\n    /**\r\n     * Whether there are no outstanding microtasks or macrotasks.\r\n     */\r\n    readonly isStable: boolean;\r\n    /**\r\n     * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\r\n     */\r\n    readonly onUnstable: EventEmitter<any>;\r\n    /**\r\n     * Notifies when there is no more microtasks enqueued in the current VM Turn.\r\n     * This is a hint for Angular to do change detection, which may enqueue more microtasks.\r\n     * For this reason this event can fire multiple times per VM Turn.\r\n     */\r\n    readonly onMicrotaskEmpty: EventEmitter<any>;\r\n    /**\r\n     * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\r\n     * implies we are about to relinquish VM turn.\r\n     * This event gets called just once.\r\n     */\r\n    readonly onStable: EventEmitter<any>;\r\n    /**\r\n     * Notifies that an error has been delivered.\r\n     */\r\n    readonly onError: EventEmitter<any>;\r\n    constructor({ enableLongStackTrace }: {\r\n        enableLongStackTrace?: boolean;\r\n    });\r\n    static isInAngularZone(): boolean;\r\n    static assertInAngularZone(): void;\r\n    static assertNotInAngularZone(): void;\r\n    /**\r\n     * Executes the `fn` function synchronously within the Angular zone and returns value returned by\r\n     * the function.\r\n     *\r\n     * Running functions via `run` allows you to reenter Angular zone from a task that was executed\r\n     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\r\n     *\r\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\r\n     * within the Angular zone.\r\n     *\r\n     * If a synchronous error happens it will be rethrown and not reported via `onError`.\r\n     */\r\n    run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;\r\n    /**\r\n     * Executes the `fn` function synchronously within the Angular zone as a task and returns value\r\n     * returned by the function.\r\n     *\r\n     * Running functions via `run` allows you to reenter Angular zone from a task that was executed\r\n     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\r\n     *\r\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\r\n     * within the Angular zone.\r\n     *\r\n     * If a synchronous error happens it will be rethrown and not reported via `onError`.\r\n     */\r\n    runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[], name?: string): T;\r\n    /**\r\n     * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\r\n     * rethrown.\r\n     */\r\n    runGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;\r\n    /**\r\n     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\r\n     * the function.\r\n     *\r\n     * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\r\n     * work that\r\n     * doesn't trigger Angular change-detection or is subject to Angular's error handling.\r\n     *\r\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\r\n     * outside of the Angular zone.\r\n     *\r\n     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\r\n     */\r\n    runOutsideAngular<T>(fn: (...args: any[]) => T): T;\r\n}\r\n/**\r\n * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls\r\n * to framework to perform rendering.\r\n */\r\nexport declare class NoopNgZone implements NgZone {\r\n    readonly hasPendingMicrotasks: boolean;\r\n    readonly hasPendingMacrotasks: boolean;\r\n    readonly isStable: boolean;\r\n    readonly onUnstable: EventEmitter<any>;\r\n    readonly onMicrotaskEmpty: EventEmitter<any>;\r\n    readonly onStable: EventEmitter<any>;\r\n    readonly onError: EventEmitter<any>;\r\n    run(fn: () => any): any;\r\n    runGuarded(fn: () => any): any;\r\n    runOutsideAngular(fn: () => any): any;\r\n    runTask<T>(fn: () => any): any;\r\n}\r\n",
  "/node_modules/@angular/core/src/zone.d.ts": "/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nexport { NgZone, NoopNgZone as NoopNgZone } from './zone/ng_zone';\r\n"
}